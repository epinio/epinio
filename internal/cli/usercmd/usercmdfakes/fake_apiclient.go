// Copyright Â© 2021 - 2023 SUSE LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by counterfeiter. DO NOT EDIT.
package usercmdfakes

import (
	"context"
	"net/http"
	"sync"

	"github.com/epinio/epinio/helpers/kubernetes/tailer"
	"github.com/epinio/epinio/internal/cli/usercmd"
	"github.com/epinio/epinio/pkg/api/core/v1/client"
	"github.com/epinio/epinio/pkg/api/core/v1/models"
	"k8s.io/kubectl/pkg/util/term"
)

type FakeAPIClient struct {
	AllAppsStub        func() (models.AppList, error)
	allAppsMutex       sync.RWMutex
	allAppsArgsForCall []struct {
	}
	allAppsReturns struct {
		result1 models.AppList
		result2 error
	}
	allAppsReturnsOnCall map[int]struct {
		result1 models.AppList
		result2 error
	}
	AllConfigurationsStub        func() (models.ConfigurationResponseList, error)
	allConfigurationsMutex       sync.RWMutex
	allConfigurationsArgsForCall []struct {
	}
	allConfigurationsReturns struct {
		result1 models.ConfigurationResponseList
		result2 error
	}
	allConfigurationsReturnsOnCall map[int]struct {
		result1 models.ConfigurationResponseList
		result2 error
	}
	AllServicesStub        func() (models.ServiceList, error)
	allServicesMutex       sync.RWMutex
	allServicesArgsForCall []struct {
	}
	allServicesReturns struct {
		result1 models.ServiceList
		result2 error
	}
	allServicesReturnsOnCall map[int]struct {
		result1 models.ServiceList
		result2 error
	}
	AppCreateStub        func(models.ApplicationCreateRequest, string) (models.Response, error)
	appCreateMutex       sync.RWMutex
	appCreateArgsForCall []struct {
		arg1 models.ApplicationCreateRequest
		arg2 string
	}
	appCreateReturns struct {
		result1 models.Response
		result2 error
	}
	appCreateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppDeleteStub        func(string, []string) (models.ApplicationDeleteResponse, error)
	appDeleteMutex       sync.RWMutex
	appDeleteArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	appDeleteReturns struct {
		result1 models.ApplicationDeleteResponse
		result2 error
	}
	appDeleteReturnsOnCall map[int]struct {
		result1 models.ApplicationDeleteResponse
		result2 error
	}
	AppDeployStub        func(models.DeployRequest) (*models.DeployResponse, error)
	appDeployMutex       sync.RWMutex
	appDeployArgsForCall []struct {
		arg1 models.DeployRequest
	}
	appDeployReturns struct {
		result1 *models.DeployResponse
		result2 error
	}
	appDeployReturnsOnCall map[int]struct {
		result1 *models.DeployResponse
		result2 error
	}
	AppExecStub        func(context.Context, string, string, string, term.TTY) error
	appExecMutex       sync.RWMutex
	appExecArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 term.TTY
	}
	appExecReturns struct {
		result1 error
	}
	appExecReturnsOnCall map[int]struct {
		result1 error
	}
	AppExportStub        func(string, string, models.AppExportRequest) (models.Response, error)
	appExportMutex       sync.RWMutex
	appExportArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.AppExportRequest
	}
	appExportReturns struct {
		result1 models.Response
		result2 error
	}
	appExportReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppGetPartStub        func(string, string, string) (models.AppPartResponse, error)
	appGetPartMutex       sync.RWMutex
	appGetPartArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	appGetPartReturns struct {
		result1 models.AppPartResponse
		result2 error
	}
	appGetPartReturnsOnCall map[int]struct {
		result1 models.AppPartResponse
		result2 error
	}
	AppImportGitStub        func(string, string, models.GitRef) (models.ImportGitResponse, error)
	appImportGitMutex       sync.RWMutex
	appImportGitArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.GitRef
	}
	appImportGitReturns struct {
		result1 models.ImportGitResponse
		result2 error
	}
	appImportGitReturnsOnCall map[int]struct {
		result1 models.ImportGitResponse
		result2 error
	}
	AppLogsStub        func(string, string, string, bool, func(tailer.ContainerLogLine)) error
	appLogsMutex       sync.RWMutex
	appLogsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 bool
		arg5 func(tailer.ContainerLogLine)
	}
	appLogsReturns struct {
		result1 error
	}
	appLogsReturnsOnCall map[int]struct {
		result1 error
	}
	AppMatchStub        func(string, string) (models.AppMatchResponse, error)
	appMatchMutex       sync.RWMutex
	appMatchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appMatchReturns struct {
		result1 models.AppMatchResponse
		result2 error
	}
	appMatchReturnsOnCall map[int]struct {
		result1 models.AppMatchResponse
		result2 error
	}
	AppPortForwardStub        func(string, string, string, *client.PortForwardOpts) error
	appPortForwardMutex       sync.RWMutex
	appPortForwardArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *client.PortForwardOpts
	}
	appPortForwardReturns struct {
		result1 error
	}
	appPortForwardReturnsOnCall map[int]struct {
		result1 error
	}
	AppRestartStub        func(string, string) (models.Response, error)
	appRestartMutex       sync.RWMutex
	appRestartArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appRestartReturns struct {
		result1 models.Response
		result2 error
	}
	appRestartReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppRunningStub        func(models.AppRef) (models.Response, error)
	appRunningMutex       sync.RWMutex
	appRunningArgsForCall []struct {
		arg1 models.AppRef
	}
	appRunningReturns struct {
		result1 models.Response
		result2 error
	}
	appRunningReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppShowStub        func(string, string) (models.App, error)
	appShowMutex       sync.RWMutex
	appShowArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appShowReturns struct {
		result1 models.App
		result2 error
	}
	appShowReturnsOnCall map[int]struct {
		result1 models.App
		result2 error
	}
	AppStageStub        func(models.StageRequest) (*models.StageResponse, error)
	appStageMutex       sync.RWMutex
	appStageArgsForCall []struct {
		arg1 models.StageRequest
	}
	appStageReturns struct {
		result1 *models.StageResponse
		result2 error
	}
	appStageReturnsOnCall map[int]struct {
		result1 *models.StageResponse
		result2 error
	}
	AppUpdateStub        func(models.ApplicationUpdateRequest, string, string) (models.Response, error)
	appUpdateMutex       sync.RWMutex
	appUpdateArgsForCall []struct {
		arg1 models.ApplicationUpdateRequest
		arg2 string
		arg3 string
	}
	appUpdateReturns struct {
		result1 models.Response
		result2 error
	}
	appUpdateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppUploadStub        func(string, string, client.FormFile) (models.UploadResponse, error)
	appUploadMutex       sync.RWMutex
	appUploadArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 client.FormFile
	}
	appUploadReturns struct {
		result1 models.UploadResponse
		result2 error
	}
	appUploadReturnsOnCall map[int]struct {
		result1 models.UploadResponse
		result2 error
	}
	AppValidateCVStub        func(string, string) (models.Response, error)
	appValidateCVMutex       sync.RWMutex
	appValidateCVArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appValidateCVReturns struct {
		result1 models.Response
		result2 error
	}
	appValidateCVReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppsStub        func(string) (models.AppList, error)
	appsMutex       sync.RWMutex
	appsArgsForCall []struct {
		arg1 string
	}
	appsReturns struct {
		result1 models.AppList
		result2 error
	}
	appsReturnsOnCall map[int]struct {
		result1 models.AppList
		result2 error
	}
	AuthTokenStub        func() (models.AuthTokenResponse, error)
	authTokenMutex       sync.RWMutex
	authTokenArgsForCall []struct {
	}
	authTokenReturns struct {
		result1 models.AuthTokenResponse
		result2 error
	}
	authTokenReturnsOnCall map[int]struct {
		result1 models.AuthTokenResponse
		result2 error
	}
	ChartListStub        func() ([]models.AppChart, error)
	chartListMutex       sync.RWMutex
	chartListArgsForCall []struct {
	}
	chartListReturns struct {
		result1 []models.AppChart
		result2 error
	}
	chartListReturnsOnCall map[int]struct {
		result1 []models.AppChart
		result2 error
	}
	ChartMatchStub        func(string) (models.ChartMatchResponse, error)
	chartMatchMutex       sync.RWMutex
	chartMatchArgsForCall []struct {
		arg1 string
	}
	chartMatchReturns struct {
		result1 models.ChartMatchResponse
		result2 error
	}
	chartMatchReturnsOnCall map[int]struct {
		result1 models.ChartMatchResponse
		result2 error
	}
	ChartShowStub        func(string) (models.AppChart, error)
	chartShowMutex       sync.RWMutex
	chartShowArgsForCall []struct {
		arg1 string
	}
	chartShowReturns struct {
		result1 models.AppChart
		result2 error
	}
	chartShowReturnsOnCall map[int]struct {
		result1 models.AppChart
		result2 error
	}
	ConfigurationAppsStub        func(string) (models.ConfigurationAppsResponse, error)
	configurationAppsMutex       sync.RWMutex
	configurationAppsArgsForCall []struct {
		arg1 string
	}
	configurationAppsReturns struct {
		result1 models.ConfigurationAppsResponse
		result2 error
	}
	configurationAppsReturnsOnCall map[int]struct {
		result1 models.ConfigurationAppsResponse
		result2 error
	}
	ConfigurationBindingCreateStub        func(models.BindRequest, string, string) (models.BindResponse, error)
	configurationBindingCreateMutex       sync.RWMutex
	configurationBindingCreateArgsForCall []struct {
		arg1 models.BindRequest
		arg2 string
		arg3 string
	}
	configurationBindingCreateReturns struct {
		result1 models.BindResponse
		result2 error
	}
	configurationBindingCreateReturnsOnCall map[int]struct {
		result1 models.BindResponse
		result2 error
	}
	ConfigurationBindingDeleteStub        func(string, string, string) (models.Response, error)
	configurationBindingDeleteMutex       sync.RWMutex
	configurationBindingDeleteArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	configurationBindingDeleteReturns struct {
		result1 models.Response
		result2 error
	}
	configurationBindingDeleteReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ConfigurationCreateStub        func(models.ConfigurationCreateRequest, string) (models.Response, error)
	configurationCreateMutex       sync.RWMutex
	configurationCreateArgsForCall []struct {
		arg1 models.ConfigurationCreateRequest
		arg2 string
	}
	configurationCreateReturns struct {
		result1 models.Response
		result2 error
	}
	configurationCreateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ConfigurationDeleteStub        func(models.ConfigurationDeleteRequest, string, []string) (models.ConfigurationDeleteResponse, error)
	configurationDeleteMutex       sync.RWMutex
	configurationDeleteArgsForCall []struct {
		arg1 models.ConfigurationDeleteRequest
		arg2 string
		arg3 []string
	}
	configurationDeleteReturns struct {
		result1 models.ConfigurationDeleteResponse
		result2 error
	}
	configurationDeleteReturnsOnCall map[int]struct {
		result1 models.ConfigurationDeleteResponse
		result2 error
	}
	ConfigurationMatchStub        func(string, string) (models.ConfigurationMatchResponse, error)
	configurationMatchMutex       sync.RWMutex
	configurationMatchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	configurationMatchReturns struct {
		result1 models.ConfigurationMatchResponse
		result2 error
	}
	configurationMatchReturnsOnCall map[int]struct {
		result1 models.ConfigurationMatchResponse
		result2 error
	}
	ConfigurationShowStub        func(string, string) (models.ConfigurationResponse, error)
	configurationShowMutex       sync.RWMutex
	configurationShowArgsForCall []struct {
		arg1 string
		arg2 string
	}
	configurationShowReturns struct {
		result1 models.ConfigurationResponse
		result2 error
	}
	configurationShowReturnsOnCall map[int]struct {
		result1 models.ConfigurationResponse
		result2 error
	}
	ConfigurationUpdateStub        func(models.ConfigurationUpdateRequest, string, string) (models.Response, error)
	configurationUpdateMutex       sync.RWMutex
	configurationUpdateArgsForCall []struct {
		arg1 models.ConfigurationUpdateRequest
		arg2 string
		arg3 string
	}
	configurationUpdateReturns struct {
		result1 models.Response
		result2 error
	}
	configurationUpdateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ConfigurationsStub        func(string) (models.ConfigurationResponseList, error)
	configurationsMutex       sync.RWMutex
	configurationsArgsForCall []struct {
		arg1 string
	}
	configurationsReturns struct {
		result1 models.ConfigurationResponseList
		result2 error
	}
	configurationsReturnsOnCall map[int]struct {
		result1 models.ConfigurationResponseList
		result2 error
	}
	DisableVersionWarningStub        func()
	disableVersionWarningMutex       sync.RWMutex
	disableVersionWarningArgsForCall []struct {
	}
	EnvListStub        func(string, string) (models.EnvVariableMap, error)
	envListMutex       sync.RWMutex
	envListArgsForCall []struct {
		arg1 string
		arg2 string
	}
	envListReturns struct {
		result1 models.EnvVariableMap
		result2 error
	}
	envListReturnsOnCall map[int]struct {
		result1 models.EnvVariableMap
		result2 error
	}
	EnvMatchStub        func(string, string, string) (models.EnvMatchResponse, error)
	envMatchMutex       sync.RWMutex
	envMatchArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	envMatchReturns struct {
		result1 models.EnvMatchResponse
		result2 error
	}
	envMatchReturnsOnCall map[int]struct {
		result1 models.EnvMatchResponse
		result2 error
	}
	EnvSetStub        func(models.EnvVariableMap, string, string) (models.Response, error)
	envSetMutex       sync.RWMutex
	envSetArgsForCall []struct {
		arg1 models.EnvVariableMap
		arg2 string
		arg3 string
	}
	envSetReturns struct {
		result1 models.Response
		result2 error
	}
	envSetReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	EnvShowStub        func(string, string, string) (models.EnvVariable, error)
	envShowMutex       sync.RWMutex
	envShowArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	envShowReturns struct {
		result1 models.EnvVariable
		result2 error
	}
	envShowReturnsOnCall map[int]struct {
		result1 models.EnvVariable
		result2 error
	}
	EnvUnsetStub        func(string, string, string) (models.Response, error)
	envUnsetMutex       sync.RWMutex
	envUnsetArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	envUnsetReturns struct {
		result1 models.Response
		result2 error
	}
	envUnsetReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ExportregistryListStub        func() ([]models.ExportregistryResponse, error)
	exportregistryListMutex       sync.RWMutex
	exportregistryListArgsForCall []struct {
	}
	exportregistryListReturns struct {
		result1 []models.ExportregistryResponse
		result2 error
	}
	exportregistryListReturnsOnCall map[int]struct {
		result1 []models.ExportregistryResponse
		result2 error
	}
	ExportregistryMatchStub        func(string) (models.ExportregistriesMatchResponse, error)
	exportregistryMatchMutex       sync.RWMutex
	exportregistryMatchArgsForCall []struct {
		arg1 string
	}
	exportregistryMatchReturns struct {
		result1 models.ExportregistriesMatchResponse
		result2 error
	}
	exportregistryMatchReturnsOnCall map[int]struct {
		result1 models.ExportregistriesMatchResponse
		result2 error
	}
	GitconfigCreateStub        func(models.GitconfigCreateRequest) (models.Response, error)
	gitconfigCreateMutex       sync.RWMutex
	gitconfigCreateArgsForCall []struct {
		arg1 models.GitconfigCreateRequest
	}
	gitconfigCreateReturns struct {
		result1 models.Response
		result2 error
	}
	gitconfigCreateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	GitconfigDeleteStub        func([]string) (models.Response, error)
	gitconfigDeleteMutex       sync.RWMutex
	gitconfigDeleteArgsForCall []struct {
		arg1 []string
	}
	gitconfigDeleteReturns struct {
		result1 models.Response
		result2 error
	}
	gitconfigDeleteReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	GitconfigShowStub        func(string) (models.Gitconfig, error)
	gitconfigShowMutex       sync.RWMutex
	gitconfigShowArgsForCall []struct {
		arg1 string
	}
	gitconfigShowReturns struct {
		result1 models.Gitconfig
		result2 error
	}
	gitconfigShowReturnsOnCall map[int]struct {
		result1 models.Gitconfig
		result2 error
	}
	GitconfigsStub        func() (models.GitconfigList, error)
	gitconfigsMutex       sync.RWMutex
	gitconfigsArgsForCall []struct {
	}
	gitconfigsReturns struct {
		result1 models.GitconfigList
		result2 error
	}
	gitconfigsReturnsOnCall map[int]struct {
		result1 models.GitconfigList
		result2 error
	}
	GitconfigsMatchStub        func(string) (models.GitconfigsMatchResponse, error)
	gitconfigsMatchMutex       sync.RWMutex
	gitconfigsMatchArgsForCall []struct {
		arg1 string
	}
	gitconfigsMatchReturns struct {
		result1 models.GitconfigsMatchResponse
		result2 error
	}
	gitconfigsMatchReturnsOnCall map[int]struct {
		result1 models.GitconfigsMatchResponse
		result2 error
	}
	HeadersStub        func() http.Header
	headersMutex       sync.RWMutex
	headersArgsForCall []struct {
	}
	headersReturns struct {
		result1 http.Header
	}
	headersReturnsOnCall map[int]struct {
		result1 http.Header
	}
	InfoStub        func() (models.InfoResponse, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
	}
	infoReturns struct {
		result1 models.InfoResponse
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 models.InfoResponse
		result2 error
	}
	MeStub        func() (models.MeResponse, error)
	meMutex       sync.RWMutex
	meArgsForCall []struct {
	}
	meReturns struct {
		result1 models.MeResponse
		result2 error
	}
	meReturnsOnCall map[int]struct {
		result1 models.MeResponse
		result2 error
	}
	NamespaceCreateStub        func(models.NamespaceCreateRequest) (models.Response, error)
	namespaceCreateMutex       sync.RWMutex
	namespaceCreateArgsForCall []struct {
		arg1 models.NamespaceCreateRequest
	}
	namespaceCreateReturns struct {
		result1 models.Response
		result2 error
	}
	namespaceCreateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	NamespaceDeleteStub        func([]string) (models.Response, error)
	namespaceDeleteMutex       sync.RWMutex
	namespaceDeleteArgsForCall []struct {
		arg1 []string
	}
	namespaceDeleteReturns struct {
		result1 models.Response
		result2 error
	}
	namespaceDeleteReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	NamespaceShowStub        func(string) (models.Namespace, error)
	namespaceShowMutex       sync.RWMutex
	namespaceShowArgsForCall []struct {
		arg1 string
	}
	namespaceShowReturns struct {
		result1 models.Namespace
		result2 error
	}
	namespaceShowReturnsOnCall map[int]struct {
		result1 models.Namespace
		result2 error
	}
	NamespacesStub        func() (models.NamespaceList, error)
	namespacesMutex       sync.RWMutex
	namespacesArgsForCall []struct {
	}
	namespacesReturns struct {
		result1 models.NamespaceList
		result2 error
	}
	namespacesReturnsOnCall map[int]struct {
		result1 models.NamespaceList
		result2 error
	}
	NamespacesMatchStub        func(string) (models.NamespacesMatchResponse, error)
	namespacesMatchMutex       sync.RWMutex
	namespacesMatchArgsForCall []struct {
		arg1 string
	}
	namespacesMatchReturns struct {
		result1 models.NamespacesMatchResponse
		result2 error
	}
	namespacesMatchReturnsOnCall map[int]struct {
		result1 models.NamespacesMatchResponse
		result2 error
	}
	ServiceBindStub        func(models.ServiceBindRequest, string, string) (models.Response, error)
	serviceBindMutex       sync.RWMutex
	serviceBindArgsForCall []struct {
		arg1 models.ServiceBindRequest
		arg2 string
		arg3 string
	}
	serviceBindReturns struct {
		result1 models.Response
		result2 error
	}
	serviceBindReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ServiceCatalogStub        func() (models.CatalogServices, error)
	serviceCatalogMutex       sync.RWMutex
	serviceCatalogArgsForCall []struct {
	}
	serviceCatalogReturns struct {
		result1 models.CatalogServices
		result2 error
	}
	serviceCatalogReturnsOnCall map[int]struct {
		result1 models.CatalogServices
		result2 error
	}
	ServiceCatalogMatchStub        func(string) (models.CatalogMatchResponse, error)
	serviceCatalogMatchMutex       sync.RWMutex
	serviceCatalogMatchArgsForCall []struct {
		arg1 string
	}
	serviceCatalogMatchReturns struct {
		result1 models.CatalogMatchResponse
		result2 error
	}
	serviceCatalogMatchReturnsOnCall map[int]struct {
		result1 models.CatalogMatchResponse
		result2 error
	}
	ServiceCatalogShowStub        func(string) (*models.CatalogService, error)
	serviceCatalogShowMutex       sync.RWMutex
	serviceCatalogShowArgsForCall []struct {
		arg1 string
	}
	serviceCatalogShowReturns struct {
		result1 *models.CatalogService
		result2 error
	}
	serviceCatalogShowReturnsOnCall map[int]struct {
		result1 *models.CatalogService
		result2 error
	}
	ServiceCreateStub        func(models.ServiceCreateRequest, string) (models.Response, error)
	serviceCreateMutex       sync.RWMutex
	serviceCreateArgsForCall []struct {
		arg1 models.ServiceCreateRequest
		arg2 string
	}
	serviceCreateReturns struct {
		result1 models.Response
		result2 error
	}
	serviceCreateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ServiceDeleteStub        func(models.ServiceDeleteRequest, string, []string) (models.ServiceDeleteResponse, error)
	serviceDeleteMutex       sync.RWMutex
	serviceDeleteArgsForCall []struct {
		arg1 models.ServiceDeleteRequest
		arg2 string
		arg3 []string
	}
	serviceDeleteReturns struct {
		result1 models.ServiceDeleteResponse
		result2 error
	}
	serviceDeleteReturnsOnCall map[int]struct {
		result1 models.ServiceDeleteResponse
		result2 error
	}
	ServiceListStub        func(string) (models.ServiceList, error)
	serviceListMutex       sync.RWMutex
	serviceListArgsForCall []struct {
		arg1 string
	}
	serviceListReturns struct {
		result1 models.ServiceList
		result2 error
	}
	serviceListReturnsOnCall map[int]struct {
		result1 models.ServiceList
		result2 error
	}
	ServiceMatchStub        func(string, string) (models.ServiceMatchResponse, error)
	serviceMatchMutex       sync.RWMutex
	serviceMatchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	serviceMatchReturns struct {
		result1 models.ServiceMatchResponse
		result2 error
	}
	serviceMatchReturnsOnCall map[int]struct {
		result1 models.ServiceMatchResponse
		result2 error
	}
	ServicePortForwardStub        func(string, string, *client.PortForwardOpts) error
	servicePortForwardMutex       sync.RWMutex
	servicePortForwardArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *client.PortForwardOpts
	}
	servicePortForwardReturns struct {
		result1 error
	}
	servicePortForwardReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceShowStub        func(string, string) (*models.Service, error)
	serviceShowMutex       sync.RWMutex
	serviceShowArgsForCall []struct {
		arg1 string
		arg2 string
	}
	serviceShowReturns struct {
		result1 *models.Service
		result2 error
	}
	serviceShowReturnsOnCall map[int]struct {
		result1 *models.Service
		result2 error
	}
	ServiceUnbindStub        func(models.ServiceUnbindRequest, string, string) (models.Response, error)
	serviceUnbindMutex       sync.RWMutex
	serviceUnbindArgsForCall []struct {
		arg1 models.ServiceUnbindRequest
		arg2 string
		arg3 string
	}
	serviceUnbindReturns struct {
		result1 models.Response
		result2 error
	}
	serviceUnbindReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ServiceUpdateStub        func(models.ServiceUpdateRequest, string, string) (models.Response, error)
	serviceUpdateMutex       sync.RWMutex
	serviceUpdateArgsForCall []struct {
		arg1 models.ServiceUpdateRequest
		arg2 string
		arg3 string
	}
	serviceUpdateReturns struct {
		result1 models.Response
		result2 error
	}
	serviceUpdateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	SetHeaderStub        func(string, string)
	setHeaderMutex       sync.RWMutex
	setHeaderArgsForCall []struct {
		arg1 string
		arg2 string
	}
	StagingCompleteStub        func(string, string) (models.Response, error)
	stagingCompleteMutex       sync.RWMutex
	stagingCompleteArgsForCall []struct {
		arg1 string
		arg2 string
	}
	stagingCompleteReturns struct {
		result1 models.Response
		result2 error
	}
	stagingCompleteReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	VersionWarningEnabledStub        func() bool
	versionWarningEnabledMutex       sync.RWMutex
	versionWarningEnabledArgsForCall []struct {
	}
	versionWarningEnabledReturns struct {
		result1 bool
	}
	versionWarningEnabledReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAPIClient) AllApps() (models.AppList, error) {
	fake.allAppsMutex.Lock()
	ret, specificReturn := fake.allAppsReturnsOnCall[len(fake.allAppsArgsForCall)]
	fake.allAppsArgsForCall = append(fake.allAppsArgsForCall, struct {
	}{})
	stub := fake.AllAppsStub
	fakeReturns := fake.allAppsReturns
	fake.recordInvocation("AllApps", []interface{}{})
	fake.allAppsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AllAppsCallCount() int {
	fake.allAppsMutex.RLock()
	defer fake.allAppsMutex.RUnlock()
	return len(fake.allAppsArgsForCall)
}

func (fake *FakeAPIClient) AllAppsCalls(stub func() (models.AppList, error)) {
	fake.allAppsMutex.Lock()
	defer fake.allAppsMutex.Unlock()
	fake.AllAppsStub = stub
}

func (fake *FakeAPIClient) AllAppsReturns(result1 models.AppList, result2 error) {
	fake.allAppsMutex.Lock()
	defer fake.allAppsMutex.Unlock()
	fake.AllAppsStub = nil
	fake.allAppsReturns = struct {
		result1 models.AppList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllAppsReturnsOnCall(i int, result1 models.AppList, result2 error) {
	fake.allAppsMutex.Lock()
	defer fake.allAppsMutex.Unlock()
	fake.AllAppsStub = nil
	if fake.allAppsReturnsOnCall == nil {
		fake.allAppsReturnsOnCall = make(map[int]struct {
			result1 models.AppList
			result2 error
		})
	}
	fake.allAppsReturnsOnCall[i] = struct {
		result1 models.AppList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllConfigurations() (models.ConfigurationResponseList, error) {
	fake.allConfigurationsMutex.Lock()
	ret, specificReturn := fake.allConfigurationsReturnsOnCall[len(fake.allConfigurationsArgsForCall)]
	fake.allConfigurationsArgsForCall = append(fake.allConfigurationsArgsForCall, struct {
	}{})
	stub := fake.AllConfigurationsStub
	fakeReturns := fake.allConfigurationsReturns
	fake.recordInvocation("AllConfigurations", []interface{}{})
	fake.allConfigurationsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AllConfigurationsCallCount() int {
	fake.allConfigurationsMutex.RLock()
	defer fake.allConfigurationsMutex.RUnlock()
	return len(fake.allConfigurationsArgsForCall)
}

func (fake *FakeAPIClient) AllConfigurationsCalls(stub func() (models.ConfigurationResponseList, error)) {
	fake.allConfigurationsMutex.Lock()
	defer fake.allConfigurationsMutex.Unlock()
	fake.AllConfigurationsStub = stub
}

func (fake *FakeAPIClient) AllConfigurationsReturns(result1 models.ConfigurationResponseList, result2 error) {
	fake.allConfigurationsMutex.Lock()
	defer fake.allConfigurationsMutex.Unlock()
	fake.AllConfigurationsStub = nil
	fake.allConfigurationsReturns = struct {
		result1 models.ConfigurationResponseList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllConfigurationsReturnsOnCall(i int, result1 models.ConfigurationResponseList, result2 error) {
	fake.allConfigurationsMutex.Lock()
	defer fake.allConfigurationsMutex.Unlock()
	fake.AllConfigurationsStub = nil
	if fake.allConfigurationsReturnsOnCall == nil {
		fake.allConfigurationsReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationResponseList
			result2 error
		})
	}
	fake.allConfigurationsReturnsOnCall[i] = struct {
		result1 models.ConfigurationResponseList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllServices() (models.ServiceList, error) {
	fake.allServicesMutex.Lock()
	ret, specificReturn := fake.allServicesReturnsOnCall[len(fake.allServicesArgsForCall)]
	fake.allServicesArgsForCall = append(fake.allServicesArgsForCall, struct {
	}{})
	stub := fake.AllServicesStub
	fakeReturns := fake.allServicesReturns
	fake.recordInvocation("AllServices", []interface{}{})
	fake.allServicesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AllServicesCallCount() int {
	fake.allServicesMutex.RLock()
	defer fake.allServicesMutex.RUnlock()
	return len(fake.allServicesArgsForCall)
}

func (fake *FakeAPIClient) AllServicesCalls(stub func() (models.ServiceList, error)) {
	fake.allServicesMutex.Lock()
	defer fake.allServicesMutex.Unlock()
	fake.AllServicesStub = stub
}

func (fake *FakeAPIClient) AllServicesReturns(result1 models.ServiceList, result2 error) {
	fake.allServicesMutex.Lock()
	defer fake.allServicesMutex.Unlock()
	fake.AllServicesStub = nil
	fake.allServicesReturns = struct {
		result1 models.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllServicesReturnsOnCall(i int, result1 models.ServiceList, result2 error) {
	fake.allServicesMutex.Lock()
	defer fake.allServicesMutex.Unlock()
	fake.AllServicesStub = nil
	if fake.allServicesReturnsOnCall == nil {
		fake.allServicesReturnsOnCall = make(map[int]struct {
			result1 models.ServiceList
			result2 error
		})
	}
	fake.allServicesReturnsOnCall[i] = struct {
		result1 models.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppCreate(arg1 models.ApplicationCreateRequest, arg2 string) (models.Response, error) {
	fake.appCreateMutex.Lock()
	ret, specificReturn := fake.appCreateReturnsOnCall[len(fake.appCreateArgsForCall)]
	fake.appCreateArgsForCall = append(fake.appCreateArgsForCall, struct {
		arg1 models.ApplicationCreateRequest
		arg2 string
	}{arg1, arg2})
	stub := fake.AppCreateStub
	fakeReturns := fake.appCreateReturns
	fake.recordInvocation("AppCreate", []interface{}{arg1, arg2})
	fake.appCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppCreateCallCount() int {
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	return len(fake.appCreateArgsForCall)
}

func (fake *FakeAPIClient) AppCreateCalls(stub func(models.ApplicationCreateRequest, string) (models.Response, error)) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = stub
}

func (fake *FakeAPIClient) AppCreateArgsForCall(i int) (models.ApplicationCreateRequest, string) {
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	argsForCall := fake.appCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppCreateReturns(result1 models.Response, result2 error) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = nil
	fake.appCreateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppCreateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = nil
	if fake.appCreateReturnsOnCall == nil {
		fake.appCreateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appCreateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppDelete(arg1 string, arg2 []string) (models.ApplicationDeleteResponse, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.appDeleteMutex.Lock()
	ret, specificReturn := fake.appDeleteReturnsOnCall[len(fake.appDeleteArgsForCall)]
	fake.appDeleteArgsForCall = append(fake.appDeleteArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.AppDeleteStub
	fakeReturns := fake.appDeleteReturns
	fake.recordInvocation("AppDelete", []interface{}{arg1, arg2Copy})
	fake.appDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppDeleteCallCount() int {
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	return len(fake.appDeleteArgsForCall)
}

func (fake *FakeAPIClient) AppDeleteCalls(stub func(string, []string) (models.ApplicationDeleteResponse, error)) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = stub
}

func (fake *FakeAPIClient) AppDeleteArgsForCall(i int) (string, []string) {
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	argsForCall := fake.appDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppDeleteReturns(result1 models.ApplicationDeleteResponse, result2 error) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = nil
	fake.appDeleteReturns = struct {
		result1 models.ApplicationDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppDeleteReturnsOnCall(i int, result1 models.ApplicationDeleteResponse, result2 error) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = nil
	if fake.appDeleteReturnsOnCall == nil {
		fake.appDeleteReturnsOnCall = make(map[int]struct {
			result1 models.ApplicationDeleteResponse
			result2 error
		})
	}
	fake.appDeleteReturnsOnCall[i] = struct {
		result1 models.ApplicationDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppDeploy(arg1 models.DeployRequest) (*models.DeployResponse, error) {
	fake.appDeployMutex.Lock()
	ret, specificReturn := fake.appDeployReturnsOnCall[len(fake.appDeployArgsForCall)]
	fake.appDeployArgsForCall = append(fake.appDeployArgsForCall, struct {
		arg1 models.DeployRequest
	}{arg1})
	stub := fake.AppDeployStub
	fakeReturns := fake.appDeployReturns
	fake.recordInvocation("AppDeploy", []interface{}{arg1})
	fake.appDeployMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppDeployCallCount() int {
	fake.appDeployMutex.RLock()
	defer fake.appDeployMutex.RUnlock()
	return len(fake.appDeployArgsForCall)
}

func (fake *FakeAPIClient) AppDeployCalls(stub func(models.DeployRequest) (*models.DeployResponse, error)) {
	fake.appDeployMutex.Lock()
	defer fake.appDeployMutex.Unlock()
	fake.AppDeployStub = stub
}

func (fake *FakeAPIClient) AppDeployArgsForCall(i int) models.DeployRequest {
	fake.appDeployMutex.RLock()
	defer fake.appDeployMutex.RUnlock()
	argsForCall := fake.appDeployArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) AppDeployReturns(result1 *models.DeployResponse, result2 error) {
	fake.appDeployMutex.Lock()
	defer fake.appDeployMutex.Unlock()
	fake.AppDeployStub = nil
	fake.appDeployReturns = struct {
		result1 *models.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppDeployReturnsOnCall(i int, result1 *models.DeployResponse, result2 error) {
	fake.appDeployMutex.Lock()
	defer fake.appDeployMutex.Unlock()
	fake.AppDeployStub = nil
	if fake.appDeployReturnsOnCall == nil {
		fake.appDeployReturnsOnCall = make(map[int]struct {
			result1 *models.DeployResponse
			result2 error
		})
	}
	fake.appDeployReturnsOnCall[i] = struct {
		result1 *models.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppExec(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 term.TTY) error {
	fake.appExecMutex.Lock()
	ret, specificReturn := fake.appExecReturnsOnCall[len(fake.appExecArgsForCall)]
	fake.appExecArgsForCall = append(fake.appExecArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 term.TTY
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AppExecStub
	fakeReturns := fake.appExecReturns
	fake.recordInvocation("AppExec", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.appExecMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) AppExecCallCount() int {
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	return len(fake.appExecArgsForCall)
}

func (fake *FakeAPIClient) AppExecCalls(stub func(context.Context, string, string, string, term.TTY) error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = stub
}

func (fake *FakeAPIClient) AppExecArgsForCall(i int) (context.Context, string, string, string, term.TTY) {
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	argsForCall := fake.appExecArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeAPIClient) AppExecReturns(result1 error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = nil
	fake.appExecReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppExecReturnsOnCall(i int, result1 error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = nil
	if fake.appExecReturnsOnCall == nil {
		fake.appExecReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appExecReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppExport(arg1 string, arg2 string, arg3 models.AppExportRequest) (models.Response, error) {
	fake.appExportMutex.Lock()
	ret, specificReturn := fake.appExportReturnsOnCall[len(fake.appExportArgsForCall)]
	fake.appExportArgsForCall = append(fake.appExportArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.AppExportRequest
	}{arg1, arg2, arg3})
	stub := fake.AppExportStub
	fakeReturns := fake.appExportReturns
	fake.recordInvocation("AppExport", []interface{}{arg1, arg2, arg3})
	fake.appExportMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppExportCallCount() int {
	fake.appExportMutex.RLock()
	defer fake.appExportMutex.RUnlock()
	return len(fake.appExportArgsForCall)
}

func (fake *FakeAPIClient) AppExportCalls(stub func(string, string, models.AppExportRequest) (models.Response, error)) {
	fake.appExportMutex.Lock()
	defer fake.appExportMutex.Unlock()
	fake.AppExportStub = stub
}

func (fake *FakeAPIClient) AppExportArgsForCall(i int) (string, string, models.AppExportRequest) {
	fake.appExportMutex.RLock()
	defer fake.appExportMutex.RUnlock()
	argsForCall := fake.appExportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) AppExportReturns(result1 models.Response, result2 error) {
	fake.appExportMutex.Lock()
	defer fake.appExportMutex.Unlock()
	fake.AppExportStub = nil
	fake.appExportReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppExportReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appExportMutex.Lock()
	defer fake.appExportMutex.Unlock()
	fake.AppExportStub = nil
	if fake.appExportReturnsOnCall == nil {
		fake.appExportReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appExportReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppGetPart(arg1 string, arg2 string, arg3 string) (models.AppPartResponse, error) {
	fake.appGetPartMutex.Lock()
	ret, specificReturn := fake.appGetPartReturnsOnCall[len(fake.appGetPartArgsForCall)]
	fake.appGetPartArgsForCall = append(fake.appGetPartArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AppGetPartStub
	fakeReturns := fake.appGetPartReturns
	fake.recordInvocation("AppGetPart", []interface{}{arg1, arg2, arg3})
	fake.appGetPartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppGetPartCallCount() int {
	fake.appGetPartMutex.RLock()
	defer fake.appGetPartMutex.RUnlock()
	return len(fake.appGetPartArgsForCall)
}

func (fake *FakeAPIClient) AppGetPartCalls(stub func(string, string, string) (models.AppPartResponse, error)) {
	fake.appGetPartMutex.Lock()
	defer fake.appGetPartMutex.Unlock()
	fake.AppGetPartStub = stub
}

func (fake *FakeAPIClient) AppGetPartArgsForCall(i int) (string, string, string) {
	fake.appGetPartMutex.RLock()
	defer fake.appGetPartMutex.RUnlock()
	argsForCall := fake.appGetPartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) AppGetPartReturns(result1 models.AppPartResponse, result2 error) {
	fake.appGetPartMutex.Lock()
	defer fake.appGetPartMutex.Unlock()
	fake.AppGetPartStub = nil
	fake.appGetPartReturns = struct {
		result1 models.AppPartResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppGetPartReturnsOnCall(i int, result1 models.AppPartResponse, result2 error) {
	fake.appGetPartMutex.Lock()
	defer fake.appGetPartMutex.Unlock()
	fake.AppGetPartStub = nil
	if fake.appGetPartReturnsOnCall == nil {
		fake.appGetPartReturnsOnCall = make(map[int]struct {
			result1 models.AppPartResponse
			result2 error
		})
	}
	fake.appGetPartReturnsOnCall[i] = struct {
		result1 models.AppPartResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppImportGit(arg1 string, arg2 string, arg3 models.GitRef) (models.ImportGitResponse, error) {
	fake.appImportGitMutex.Lock()
	ret, specificReturn := fake.appImportGitReturnsOnCall[len(fake.appImportGitArgsForCall)]
	fake.appImportGitArgsForCall = append(fake.appImportGitArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.GitRef
	}{arg1, arg2, arg3})
	stub := fake.AppImportGitStub
	fakeReturns := fake.appImportGitReturns
	fake.recordInvocation("AppImportGit", []interface{}{arg1, arg2, arg3})
	fake.appImportGitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppImportGitCallCount() int {
	fake.appImportGitMutex.RLock()
	defer fake.appImportGitMutex.RUnlock()
	return len(fake.appImportGitArgsForCall)
}

func (fake *FakeAPIClient) AppImportGitCalls(stub func(string, string, models.GitRef) (models.ImportGitResponse, error)) {
	fake.appImportGitMutex.Lock()
	defer fake.appImportGitMutex.Unlock()
	fake.AppImportGitStub = stub
}

func (fake *FakeAPIClient) AppImportGitArgsForCall(i int) (string, string, models.GitRef) {
	fake.appImportGitMutex.RLock()
	defer fake.appImportGitMutex.RUnlock()
	argsForCall := fake.appImportGitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) AppImportGitReturns(result1 models.ImportGitResponse, result2 error) {
	fake.appImportGitMutex.Lock()
	defer fake.appImportGitMutex.Unlock()
	fake.AppImportGitStub = nil
	fake.appImportGitReturns = struct {
		result1 models.ImportGitResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppImportGitReturnsOnCall(i int, result1 models.ImportGitResponse, result2 error) {
	fake.appImportGitMutex.Lock()
	defer fake.appImportGitMutex.Unlock()
	fake.AppImportGitStub = nil
	if fake.appImportGitReturnsOnCall == nil {
		fake.appImportGitReturnsOnCall = make(map[int]struct {
			result1 models.ImportGitResponse
			result2 error
		})
	}
	fake.appImportGitReturnsOnCall[i] = struct {
		result1 models.ImportGitResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppLogs(arg1 string, arg2 string, arg3 string, arg4 bool, arg5 func(tailer.ContainerLogLine)) error {
	fake.appLogsMutex.Lock()
	ret, specificReturn := fake.appLogsReturnsOnCall[len(fake.appLogsArgsForCall)]
	fake.appLogsArgsForCall = append(fake.appLogsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 bool
		arg5 func(tailer.ContainerLogLine)
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AppLogsStub
	fakeReturns := fake.appLogsReturns
	fake.recordInvocation("AppLogs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.appLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) AppLogsCallCount() int {
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	return len(fake.appLogsArgsForCall)
}

func (fake *FakeAPIClient) AppLogsCalls(stub func(string, string, string, bool, func(tailer.ContainerLogLine)) error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = stub
}

func (fake *FakeAPIClient) AppLogsArgsForCall(i int) (string, string, string, bool, func(tailer.ContainerLogLine)) {
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	argsForCall := fake.appLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeAPIClient) AppLogsReturns(result1 error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = nil
	fake.appLogsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppLogsReturnsOnCall(i int, result1 error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = nil
	if fake.appLogsReturnsOnCall == nil {
		fake.appLogsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appLogsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppMatch(arg1 string, arg2 string) (models.AppMatchResponse, error) {
	fake.appMatchMutex.Lock()
	ret, specificReturn := fake.appMatchReturnsOnCall[len(fake.appMatchArgsForCall)]
	fake.appMatchArgsForCall = append(fake.appMatchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppMatchStub
	fakeReturns := fake.appMatchReturns
	fake.recordInvocation("AppMatch", []interface{}{arg1, arg2})
	fake.appMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppMatchCallCount() int {
	fake.appMatchMutex.RLock()
	defer fake.appMatchMutex.RUnlock()
	return len(fake.appMatchArgsForCall)
}

func (fake *FakeAPIClient) AppMatchCalls(stub func(string, string) (models.AppMatchResponse, error)) {
	fake.appMatchMutex.Lock()
	defer fake.appMatchMutex.Unlock()
	fake.AppMatchStub = stub
}

func (fake *FakeAPIClient) AppMatchArgsForCall(i int) (string, string) {
	fake.appMatchMutex.RLock()
	defer fake.appMatchMutex.RUnlock()
	argsForCall := fake.appMatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppMatchReturns(result1 models.AppMatchResponse, result2 error) {
	fake.appMatchMutex.Lock()
	defer fake.appMatchMutex.Unlock()
	fake.AppMatchStub = nil
	fake.appMatchReturns = struct {
		result1 models.AppMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppMatchReturnsOnCall(i int, result1 models.AppMatchResponse, result2 error) {
	fake.appMatchMutex.Lock()
	defer fake.appMatchMutex.Unlock()
	fake.AppMatchStub = nil
	if fake.appMatchReturnsOnCall == nil {
		fake.appMatchReturnsOnCall = make(map[int]struct {
			result1 models.AppMatchResponse
			result2 error
		})
	}
	fake.appMatchReturnsOnCall[i] = struct {
		result1 models.AppMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppPortForward(arg1 string, arg2 string, arg3 string, arg4 *client.PortForwardOpts) error {
	fake.appPortForwardMutex.Lock()
	ret, specificReturn := fake.appPortForwardReturnsOnCall[len(fake.appPortForwardArgsForCall)]
	fake.appPortForwardArgsForCall = append(fake.appPortForwardArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *client.PortForwardOpts
	}{arg1, arg2, arg3, arg4})
	stub := fake.AppPortForwardStub
	fakeReturns := fake.appPortForwardReturns
	fake.recordInvocation("AppPortForward", []interface{}{arg1, arg2, arg3, arg4})
	fake.appPortForwardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) AppPortForwardCallCount() int {
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	return len(fake.appPortForwardArgsForCall)
}

func (fake *FakeAPIClient) AppPortForwardCalls(stub func(string, string, string, *client.PortForwardOpts) error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = stub
}

func (fake *FakeAPIClient) AppPortForwardArgsForCall(i int) (string, string, string, *client.PortForwardOpts) {
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	argsForCall := fake.appPortForwardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAPIClient) AppPortForwardReturns(result1 error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = nil
	fake.appPortForwardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppPortForwardReturnsOnCall(i int, result1 error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = nil
	if fake.appPortForwardReturnsOnCall == nil {
		fake.appPortForwardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appPortForwardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppRestart(arg1 string, arg2 string) (models.Response, error) {
	fake.appRestartMutex.Lock()
	ret, specificReturn := fake.appRestartReturnsOnCall[len(fake.appRestartArgsForCall)]
	fake.appRestartArgsForCall = append(fake.appRestartArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppRestartStub
	fakeReturns := fake.appRestartReturns
	fake.recordInvocation("AppRestart", []interface{}{arg1, arg2})
	fake.appRestartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppRestartCallCount() int {
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	return len(fake.appRestartArgsForCall)
}

func (fake *FakeAPIClient) AppRestartCalls(stub func(string, string) (models.Response, error)) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = stub
}

func (fake *FakeAPIClient) AppRestartArgsForCall(i int) (string, string) {
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	argsForCall := fake.appRestartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppRestartReturns(result1 models.Response, result2 error) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = nil
	fake.appRestartReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppRestartReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = nil
	if fake.appRestartReturnsOnCall == nil {
		fake.appRestartReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appRestartReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppRunning(arg1 models.AppRef) (models.Response, error) {
	fake.appRunningMutex.Lock()
	ret, specificReturn := fake.appRunningReturnsOnCall[len(fake.appRunningArgsForCall)]
	fake.appRunningArgsForCall = append(fake.appRunningArgsForCall, struct {
		arg1 models.AppRef
	}{arg1})
	stub := fake.AppRunningStub
	fakeReturns := fake.appRunningReturns
	fake.recordInvocation("AppRunning", []interface{}{arg1})
	fake.appRunningMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppRunningCallCount() int {
	fake.appRunningMutex.RLock()
	defer fake.appRunningMutex.RUnlock()
	return len(fake.appRunningArgsForCall)
}

func (fake *FakeAPIClient) AppRunningCalls(stub func(models.AppRef) (models.Response, error)) {
	fake.appRunningMutex.Lock()
	defer fake.appRunningMutex.Unlock()
	fake.AppRunningStub = stub
}

func (fake *FakeAPIClient) AppRunningArgsForCall(i int) models.AppRef {
	fake.appRunningMutex.RLock()
	defer fake.appRunningMutex.RUnlock()
	argsForCall := fake.appRunningArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) AppRunningReturns(result1 models.Response, result2 error) {
	fake.appRunningMutex.Lock()
	defer fake.appRunningMutex.Unlock()
	fake.AppRunningStub = nil
	fake.appRunningReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppRunningReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appRunningMutex.Lock()
	defer fake.appRunningMutex.Unlock()
	fake.AppRunningStub = nil
	if fake.appRunningReturnsOnCall == nil {
		fake.appRunningReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appRunningReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppShow(arg1 string, arg2 string) (models.App, error) {
	fake.appShowMutex.Lock()
	ret, specificReturn := fake.appShowReturnsOnCall[len(fake.appShowArgsForCall)]
	fake.appShowArgsForCall = append(fake.appShowArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppShowStub
	fakeReturns := fake.appShowReturns
	fake.recordInvocation("AppShow", []interface{}{arg1, arg2})
	fake.appShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppShowCallCount() int {
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	return len(fake.appShowArgsForCall)
}

func (fake *FakeAPIClient) AppShowCalls(stub func(string, string) (models.App, error)) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = stub
}

func (fake *FakeAPIClient) AppShowArgsForCall(i int) (string, string) {
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	argsForCall := fake.appShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppShowReturns(result1 models.App, result2 error) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = nil
	fake.appShowReturns = struct {
		result1 models.App
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppShowReturnsOnCall(i int, result1 models.App, result2 error) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = nil
	if fake.appShowReturnsOnCall == nil {
		fake.appShowReturnsOnCall = make(map[int]struct {
			result1 models.App
			result2 error
		})
	}
	fake.appShowReturnsOnCall[i] = struct {
		result1 models.App
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppStage(arg1 models.StageRequest) (*models.StageResponse, error) {
	fake.appStageMutex.Lock()
	ret, specificReturn := fake.appStageReturnsOnCall[len(fake.appStageArgsForCall)]
	fake.appStageArgsForCall = append(fake.appStageArgsForCall, struct {
		arg1 models.StageRequest
	}{arg1})
	stub := fake.AppStageStub
	fakeReturns := fake.appStageReturns
	fake.recordInvocation("AppStage", []interface{}{arg1})
	fake.appStageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppStageCallCount() int {
	fake.appStageMutex.RLock()
	defer fake.appStageMutex.RUnlock()
	return len(fake.appStageArgsForCall)
}

func (fake *FakeAPIClient) AppStageCalls(stub func(models.StageRequest) (*models.StageResponse, error)) {
	fake.appStageMutex.Lock()
	defer fake.appStageMutex.Unlock()
	fake.AppStageStub = stub
}

func (fake *FakeAPIClient) AppStageArgsForCall(i int) models.StageRequest {
	fake.appStageMutex.RLock()
	defer fake.appStageMutex.RUnlock()
	argsForCall := fake.appStageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) AppStageReturns(result1 *models.StageResponse, result2 error) {
	fake.appStageMutex.Lock()
	defer fake.appStageMutex.Unlock()
	fake.AppStageStub = nil
	fake.appStageReturns = struct {
		result1 *models.StageResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppStageReturnsOnCall(i int, result1 *models.StageResponse, result2 error) {
	fake.appStageMutex.Lock()
	defer fake.appStageMutex.Unlock()
	fake.AppStageStub = nil
	if fake.appStageReturnsOnCall == nil {
		fake.appStageReturnsOnCall = make(map[int]struct {
			result1 *models.StageResponse
			result2 error
		})
	}
	fake.appStageReturnsOnCall[i] = struct {
		result1 *models.StageResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppUpdate(arg1 models.ApplicationUpdateRequest, arg2 string, arg3 string) (models.Response, error) {
	fake.appUpdateMutex.Lock()
	ret, specificReturn := fake.appUpdateReturnsOnCall[len(fake.appUpdateArgsForCall)]
	fake.appUpdateArgsForCall = append(fake.appUpdateArgsForCall, struct {
		arg1 models.ApplicationUpdateRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AppUpdateStub
	fakeReturns := fake.appUpdateReturns
	fake.recordInvocation("AppUpdate", []interface{}{arg1, arg2, arg3})
	fake.appUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppUpdateCallCount() int {
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	return len(fake.appUpdateArgsForCall)
}

func (fake *FakeAPIClient) AppUpdateCalls(stub func(models.ApplicationUpdateRequest, string, string) (models.Response, error)) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = stub
}

func (fake *FakeAPIClient) AppUpdateArgsForCall(i int) (models.ApplicationUpdateRequest, string, string) {
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	argsForCall := fake.appUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) AppUpdateReturns(result1 models.Response, result2 error) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = nil
	fake.appUpdateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppUpdateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = nil
	if fake.appUpdateReturnsOnCall == nil {
		fake.appUpdateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appUpdateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppUpload(arg1 string, arg2 string, arg3 client.FormFile) (models.UploadResponse, error) {
	fake.appUploadMutex.Lock()
	ret, specificReturn := fake.appUploadReturnsOnCall[len(fake.appUploadArgsForCall)]
	fake.appUploadArgsForCall = append(fake.appUploadArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 client.FormFile
	}{arg1, arg2, arg3})
	stub := fake.AppUploadStub
	fakeReturns := fake.appUploadReturns
	fake.recordInvocation("AppUpload", []interface{}{arg1, arg2, arg3})
	fake.appUploadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppUploadCallCount() int {
	fake.appUploadMutex.RLock()
	defer fake.appUploadMutex.RUnlock()
	return len(fake.appUploadArgsForCall)
}

func (fake *FakeAPIClient) AppUploadCalls(stub func(string, string, client.FormFile) (models.UploadResponse, error)) {
	fake.appUploadMutex.Lock()
	defer fake.appUploadMutex.Unlock()
	fake.AppUploadStub = stub
}

func (fake *FakeAPIClient) AppUploadArgsForCall(i int) (string, string, client.FormFile) {
	fake.appUploadMutex.RLock()
	defer fake.appUploadMutex.RUnlock()
	argsForCall := fake.appUploadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) AppUploadReturns(result1 models.UploadResponse, result2 error) {
	fake.appUploadMutex.Lock()
	defer fake.appUploadMutex.Unlock()
	fake.AppUploadStub = nil
	fake.appUploadReturns = struct {
		result1 models.UploadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppUploadReturnsOnCall(i int, result1 models.UploadResponse, result2 error) {
	fake.appUploadMutex.Lock()
	defer fake.appUploadMutex.Unlock()
	fake.AppUploadStub = nil
	if fake.appUploadReturnsOnCall == nil {
		fake.appUploadReturnsOnCall = make(map[int]struct {
			result1 models.UploadResponse
			result2 error
		})
	}
	fake.appUploadReturnsOnCall[i] = struct {
		result1 models.UploadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppValidateCV(arg1 string, arg2 string) (models.Response, error) {
	fake.appValidateCVMutex.Lock()
	ret, specificReturn := fake.appValidateCVReturnsOnCall[len(fake.appValidateCVArgsForCall)]
	fake.appValidateCVArgsForCall = append(fake.appValidateCVArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppValidateCVStub
	fakeReturns := fake.appValidateCVReturns
	fake.recordInvocation("AppValidateCV", []interface{}{arg1, arg2})
	fake.appValidateCVMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppValidateCVCallCount() int {
	fake.appValidateCVMutex.RLock()
	defer fake.appValidateCVMutex.RUnlock()
	return len(fake.appValidateCVArgsForCall)
}

func (fake *FakeAPIClient) AppValidateCVCalls(stub func(string, string) (models.Response, error)) {
	fake.appValidateCVMutex.Lock()
	defer fake.appValidateCVMutex.Unlock()
	fake.AppValidateCVStub = stub
}

func (fake *FakeAPIClient) AppValidateCVArgsForCall(i int) (string, string) {
	fake.appValidateCVMutex.RLock()
	defer fake.appValidateCVMutex.RUnlock()
	argsForCall := fake.appValidateCVArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppValidateCVReturns(result1 models.Response, result2 error) {
	fake.appValidateCVMutex.Lock()
	defer fake.appValidateCVMutex.Unlock()
	fake.AppValidateCVStub = nil
	fake.appValidateCVReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppValidateCVReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appValidateCVMutex.Lock()
	defer fake.appValidateCVMutex.Unlock()
	fake.AppValidateCVStub = nil
	if fake.appValidateCVReturnsOnCall == nil {
		fake.appValidateCVReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appValidateCVReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Apps(arg1 string) (models.AppList, error) {
	fake.appsMutex.Lock()
	ret, specificReturn := fake.appsReturnsOnCall[len(fake.appsArgsForCall)]
	fake.appsArgsForCall = append(fake.appsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AppsStub
	fakeReturns := fake.appsReturns
	fake.recordInvocation("Apps", []interface{}{arg1})
	fake.appsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppsCallCount() int {
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	return len(fake.appsArgsForCall)
}

func (fake *FakeAPIClient) AppsCalls(stub func(string) (models.AppList, error)) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = stub
}

func (fake *FakeAPIClient) AppsArgsForCall(i int) string {
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	argsForCall := fake.appsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) AppsReturns(result1 models.AppList, result2 error) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = nil
	fake.appsReturns = struct {
		result1 models.AppList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppsReturnsOnCall(i int, result1 models.AppList, result2 error) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = nil
	if fake.appsReturnsOnCall == nil {
		fake.appsReturnsOnCall = make(map[int]struct {
			result1 models.AppList
			result2 error
		})
	}
	fake.appsReturnsOnCall[i] = struct {
		result1 models.AppList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AuthToken() (models.AuthTokenResponse, error) {
	fake.authTokenMutex.Lock()
	ret, specificReturn := fake.authTokenReturnsOnCall[len(fake.authTokenArgsForCall)]
	fake.authTokenArgsForCall = append(fake.authTokenArgsForCall, struct {
	}{})
	stub := fake.AuthTokenStub
	fakeReturns := fake.authTokenReturns
	fake.recordInvocation("AuthToken", []interface{}{})
	fake.authTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AuthTokenCallCount() int {
	fake.authTokenMutex.RLock()
	defer fake.authTokenMutex.RUnlock()
	return len(fake.authTokenArgsForCall)
}

func (fake *FakeAPIClient) AuthTokenCalls(stub func() (models.AuthTokenResponse, error)) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = stub
}

func (fake *FakeAPIClient) AuthTokenReturns(result1 models.AuthTokenResponse, result2 error) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = nil
	fake.authTokenReturns = struct {
		result1 models.AuthTokenResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AuthTokenReturnsOnCall(i int, result1 models.AuthTokenResponse, result2 error) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = nil
	if fake.authTokenReturnsOnCall == nil {
		fake.authTokenReturnsOnCall = make(map[int]struct {
			result1 models.AuthTokenResponse
			result2 error
		})
	}
	fake.authTokenReturnsOnCall[i] = struct {
		result1 models.AuthTokenResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartList() ([]models.AppChart, error) {
	fake.chartListMutex.Lock()
	ret, specificReturn := fake.chartListReturnsOnCall[len(fake.chartListArgsForCall)]
	fake.chartListArgsForCall = append(fake.chartListArgsForCall, struct {
	}{})
	stub := fake.ChartListStub
	fakeReturns := fake.chartListReturns
	fake.recordInvocation("ChartList", []interface{}{})
	fake.chartListMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ChartListCallCount() int {
	fake.chartListMutex.RLock()
	defer fake.chartListMutex.RUnlock()
	return len(fake.chartListArgsForCall)
}

func (fake *FakeAPIClient) ChartListCalls(stub func() ([]models.AppChart, error)) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = stub
}

func (fake *FakeAPIClient) ChartListReturns(result1 []models.AppChart, result2 error) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = nil
	fake.chartListReturns = struct {
		result1 []models.AppChart
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartListReturnsOnCall(i int, result1 []models.AppChart, result2 error) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = nil
	if fake.chartListReturnsOnCall == nil {
		fake.chartListReturnsOnCall = make(map[int]struct {
			result1 []models.AppChart
			result2 error
		})
	}
	fake.chartListReturnsOnCall[i] = struct {
		result1 []models.AppChart
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartMatch(arg1 string) (models.ChartMatchResponse, error) {
	fake.chartMatchMutex.Lock()
	ret, specificReturn := fake.chartMatchReturnsOnCall[len(fake.chartMatchArgsForCall)]
	fake.chartMatchArgsForCall = append(fake.chartMatchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ChartMatchStub
	fakeReturns := fake.chartMatchReturns
	fake.recordInvocation("ChartMatch", []interface{}{arg1})
	fake.chartMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ChartMatchCallCount() int {
	fake.chartMatchMutex.RLock()
	defer fake.chartMatchMutex.RUnlock()
	return len(fake.chartMatchArgsForCall)
}

func (fake *FakeAPIClient) ChartMatchCalls(stub func(string) (models.ChartMatchResponse, error)) {
	fake.chartMatchMutex.Lock()
	defer fake.chartMatchMutex.Unlock()
	fake.ChartMatchStub = stub
}

func (fake *FakeAPIClient) ChartMatchArgsForCall(i int) string {
	fake.chartMatchMutex.RLock()
	defer fake.chartMatchMutex.RUnlock()
	argsForCall := fake.chartMatchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ChartMatchReturns(result1 models.ChartMatchResponse, result2 error) {
	fake.chartMatchMutex.Lock()
	defer fake.chartMatchMutex.Unlock()
	fake.ChartMatchStub = nil
	fake.chartMatchReturns = struct {
		result1 models.ChartMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartMatchReturnsOnCall(i int, result1 models.ChartMatchResponse, result2 error) {
	fake.chartMatchMutex.Lock()
	defer fake.chartMatchMutex.Unlock()
	fake.ChartMatchStub = nil
	if fake.chartMatchReturnsOnCall == nil {
		fake.chartMatchReturnsOnCall = make(map[int]struct {
			result1 models.ChartMatchResponse
			result2 error
		})
	}
	fake.chartMatchReturnsOnCall[i] = struct {
		result1 models.ChartMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartShow(arg1 string) (models.AppChart, error) {
	fake.chartShowMutex.Lock()
	ret, specificReturn := fake.chartShowReturnsOnCall[len(fake.chartShowArgsForCall)]
	fake.chartShowArgsForCall = append(fake.chartShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ChartShowStub
	fakeReturns := fake.chartShowReturns
	fake.recordInvocation("ChartShow", []interface{}{arg1})
	fake.chartShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ChartShowCallCount() int {
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	return len(fake.chartShowArgsForCall)
}

func (fake *FakeAPIClient) ChartShowCalls(stub func(string) (models.AppChart, error)) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = stub
}

func (fake *FakeAPIClient) ChartShowArgsForCall(i int) string {
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	argsForCall := fake.chartShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ChartShowReturns(result1 models.AppChart, result2 error) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = nil
	fake.chartShowReturns = struct {
		result1 models.AppChart
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartShowReturnsOnCall(i int, result1 models.AppChart, result2 error) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = nil
	if fake.chartShowReturnsOnCall == nil {
		fake.chartShowReturnsOnCall = make(map[int]struct {
			result1 models.AppChart
			result2 error
		})
	}
	fake.chartShowReturnsOnCall[i] = struct {
		result1 models.AppChart
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationApps(arg1 string) (models.ConfigurationAppsResponse, error) {
	fake.configurationAppsMutex.Lock()
	ret, specificReturn := fake.configurationAppsReturnsOnCall[len(fake.configurationAppsArgsForCall)]
	fake.configurationAppsArgsForCall = append(fake.configurationAppsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ConfigurationAppsStub
	fakeReturns := fake.configurationAppsReturns
	fake.recordInvocation("ConfigurationApps", []interface{}{arg1})
	fake.configurationAppsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationAppsCallCount() int {
	fake.configurationAppsMutex.RLock()
	defer fake.configurationAppsMutex.RUnlock()
	return len(fake.configurationAppsArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationAppsCalls(stub func(string) (models.ConfigurationAppsResponse, error)) {
	fake.configurationAppsMutex.Lock()
	defer fake.configurationAppsMutex.Unlock()
	fake.ConfigurationAppsStub = stub
}

func (fake *FakeAPIClient) ConfigurationAppsArgsForCall(i int) string {
	fake.configurationAppsMutex.RLock()
	defer fake.configurationAppsMutex.RUnlock()
	argsForCall := fake.configurationAppsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ConfigurationAppsReturns(result1 models.ConfigurationAppsResponse, result2 error) {
	fake.configurationAppsMutex.Lock()
	defer fake.configurationAppsMutex.Unlock()
	fake.ConfigurationAppsStub = nil
	fake.configurationAppsReturns = struct {
		result1 models.ConfigurationAppsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationAppsReturnsOnCall(i int, result1 models.ConfigurationAppsResponse, result2 error) {
	fake.configurationAppsMutex.Lock()
	defer fake.configurationAppsMutex.Unlock()
	fake.ConfigurationAppsStub = nil
	if fake.configurationAppsReturnsOnCall == nil {
		fake.configurationAppsReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationAppsResponse
			result2 error
		})
	}
	fake.configurationAppsReturnsOnCall[i] = struct {
		result1 models.ConfigurationAppsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationBindingCreate(arg1 models.BindRequest, arg2 string, arg3 string) (models.BindResponse, error) {
	fake.configurationBindingCreateMutex.Lock()
	ret, specificReturn := fake.configurationBindingCreateReturnsOnCall[len(fake.configurationBindingCreateArgsForCall)]
	fake.configurationBindingCreateArgsForCall = append(fake.configurationBindingCreateArgsForCall, struct {
		arg1 models.BindRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ConfigurationBindingCreateStub
	fakeReturns := fake.configurationBindingCreateReturns
	fake.recordInvocation("ConfigurationBindingCreate", []interface{}{arg1, arg2, arg3})
	fake.configurationBindingCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationBindingCreateCallCount() int {
	fake.configurationBindingCreateMutex.RLock()
	defer fake.configurationBindingCreateMutex.RUnlock()
	return len(fake.configurationBindingCreateArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationBindingCreateCalls(stub func(models.BindRequest, string, string) (models.BindResponse, error)) {
	fake.configurationBindingCreateMutex.Lock()
	defer fake.configurationBindingCreateMutex.Unlock()
	fake.ConfigurationBindingCreateStub = stub
}

func (fake *FakeAPIClient) ConfigurationBindingCreateArgsForCall(i int) (models.BindRequest, string, string) {
	fake.configurationBindingCreateMutex.RLock()
	defer fake.configurationBindingCreateMutex.RUnlock()
	argsForCall := fake.configurationBindingCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ConfigurationBindingCreateReturns(result1 models.BindResponse, result2 error) {
	fake.configurationBindingCreateMutex.Lock()
	defer fake.configurationBindingCreateMutex.Unlock()
	fake.ConfigurationBindingCreateStub = nil
	fake.configurationBindingCreateReturns = struct {
		result1 models.BindResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationBindingCreateReturnsOnCall(i int, result1 models.BindResponse, result2 error) {
	fake.configurationBindingCreateMutex.Lock()
	defer fake.configurationBindingCreateMutex.Unlock()
	fake.ConfigurationBindingCreateStub = nil
	if fake.configurationBindingCreateReturnsOnCall == nil {
		fake.configurationBindingCreateReturnsOnCall = make(map[int]struct {
			result1 models.BindResponse
			result2 error
		})
	}
	fake.configurationBindingCreateReturnsOnCall[i] = struct {
		result1 models.BindResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationBindingDelete(arg1 string, arg2 string, arg3 string) (models.Response, error) {
	fake.configurationBindingDeleteMutex.Lock()
	ret, specificReturn := fake.configurationBindingDeleteReturnsOnCall[len(fake.configurationBindingDeleteArgsForCall)]
	fake.configurationBindingDeleteArgsForCall = append(fake.configurationBindingDeleteArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ConfigurationBindingDeleteStub
	fakeReturns := fake.configurationBindingDeleteReturns
	fake.recordInvocation("ConfigurationBindingDelete", []interface{}{arg1, arg2, arg3})
	fake.configurationBindingDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteCallCount() int {
	fake.configurationBindingDeleteMutex.RLock()
	defer fake.configurationBindingDeleteMutex.RUnlock()
	return len(fake.configurationBindingDeleteArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteCalls(stub func(string, string, string) (models.Response, error)) {
	fake.configurationBindingDeleteMutex.Lock()
	defer fake.configurationBindingDeleteMutex.Unlock()
	fake.ConfigurationBindingDeleteStub = stub
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteArgsForCall(i int) (string, string, string) {
	fake.configurationBindingDeleteMutex.RLock()
	defer fake.configurationBindingDeleteMutex.RUnlock()
	argsForCall := fake.configurationBindingDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteReturns(result1 models.Response, result2 error) {
	fake.configurationBindingDeleteMutex.Lock()
	defer fake.configurationBindingDeleteMutex.Unlock()
	fake.ConfigurationBindingDeleteStub = nil
	fake.configurationBindingDeleteReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.configurationBindingDeleteMutex.Lock()
	defer fake.configurationBindingDeleteMutex.Unlock()
	fake.ConfigurationBindingDeleteStub = nil
	if fake.configurationBindingDeleteReturnsOnCall == nil {
		fake.configurationBindingDeleteReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.configurationBindingDeleteReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationCreate(arg1 models.ConfigurationCreateRequest, arg2 string) (models.Response, error) {
	fake.configurationCreateMutex.Lock()
	ret, specificReturn := fake.configurationCreateReturnsOnCall[len(fake.configurationCreateArgsForCall)]
	fake.configurationCreateArgsForCall = append(fake.configurationCreateArgsForCall, struct {
		arg1 models.ConfigurationCreateRequest
		arg2 string
	}{arg1, arg2})
	stub := fake.ConfigurationCreateStub
	fakeReturns := fake.configurationCreateReturns
	fake.recordInvocation("ConfigurationCreate", []interface{}{arg1, arg2})
	fake.configurationCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationCreateCallCount() int {
	fake.configurationCreateMutex.RLock()
	defer fake.configurationCreateMutex.RUnlock()
	return len(fake.configurationCreateArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationCreateCalls(stub func(models.ConfigurationCreateRequest, string) (models.Response, error)) {
	fake.configurationCreateMutex.Lock()
	defer fake.configurationCreateMutex.Unlock()
	fake.ConfigurationCreateStub = stub
}

func (fake *FakeAPIClient) ConfigurationCreateArgsForCall(i int) (models.ConfigurationCreateRequest, string) {
	fake.configurationCreateMutex.RLock()
	defer fake.configurationCreateMutex.RUnlock()
	argsForCall := fake.configurationCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ConfigurationCreateReturns(result1 models.Response, result2 error) {
	fake.configurationCreateMutex.Lock()
	defer fake.configurationCreateMutex.Unlock()
	fake.ConfigurationCreateStub = nil
	fake.configurationCreateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationCreateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.configurationCreateMutex.Lock()
	defer fake.configurationCreateMutex.Unlock()
	fake.ConfigurationCreateStub = nil
	if fake.configurationCreateReturnsOnCall == nil {
		fake.configurationCreateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.configurationCreateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationDelete(arg1 models.ConfigurationDeleteRequest, arg2 string, arg3 []string) (models.ConfigurationDeleteResponse, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.configurationDeleteMutex.Lock()
	ret, specificReturn := fake.configurationDeleteReturnsOnCall[len(fake.configurationDeleteArgsForCall)]
	fake.configurationDeleteArgsForCall = append(fake.configurationDeleteArgsForCall, struct {
		arg1 models.ConfigurationDeleteRequest
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.ConfigurationDeleteStub
	fakeReturns := fake.configurationDeleteReturns
	fake.recordInvocation("ConfigurationDelete", []interface{}{arg1, arg2, arg3Copy})
	fake.configurationDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationDeleteCallCount() int {
	fake.configurationDeleteMutex.RLock()
	defer fake.configurationDeleteMutex.RUnlock()
	return len(fake.configurationDeleteArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationDeleteCalls(stub func(models.ConfigurationDeleteRequest, string, []string) (models.ConfigurationDeleteResponse, error)) {
	fake.configurationDeleteMutex.Lock()
	defer fake.configurationDeleteMutex.Unlock()
	fake.ConfigurationDeleteStub = stub
}

func (fake *FakeAPIClient) ConfigurationDeleteArgsForCall(i int) (models.ConfigurationDeleteRequest, string, []string) {
	fake.configurationDeleteMutex.RLock()
	defer fake.configurationDeleteMutex.RUnlock()
	argsForCall := fake.configurationDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ConfigurationDeleteReturns(result1 models.ConfigurationDeleteResponse, result2 error) {
	fake.configurationDeleteMutex.Lock()
	defer fake.configurationDeleteMutex.Unlock()
	fake.ConfigurationDeleteStub = nil
	fake.configurationDeleteReturns = struct {
		result1 models.ConfigurationDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationDeleteReturnsOnCall(i int, result1 models.ConfigurationDeleteResponse, result2 error) {
	fake.configurationDeleteMutex.Lock()
	defer fake.configurationDeleteMutex.Unlock()
	fake.ConfigurationDeleteStub = nil
	if fake.configurationDeleteReturnsOnCall == nil {
		fake.configurationDeleteReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationDeleteResponse
			result2 error
		})
	}
	fake.configurationDeleteReturnsOnCall[i] = struct {
		result1 models.ConfigurationDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationMatch(arg1 string, arg2 string) (models.ConfigurationMatchResponse, error) {
	fake.configurationMatchMutex.Lock()
	ret, specificReturn := fake.configurationMatchReturnsOnCall[len(fake.configurationMatchArgsForCall)]
	fake.configurationMatchArgsForCall = append(fake.configurationMatchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ConfigurationMatchStub
	fakeReturns := fake.configurationMatchReturns
	fake.recordInvocation("ConfigurationMatch", []interface{}{arg1, arg2})
	fake.configurationMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationMatchCallCount() int {
	fake.configurationMatchMutex.RLock()
	defer fake.configurationMatchMutex.RUnlock()
	return len(fake.configurationMatchArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationMatchCalls(stub func(string, string) (models.ConfigurationMatchResponse, error)) {
	fake.configurationMatchMutex.Lock()
	defer fake.configurationMatchMutex.Unlock()
	fake.ConfigurationMatchStub = stub
}

func (fake *FakeAPIClient) ConfigurationMatchArgsForCall(i int) (string, string) {
	fake.configurationMatchMutex.RLock()
	defer fake.configurationMatchMutex.RUnlock()
	argsForCall := fake.configurationMatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ConfigurationMatchReturns(result1 models.ConfigurationMatchResponse, result2 error) {
	fake.configurationMatchMutex.Lock()
	defer fake.configurationMatchMutex.Unlock()
	fake.ConfigurationMatchStub = nil
	fake.configurationMatchReturns = struct {
		result1 models.ConfigurationMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationMatchReturnsOnCall(i int, result1 models.ConfigurationMatchResponse, result2 error) {
	fake.configurationMatchMutex.Lock()
	defer fake.configurationMatchMutex.Unlock()
	fake.ConfigurationMatchStub = nil
	if fake.configurationMatchReturnsOnCall == nil {
		fake.configurationMatchReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationMatchResponse
			result2 error
		})
	}
	fake.configurationMatchReturnsOnCall[i] = struct {
		result1 models.ConfigurationMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationShow(arg1 string, arg2 string) (models.ConfigurationResponse, error) {
	fake.configurationShowMutex.Lock()
	ret, specificReturn := fake.configurationShowReturnsOnCall[len(fake.configurationShowArgsForCall)]
	fake.configurationShowArgsForCall = append(fake.configurationShowArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ConfigurationShowStub
	fakeReturns := fake.configurationShowReturns
	fake.recordInvocation("ConfigurationShow", []interface{}{arg1, arg2})
	fake.configurationShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationShowCallCount() int {
	fake.configurationShowMutex.RLock()
	defer fake.configurationShowMutex.RUnlock()
	return len(fake.configurationShowArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationShowCalls(stub func(string, string) (models.ConfigurationResponse, error)) {
	fake.configurationShowMutex.Lock()
	defer fake.configurationShowMutex.Unlock()
	fake.ConfigurationShowStub = stub
}

func (fake *FakeAPIClient) ConfigurationShowArgsForCall(i int) (string, string) {
	fake.configurationShowMutex.RLock()
	defer fake.configurationShowMutex.RUnlock()
	argsForCall := fake.configurationShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ConfigurationShowReturns(result1 models.ConfigurationResponse, result2 error) {
	fake.configurationShowMutex.Lock()
	defer fake.configurationShowMutex.Unlock()
	fake.ConfigurationShowStub = nil
	fake.configurationShowReturns = struct {
		result1 models.ConfigurationResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationShowReturnsOnCall(i int, result1 models.ConfigurationResponse, result2 error) {
	fake.configurationShowMutex.Lock()
	defer fake.configurationShowMutex.Unlock()
	fake.ConfigurationShowStub = nil
	if fake.configurationShowReturnsOnCall == nil {
		fake.configurationShowReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationResponse
			result2 error
		})
	}
	fake.configurationShowReturnsOnCall[i] = struct {
		result1 models.ConfigurationResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationUpdate(arg1 models.ConfigurationUpdateRequest, arg2 string, arg3 string) (models.Response, error) {
	fake.configurationUpdateMutex.Lock()
	ret, specificReturn := fake.configurationUpdateReturnsOnCall[len(fake.configurationUpdateArgsForCall)]
	fake.configurationUpdateArgsForCall = append(fake.configurationUpdateArgsForCall, struct {
		arg1 models.ConfigurationUpdateRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ConfigurationUpdateStub
	fakeReturns := fake.configurationUpdateReturns
	fake.recordInvocation("ConfigurationUpdate", []interface{}{arg1, arg2, arg3})
	fake.configurationUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationUpdateCallCount() int {
	fake.configurationUpdateMutex.RLock()
	defer fake.configurationUpdateMutex.RUnlock()
	return len(fake.configurationUpdateArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationUpdateCalls(stub func(models.ConfigurationUpdateRequest, string, string) (models.Response, error)) {
	fake.configurationUpdateMutex.Lock()
	defer fake.configurationUpdateMutex.Unlock()
	fake.ConfigurationUpdateStub = stub
}

func (fake *FakeAPIClient) ConfigurationUpdateArgsForCall(i int) (models.ConfigurationUpdateRequest, string, string) {
	fake.configurationUpdateMutex.RLock()
	defer fake.configurationUpdateMutex.RUnlock()
	argsForCall := fake.configurationUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ConfigurationUpdateReturns(result1 models.Response, result2 error) {
	fake.configurationUpdateMutex.Lock()
	defer fake.configurationUpdateMutex.Unlock()
	fake.ConfigurationUpdateStub = nil
	fake.configurationUpdateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationUpdateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.configurationUpdateMutex.Lock()
	defer fake.configurationUpdateMutex.Unlock()
	fake.ConfigurationUpdateStub = nil
	if fake.configurationUpdateReturnsOnCall == nil {
		fake.configurationUpdateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.configurationUpdateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Configurations(arg1 string) (models.ConfigurationResponseList, error) {
	fake.configurationsMutex.Lock()
	ret, specificReturn := fake.configurationsReturnsOnCall[len(fake.configurationsArgsForCall)]
	fake.configurationsArgsForCall = append(fake.configurationsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ConfigurationsStub
	fakeReturns := fake.configurationsReturns
	fake.recordInvocation("Configurations", []interface{}{arg1})
	fake.configurationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationsCallCount() int {
	fake.configurationsMutex.RLock()
	defer fake.configurationsMutex.RUnlock()
	return len(fake.configurationsArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationsCalls(stub func(string) (models.ConfigurationResponseList, error)) {
	fake.configurationsMutex.Lock()
	defer fake.configurationsMutex.Unlock()
	fake.ConfigurationsStub = stub
}

func (fake *FakeAPIClient) ConfigurationsArgsForCall(i int) string {
	fake.configurationsMutex.RLock()
	defer fake.configurationsMutex.RUnlock()
	argsForCall := fake.configurationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ConfigurationsReturns(result1 models.ConfigurationResponseList, result2 error) {
	fake.configurationsMutex.Lock()
	defer fake.configurationsMutex.Unlock()
	fake.ConfigurationsStub = nil
	fake.configurationsReturns = struct {
		result1 models.ConfigurationResponseList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationsReturnsOnCall(i int, result1 models.ConfigurationResponseList, result2 error) {
	fake.configurationsMutex.Lock()
	defer fake.configurationsMutex.Unlock()
	fake.ConfigurationsStub = nil
	if fake.configurationsReturnsOnCall == nil {
		fake.configurationsReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationResponseList
			result2 error
		})
	}
	fake.configurationsReturnsOnCall[i] = struct {
		result1 models.ConfigurationResponseList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) DisableVersionWarning() {
	fake.disableVersionWarningMutex.Lock()
	fake.disableVersionWarningArgsForCall = append(fake.disableVersionWarningArgsForCall, struct {
	}{})
	stub := fake.DisableVersionWarningStub
	fake.recordInvocation("DisableVersionWarning", []interface{}{})
	fake.disableVersionWarningMutex.Unlock()
	if stub != nil {
		fake.DisableVersionWarningStub()
	}
}

func (fake *FakeAPIClient) DisableVersionWarningCallCount() int {
	fake.disableVersionWarningMutex.RLock()
	defer fake.disableVersionWarningMutex.RUnlock()
	return len(fake.disableVersionWarningArgsForCall)
}

func (fake *FakeAPIClient) DisableVersionWarningCalls(stub func()) {
	fake.disableVersionWarningMutex.Lock()
	defer fake.disableVersionWarningMutex.Unlock()
	fake.DisableVersionWarningStub = stub
}

func (fake *FakeAPIClient) EnvList(arg1 string, arg2 string) (models.EnvVariableMap, error) {
	fake.envListMutex.Lock()
	ret, specificReturn := fake.envListReturnsOnCall[len(fake.envListArgsForCall)]
	fake.envListArgsForCall = append(fake.envListArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.EnvListStub
	fakeReturns := fake.envListReturns
	fake.recordInvocation("EnvList", []interface{}{arg1, arg2})
	fake.envListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvListCallCount() int {
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	return len(fake.envListArgsForCall)
}

func (fake *FakeAPIClient) EnvListCalls(stub func(string, string) (models.EnvVariableMap, error)) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = stub
}

func (fake *FakeAPIClient) EnvListArgsForCall(i int) (string, string) {
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	argsForCall := fake.envListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) EnvListReturns(result1 models.EnvVariableMap, result2 error) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = nil
	fake.envListReturns = struct {
		result1 models.EnvVariableMap
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvListReturnsOnCall(i int, result1 models.EnvVariableMap, result2 error) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = nil
	if fake.envListReturnsOnCall == nil {
		fake.envListReturnsOnCall = make(map[int]struct {
			result1 models.EnvVariableMap
			result2 error
		})
	}
	fake.envListReturnsOnCall[i] = struct {
		result1 models.EnvVariableMap
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvMatch(arg1 string, arg2 string, arg3 string) (models.EnvMatchResponse, error) {
	fake.envMatchMutex.Lock()
	ret, specificReturn := fake.envMatchReturnsOnCall[len(fake.envMatchArgsForCall)]
	fake.envMatchArgsForCall = append(fake.envMatchArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvMatchStub
	fakeReturns := fake.envMatchReturns
	fake.recordInvocation("EnvMatch", []interface{}{arg1, arg2, arg3})
	fake.envMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvMatchCallCount() int {
	fake.envMatchMutex.RLock()
	defer fake.envMatchMutex.RUnlock()
	return len(fake.envMatchArgsForCall)
}

func (fake *FakeAPIClient) EnvMatchCalls(stub func(string, string, string) (models.EnvMatchResponse, error)) {
	fake.envMatchMutex.Lock()
	defer fake.envMatchMutex.Unlock()
	fake.EnvMatchStub = stub
}

func (fake *FakeAPIClient) EnvMatchArgsForCall(i int) (string, string, string) {
	fake.envMatchMutex.RLock()
	defer fake.envMatchMutex.RUnlock()
	argsForCall := fake.envMatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) EnvMatchReturns(result1 models.EnvMatchResponse, result2 error) {
	fake.envMatchMutex.Lock()
	defer fake.envMatchMutex.Unlock()
	fake.EnvMatchStub = nil
	fake.envMatchReturns = struct {
		result1 models.EnvMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvMatchReturnsOnCall(i int, result1 models.EnvMatchResponse, result2 error) {
	fake.envMatchMutex.Lock()
	defer fake.envMatchMutex.Unlock()
	fake.EnvMatchStub = nil
	if fake.envMatchReturnsOnCall == nil {
		fake.envMatchReturnsOnCall = make(map[int]struct {
			result1 models.EnvMatchResponse
			result2 error
		})
	}
	fake.envMatchReturnsOnCall[i] = struct {
		result1 models.EnvMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvSet(arg1 models.EnvVariableMap, arg2 string, arg3 string) (models.Response, error) {
	fake.envSetMutex.Lock()
	ret, specificReturn := fake.envSetReturnsOnCall[len(fake.envSetArgsForCall)]
	fake.envSetArgsForCall = append(fake.envSetArgsForCall, struct {
		arg1 models.EnvVariableMap
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvSetStub
	fakeReturns := fake.envSetReturns
	fake.recordInvocation("EnvSet", []interface{}{arg1, arg2, arg3})
	fake.envSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvSetCallCount() int {
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	return len(fake.envSetArgsForCall)
}

func (fake *FakeAPIClient) EnvSetCalls(stub func(models.EnvVariableMap, string, string) (models.Response, error)) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = stub
}

func (fake *FakeAPIClient) EnvSetArgsForCall(i int) (models.EnvVariableMap, string, string) {
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	argsForCall := fake.envSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) EnvSetReturns(result1 models.Response, result2 error) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = nil
	fake.envSetReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvSetReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = nil
	if fake.envSetReturnsOnCall == nil {
		fake.envSetReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.envSetReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvShow(arg1 string, arg2 string, arg3 string) (models.EnvVariable, error) {
	fake.envShowMutex.Lock()
	ret, specificReturn := fake.envShowReturnsOnCall[len(fake.envShowArgsForCall)]
	fake.envShowArgsForCall = append(fake.envShowArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvShowStub
	fakeReturns := fake.envShowReturns
	fake.recordInvocation("EnvShow", []interface{}{arg1, arg2, arg3})
	fake.envShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvShowCallCount() int {
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	return len(fake.envShowArgsForCall)
}

func (fake *FakeAPIClient) EnvShowCalls(stub func(string, string, string) (models.EnvVariable, error)) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = stub
}

func (fake *FakeAPIClient) EnvShowArgsForCall(i int) (string, string, string) {
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	argsForCall := fake.envShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) EnvShowReturns(result1 models.EnvVariable, result2 error) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = nil
	fake.envShowReturns = struct {
		result1 models.EnvVariable
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvShowReturnsOnCall(i int, result1 models.EnvVariable, result2 error) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = nil
	if fake.envShowReturnsOnCall == nil {
		fake.envShowReturnsOnCall = make(map[int]struct {
			result1 models.EnvVariable
			result2 error
		})
	}
	fake.envShowReturnsOnCall[i] = struct {
		result1 models.EnvVariable
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvUnset(arg1 string, arg2 string, arg3 string) (models.Response, error) {
	fake.envUnsetMutex.Lock()
	ret, specificReturn := fake.envUnsetReturnsOnCall[len(fake.envUnsetArgsForCall)]
	fake.envUnsetArgsForCall = append(fake.envUnsetArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvUnsetStub
	fakeReturns := fake.envUnsetReturns
	fake.recordInvocation("EnvUnset", []interface{}{arg1, arg2, arg3})
	fake.envUnsetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvUnsetCallCount() int {
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	return len(fake.envUnsetArgsForCall)
}

func (fake *FakeAPIClient) EnvUnsetCalls(stub func(string, string, string) (models.Response, error)) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = stub
}

func (fake *FakeAPIClient) EnvUnsetArgsForCall(i int) (string, string, string) {
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	argsForCall := fake.envUnsetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) EnvUnsetReturns(result1 models.Response, result2 error) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = nil
	fake.envUnsetReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvUnsetReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = nil
	if fake.envUnsetReturnsOnCall == nil {
		fake.envUnsetReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.envUnsetReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ExportregistryList() ([]models.ExportregistryResponse, error) {
	fake.exportregistryListMutex.Lock()
	ret, specificReturn := fake.exportregistryListReturnsOnCall[len(fake.exportregistryListArgsForCall)]
	fake.exportregistryListArgsForCall = append(fake.exportregistryListArgsForCall, struct {
	}{})
	stub := fake.ExportregistryListStub
	fakeReturns := fake.exportregistryListReturns
	fake.recordInvocation("ExportregistryList", []interface{}{})
	fake.exportregistryListMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ExportregistryListCallCount() int {
	fake.exportregistryListMutex.RLock()
	defer fake.exportregistryListMutex.RUnlock()
	return len(fake.exportregistryListArgsForCall)
}

func (fake *FakeAPIClient) ExportregistryListCalls(stub func() ([]models.ExportregistryResponse, error)) {
	fake.exportregistryListMutex.Lock()
	defer fake.exportregistryListMutex.Unlock()
	fake.ExportregistryListStub = stub
}

func (fake *FakeAPIClient) ExportregistryListReturns(result1 []models.ExportregistryResponse, result2 error) {
	fake.exportregistryListMutex.Lock()
	defer fake.exportregistryListMutex.Unlock()
	fake.ExportregistryListStub = nil
	fake.exportregistryListReturns = struct {
		result1 []models.ExportregistryResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ExportregistryListReturnsOnCall(i int, result1 []models.ExportregistryResponse, result2 error) {
	fake.exportregistryListMutex.Lock()
	defer fake.exportregistryListMutex.Unlock()
	fake.ExportregistryListStub = nil
	if fake.exportregistryListReturnsOnCall == nil {
		fake.exportregistryListReturnsOnCall = make(map[int]struct {
			result1 []models.ExportregistryResponse
			result2 error
		})
	}
	fake.exportregistryListReturnsOnCall[i] = struct {
		result1 []models.ExportregistryResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ExportregistryMatch(arg1 string) (models.ExportregistriesMatchResponse, error) {
	fake.exportregistryMatchMutex.Lock()
	ret, specificReturn := fake.exportregistryMatchReturnsOnCall[len(fake.exportregistryMatchArgsForCall)]
	fake.exportregistryMatchArgsForCall = append(fake.exportregistryMatchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExportregistryMatchStub
	fakeReturns := fake.exportregistryMatchReturns
	fake.recordInvocation("ExportregistryMatch", []interface{}{arg1})
	fake.exportregistryMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ExportregistryMatchCallCount() int {
	fake.exportregistryMatchMutex.RLock()
	defer fake.exportregistryMatchMutex.RUnlock()
	return len(fake.exportregistryMatchArgsForCall)
}

func (fake *FakeAPIClient) ExportregistryMatchCalls(stub func(string) (models.ExportregistriesMatchResponse, error)) {
	fake.exportregistryMatchMutex.Lock()
	defer fake.exportregistryMatchMutex.Unlock()
	fake.ExportregistryMatchStub = stub
}

func (fake *FakeAPIClient) ExportregistryMatchArgsForCall(i int) string {
	fake.exportregistryMatchMutex.RLock()
	defer fake.exportregistryMatchMutex.RUnlock()
	argsForCall := fake.exportregistryMatchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ExportregistryMatchReturns(result1 models.ExportregistriesMatchResponse, result2 error) {
	fake.exportregistryMatchMutex.Lock()
	defer fake.exportregistryMatchMutex.Unlock()
	fake.ExportregistryMatchStub = nil
	fake.exportregistryMatchReturns = struct {
		result1 models.ExportregistriesMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ExportregistryMatchReturnsOnCall(i int, result1 models.ExportregistriesMatchResponse, result2 error) {
	fake.exportregistryMatchMutex.Lock()
	defer fake.exportregistryMatchMutex.Unlock()
	fake.ExportregistryMatchStub = nil
	if fake.exportregistryMatchReturnsOnCall == nil {
		fake.exportregistryMatchReturnsOnCall = make(map[int]struct {
			result1 models.ExportregistriesMatchResponse
			result2 error
		})
	}
	fake.exportregistryMatchReturnsOnCall[i] = struct {
		result1 models.ExportregistriesMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigCreate(arg1 models.GitconfigCreateRequest) (models.Response, error) {
	fake.gitconfigCreateMutex.Lock()
	ret, specificReturn := fake.gitconfigCreateReturnsOnCall[len(fake.gitconfigCreateArgsForCall)]
	fake.gitconfigCreateArgsForCall = append(fake.gitconfigCreateArgsForCall, struct {
		arg1 models.GitconfigCreateRequest
	}{arg1})
	stub := fake.GitconfigCreateStub
	fakeReturns := fake.gitconfigCreateReturns
	fake.recordInvocation("GitconfigCreate", []interface{}{arg1})
	fake.gitconfigCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) GitconfigCreateCallCount() int {
	fake.gitconfigCreateMutex.RLock()
	defer fake.gitconfigCreateMutex.RUnlock()
	return len(fake.gitconfigCreateArgsForCall)
}

func (fake *FakeAPIClient) GitconfigCreateCalls(stub func(models.GitconfigCreateRequest) (models.Response, error)) {
	fake.gitconfigCreateMutex.Lock()
	defer fake.gitconfigCreateMutex.Unlock()
	fake.GitconfigCreateStub = stub
}

func (fake *FakeAPIClient) GitconfigCreateArgsForCall(i int) models.GitconfigCreateRequest {
	fake.gitconfigCreateMutex.RLock()
	defer fake.gitconfigCreateMutex.RUnlock()
	argsForCall := fake.gitconfigCreateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) GitconfigCreateReturns(result1 models.Response, result2 error) {
	fake.gitconfigCreateMutex.Lock()
	defer fake.gitconfigCreateMutex.Unlock()
	fake.GitconfigCreateStub = nil
	fake.gitconfigCreateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigCreateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.gitconfigCreateMutex.Lock()
	defer fake.gitconfigCreateMutex.Unlock()
	fake.GitconfigCreateStub = nil
	if fake.gitconfigCreateReturnsOnCall == nil {
		fake.gitconfigCreateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.gitconfigCreateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigDelete(arg1 []string) (models.Response, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.gitconfigDeleteMutex.Lock()
	ret, specificReturn := fake.gitconfigDeleteReturnsOnCall[len(fake.gitconfigDeleteArgsForCall)]
	fake.gitconfigDeleteArgsForCall = append(fake.gitconfigDeleteArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.GitconfigDeleteStub
	fakeReturns := fake.gitconfigDeleteReturns
	fake.recordInvocation("GitconfigDelete", []interface{}{arg1Copy})
	fake.gitconfigDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) GitconfigDeleteCallCount() int {
	fake.gitconfigDeleteMutex.RLock()
	defer fake.gitconfigDeleteMutex.RUnlock()
	return len(fake.gitconfigDeleteArgsForCall)
}

func (fake *FakeAPIClient) GitconfigDeleteCalls(stub func([]string) (models.Response, error)) {
	fake.gitconfigDeleteMutex.Lock()
	defer fake.gitconfigDeleteMutex.Unlock()
	fake.GitconfigDeleteStub = stub
}

func (fake *FakeAPIClient) GitconfigDeleteArgsForCall(i int) []string {
	fake.gitconfigDeleteMutex.RLock()
	defer fake.gitconfigDeleteMutex.RUnlock()
	argsForCall := fake.gitconfigDeleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) GitconfigDeleteReturns(result1 models.Response, result2 error) {
	fake.gitconfigDeleteMutex.Lock()
	defer fake.gitconfigDeleteMutex.Unlock()
	fake.GitconfigDeleteStub = nil
	fake.gitconfigDeleteReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigDeleteReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.gitconfigDeleteMutex.Lock()
	defer fake.gitconfigDeleteMutex.Unlock()
	fake.GitconfigDeleteStub = nil
	if fake.gitconfigDeleteReturnsOnCall == nil {
		fake.gitconfigDeleteReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.gitconfigDeleteReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigShow(arg1 string) (models.Gitconfig, error) {
	fake.gitconfigShowMutex.Lock()
	ret, specificReturn := fake.gitconfigShowReturnsOnCall[len(fake.gitconfigShowArgsForCall)]
	fake.gitconfigShowArgsForCall = append(fake.gitconfigShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GitconfigShowStub
	fakeReturns := fake.gitconfigShowReturns
	fake.recordInvocation("GitconfigShow", []interface{}{arg1})
	fake.gitconfigShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) GitconfigShowCallCount() int {
	fake.gitconfigShowMutex.RLock()
	defer fake.gitconfigShowMutex.RUnlock()
	return len(fake.gitconfigShowArgsForCall)
}

func (fake *FakeAPIClient) GitconfigShowCalls(stub func(string) (models.Gitconfig, error)) {
	fake.gitconfigShowMutex.Lock()
	defer fake.gitconfigShowMutex.Unlock()
	fake.GitconfigShowStub = stub
}

func (fake *FakeAPIClient) GitconfigShowArgsForCall(i int) string {
	fake.gitconfigShowMutex.RLock()
	defer fake.gitconfigShowMutex.RUnlock()
	argsForCall := fake.gitconfigShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) GitconfigShowReturns(result1 models.Gitconfig, result2 error) {
	fake.gitconfigShowMutex.Lock()
	defer fake.gitconfigShowMutex.Unlock()
	fake.GitconfigShowStub = nil
	fake.gitconfigShowReturns = struct {
		result1 models.Gitconfig
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigShowReturnsOnCall(i int, result1 models.Gitconfig, result2 error) {
	fake.gitconfigShowMutex.Lock()
	defer fake.gitconfigShowMutex.Unlock()
	fake.GitconfigShowStub = nil
	if fake.gitconfigShowReturnsOnCall == nil {
		fake.gitconfigShowReturnsOnCall = make(map[int]struct {
			result1 models.Gitconfig
			result2 error
		})
	}
	fake.gitconfigShowReturnsOnCall[i] = struct {
		result1 models.Gitconfig
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Gitconfigs() (models.GitconfigList, error) {
	fake.gitconfigsMutex.Lock()
	ret, specificReturn := fake.gitconfigsReturnsOnCall[len(fake.gitconfigsArgsForCall)]
	fake.gitconfigsArgsForCall = append(fake.gitconfigsArgsForCall, struct {
	}{})
	stub := fake.GitconfigsStub
	fakeReturns := fake.gitconfigsReturns
	fake.recordInvocation("Gitconfigs", []interface{}{})
	fake.gitconfigsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) GitconfigsCallCount() int {
	fake.gitconfigsMutex.RLock()
	defer fake.gitconfigsMutex.RUnlock()
	return len(fake.gitconfigsArgsForCall)
}

func (fake *FakeAPIClient) GitconfigsCalls(stub func() (models.GitconfigList, error)) {
	fake.gitconfigsMutex.Lock()
	defer fake.gitconfigsMutex.Unlock()
	fake.GitconfigsStub = stub
}

func (fake *FakeAPIClient) GitconfigsReturns(result1 models.GitconfigList, result2 error) {
	fake.gitconfigsMutex.Lock()
	defer fake.gitconfigsMutex.Unlock()
	fake.GitconfigsStub = nil
	fake.gitconfigsReturns = struct {
		result1 models.GitconfigList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigsReturnsOnCall(i int, result1 models.GitconfigList, result2 error) {
	fake.gitconfigsMutex.Lock()
	defer fake.gitconfigsMutex.Unlock()
	fake.GitconfigsStub = nil
	if fake.gitconfigsReturnsOnCall == nil {
		fake.gitconfigsReturnsOnCall = make(map[int]struct {
			result1 models.GitconfigList
			result2 error
		})
	}
	fake.gitconfigsReturnsOnCall[i] = struct {
		result1 models.GitconfigList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigsMatch(arg1 string) (models.GitconfigsMatchResponse, error) {
	fake.gitconfigsMatchMutex.Lock()
	ret, specificReturn := fake.gitconfigsMatchReturnsOnCall[len(fake.gitconfigsMatchArgsForCall)]
	fake.gitconfigsMatchArgsForCall = append(fake.gitconfigsMatchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GitconfigsMatchStub
	fakeReturns := fake.gitconfigsMatchReturns
	fake.recordInvocation("GitconfigsMatch", []interface{}{arg1})
	fake.gitconfigsMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) GitconfigsMatchCallCount() int {
	fake.gitconfigsMatchMutex.RLock()
	defer fake.gitconfigsMatchMutex.RUnlock()
	return len(fake.gitconfigsMatchArgsForCall)
}

func (fake *FakeAPIClient) GitconfigsMatchCalls(stub func(string) (models.GitconfigsMatchResponse, error)) {
	fake.gitconfigsMatchMutex.Lock()
	defer fake.gitconfigsMatchMutex.Unlock()
	fake.GitconfigsMatchStub = stub
}

func (fake *FakeAPIClient) GitconfigsMatchArgsForCall(i int) string {
	fake.gitconfigsMatchMutex.RLock()
	defer fake.gitconfigsMatchMutex.RUnlock()
	argsForCall := fake.gitconfigsMatchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) GitconfigsMatchReturns(result1 models.GitconfigsMatchResponse, result2 error) {
	fake.gitconfigsMatchMutex.Lock()
	defer fake.gitconfigsMatchMutex.Unlock()
	fake.GitconfigsMatchStub = nil
	fake.gitconfigsMatchReturns = struct {
		result1 models.GitconfigsMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) GitconfigsMatchReturnsOnCall(i int, result1 models.GitconfigsMatchResponse, result2 error) {
	fake.gitconfigsMatchMutex.Lock()
	defer fake.gitconfigsMatchMutex.Unlock()
	fake.GitconfigsMatchStub = nil
	if fake.gitconfigsMatchReturnsOnCall == nil {
		fake.gitconfigsMatchReturnsOnCall = make(map[int]struct {
			result1 models.GitconfigsMatchResponse
			result2 error
		})
	}
	fake.gitconfigsMatchReturnsOnCall[i] = struct {
		result1 models.GitconfigsMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Headers() http.Header {
	fake.headersMutex.Lock()
	ret, specificReturn := fake.headersReturnsOnCall[len(fake.headersArgsForCall)]
	fake.headersArgsForCall = append(fake.headersArgsForCall, struct {
	}{})
	stub := fake.HeadersStub
	fakeReturns := fake.headersReturns
	fake.recordInvocation("Headers", []interface{}{})
	fake.headersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) HeadersCallCount() int {
	fake.headersMutex.RLock()
	defer fake.headersMutex.RUnlock()
	return len(fake.headersArgsForCall)
}

func (fake *FakeAPIClient) HeadersCalls(stub func() http.Header) {
	fake.headersMutex.Lock()
	defer fake.headersMutex.Unlock()
	fake.HeadersStub = stub
}

func (fake *FakeAPIClient) HeadersReturns(result1 http.Header) {
	fake.headersMutex.Lock()
	defer fake.headersMutex.Unlock()
	fake.HeadersStub = nil
	fake.headersReturns = struct {
		result1 http.Header
	}{result1}
}

func (fake *FakeAPIClient) HeadersReturnsOnCall(i int, result1 http.Header) {
	fake.headersMutex.Lock()
	defer fake.headersMutex.Unlock()
	fake.HeadersStub = nil
	if fake.headersReturnsOnCall == nil {
		fake.headersReturnsOnCall = make(map[int]struct {
			result1 http.Header
		})
	}
	fake.headersReturnsOnCall[i] = struct {
		result1 http.Header
	}{result1}
}

func (fake *FakeAPIClient) Info() (models.InfoResponse, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
	}{})
	stub := fake.InfoStub
	fakeReturns := fake.infoReturns
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeAPIClient) InfoCalls(stub func() (models.InfoResponse, error)) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeAPIClient) InfoReturns(result1 models.InfoResponse, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 models.InfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) InfoReturnsOnCall(i int, result1 models.InfoResponse, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 models.InfoResponse
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 models.InfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Me() (models.MeResponse, error) {
	fake.meMutex.Lock()
	ret, specificReturn := fake.meReturnsOnCall[len(fake.meArgsForCall)]
	fake.meArgsForCall = append(fake.meArgsForCall, struct {
	}{})
	stub := fake.MeStub
	fakeReturns := fake.meReturns
	fake.recordInvocation("Me", []interface{}{})
	fake.meMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) MeCallCount() int {
	fake.meMutex.RLock()
	defer fake.meMutex.RUnlock()
	return len(fake.meArgsForCall)
}

func (fake *FakeAPIClient) MeCalls(stub func() (models.MeResponse, error)) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = stub
}

func (fake *FakeAPIClient) MeReturns(result1 models.MeResponse, result2 error) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = nil
	fake.meReturns = struct {
		result1 models.MeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) MeReturnsOnCall(i int, result1 models.MeResponse, result2 error) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = nil
	if fake.meReturnsOnCall == nil {
		fake.meReturnsOnCall = make(map[int]struct {
			result1 models.MeResponse
			result2 error
		})
	}
	fake.meReturnsOnCall[i] = struct {
		result1 models.MeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceCreate(arg1 models.NamespaceCreateRequest) (models.Response, error) {
	fake.namespaceCreateMutex.Lock()
	ret, specificReturn := fake.namespaceCreateReturnsOnCall[len(fake.namespaceCreateArgsForCall)]
	fake.namespaceCreateArgsForCall = append(fake.namespaceCreateArgsForCall, struct {
		arg1 models.NamespaceCreateRequest
	}{arg1})
	stub := fake.NamespaceCreateStub
	fakeReturns := fake.namespaceCreateReturns
	fake.recordInvocation("NamespaceCreate", []interface{}{arg1})
	fake.namespaceCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespaceCreateCallCount() int {
	fake.namespaceCreateMutex.RLock()
	defer fake.namespaceCreateMutex.RUnlock()
	return len(fake.namespaceCreateArgsForCall)
}

func (fake *FakeAPIClient) NamespaceCreateCalls(stub func(models.NamespaceCreateRequest) (models.Response, error)) {
	fake.namespaceCreateMutex.Lock()
	defer fake.namespaceCreateMutex.Unlock()
	fake.NamespaceCreateStub = stub
}

func (fake *FakeAPIClient) NamespaceCreateArgsForCall(i int) models.NamespaceCreateRequest {
	fake.namespaceCreateMutex.RLock()
	defer fake.namespaceCreateMutex.RUnlock()
	argsForCall := fake.namespaceCreateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) NamespaceCreateReturns(result1 models.Response, result2 error) {
	fake.namespaceCreateMutex.Lock()
	defer fake.namespaceCreateMutex.Unlock()
	fake.NamespaceCreateStub = nil
	fake.namespaceCreateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceCreateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.namespaceCreateMutex.Lock()
	defer fake.namespaceCreateMutex.Unlock()
	fake.NamespaceCreateStub = nil
	if fake.namespaceCreateReturnsOnCall == nil {
		fake.namespaceCreateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.namespaceCreateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceDelete(arg1 []string) (models.Response, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.namespaceDeleteMutex.Lock()
	ret, specificReturn := fake.namespaceDeleteReturnsOnCall[len(fake.namespaceDeleteArgsForCall)]
	fake.namespaceDeleteArgsForCall = append(fake.namespaceDeleteArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.NamespaceDeleteStub
	fakeReturns := fake.namespaceDeleteReturns
	fake.recordInvocation("NamespaceDelete", []interface{}{arg1Copy})
	fake.namespaceDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespaceDeleteCallCount() int {
	fake.namespaceDeleteMutex.RLock()
	defer fake.namespaceDeleteMutex.RUnlock()
	return len(fake.namespaceDeleteArgsForCall)
}

func (fake *FakeAPIClient) NamespaceDeleteCalls(stub func([]string) (models.Response, error)) {
	fake.namespaceDeleteMutex.Lock()
	defer fake.namespaceDeleteMutex.Unlock()
	fake.NamespaceDeleteStub = stub
}

func (fake *FakeAPIClient) NamespaceDeleteArgsForCall(i int) []string {
	fake.namespaceDeleteMutex.RLock()
	defer fake.namespaceDeleteMutex.RUnlock()
	argsForCall := fake.namespaceDeleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) NamespaceDeleteReturns(result1 models.Response, result2 error) {
	fake.namespaceDeleteMutex.Lock()
	defer fake.namespaceDeleteMutex.Unlock()
	fake.NamespaceDeleteStub = nil
	fake.namespaceDeleteReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceDeleteReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.namespaceDeleteMutex.Lock()
	defer fake.namespaceDeleteMutex.Unlock()
	fake.NamespaceDeleteStub = nil
	if fake.namespaceDeleteReturnsOnCall == nil {
		fake.namespaceDeleteReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.namespaceDeleteReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceShow(arg1 string) (models.Namespace, error) {
	fake.namespaceShowMutex.Lock()
	ret, specificReturn := fake.namespaceShowReturnsOnCall[len(fake.namespaceShowArgsForCall)]
	fake.namespaceShowArgsForCall = append(fake.namespaceShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NamespaceShowStub
	fakeReturns := fake.namespaceShowReturns
	fake.recordInvocation("NamespaceShow", []interface{}{arg1})
	fake.namespaceShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespaceShowCallCount() int {
	fake.namespaceShowMutex.RLock()
	defer fake.namespaceShowMutex.RUnlock()
	return len(fake.namespaceShowArgsForCall)
}

func (fake *FakeAPIClient) NamespaceShowCalls(stub func(string) (models.Namespace, error)) {
	fake.namespaceShowMutex.Lock()
	defer fake.namespaceShowMutex.Unlock()
	fake.NamespaceShowStub = stub
}

func (fake *FakeAPIClient) NamespaceShowArgsForCall(i int) string {
	fake.namespaceShowMutex.RLock()
	defer fake.namespaceShowMutex.RUnlock()
	argsForCall := fake.namespaceShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) NamespaceShowReturns(result1 models.Namespace, result2 error) {
	fake.namespaceShowMutex.Lock()
	defer fake.namespaceShowMutex.Unlock()
	fake.NamespaceShowStub = nil
	fake.namespaceShowReturns = struct {
		result1 models.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceShowReturnsOnCall(i int, result1 models.Namespace, result2 error) {
	fake.namespaceShowMutex.Lock()
	defer fake.namespaceShowMutex.Unlock()
	fake.NamespaceShowStub = nil
	if fake.namespaceShowReturnsOnCall == nil {
		fake.namespaceShowReturnsOnCall = make(map[int]struct {
			result1 models.Namespace
			result2 error
		})
	}
	fake.namespaceShowReturnsOnCall[i] = struct {
		result1 models.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Namespaces() (models.NamespaceList, error) {
	fake.namespacesMutex.Lock()
	ret, specificReturn := fake.namespacesReturnsOnCall[len(fake.namespacesArgsForCall)]
	fake.namespacesArgsForCall = append(fake.namespacesArgsForCall, struct {
	}{})
	stub := fake.NamespacesStub
	fakeReturns := fake.namespacesReturns
	fake.recordInvocation("Namespaces", []interface{}{})
	fake.namespacesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespacesCallCount() int {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	return len(fake.namespacesArgsForCall)
}

func (fake *FakeAPIClient) NamespacesCalls(stub func() (models.NamespaceList, error)) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = stub
}

func (fake *FakeAPIClient) NamespacesReturns(result1 models.NamespaceList, result2 error) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	fake.namespacesReturns = struct {
		result1 models.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespacesReturnsOnCall(i int, result1 models.NamespaceList, result2 error) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	if fake.namespacesReturnsOnCall == nil {
		fake.namespacesReturnsOnCall = make(map[int]struct {
			result1 models.NamespaceList
			result2 error
		})
	}
	fake.namespacesReturnsOnCall[i] = struct {
		result1 models.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespacesMatch(arg1 string) (models.NamespacesMatchResponse, error) {
	fake.namespacesMatchMutex.Lock()
	ret, specificReturn := fake.namespacesMatchReturnsOnCall[len(fake.namespacesMatchArgsForCall)]
	fake.namespacesMatchArgsForCall = append(fake.namespacesMatchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NamespacesMatchStub
	fakeReturns := fake.namespacesMatchReturns
	fake.recordInvocation("NamespacesMatch", []interface{}{arg1})
	fake.namespacesMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespacesMatchCallCount() int {
	fake.namespacesMatchMutex.RLock()
	defer fake.namespacesMatchMutex.RUnlock()
	return len(fake.namespacesMatchArgsForCall)
}

func (fake *FakeAPIClient) NamespacesMatchCalls(stub func(string) (models.NamespacesMatchResponse, error)) {
	fake.namespacesMatchMutex.Lock()
	defer fake.namespacesMatchMutex.Unlock()
	fake.NamespacesMatchStub = stub
}

func (fake *FakeAPIClient) NamespacesMatchArgsForCall(i int) string {
	fake.namespacesMatchMutex.RLock()
	defer fake.namespacesMatchMutex.RUnlock()
	argsForCall := fake.namespacesMatchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) NamespacesMatchReturns(result1 models.NamespacesMatchResponse, result2 error) {
	fake.namespacesMatchMutex.Lock()
	defer fake.namespacesMatchMutex.Unlock()
	fake.NamespacesMatchStub = nil
	fake.namespacesMatchReturns = struct {
		result1 models.NamespacesMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespacesMatchReturnsOnCall(i int, result1 models.NamespacesMatchResponse, result2 error) {
	fake.namespacesMatchMutex.Lock()
	defer fake.namespacesMatchMutex.Unlock()
	fake.NamespacesMatchStub = nil
	if fake.namespacesMatchReturnsOnCall == nil {
		fake.namespacesMatchReturnsOnCall = make(map[int]struct {
			result1 models.NamespacesMatchResponse
			result2 error
		})
	}
	fake.namespacesMatchReturnsOnCall[i] = struct {
		result1 models.NamespacesMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceBind(arg1 models.ServiceBindRequest, arg2 string, arg3 string) (models.Response, error) {
	fake.serviceBindMutex.Lock()
	ret, specificReturn := fake.serviceBindReturnsOnCall[len(fake.serviceBindArgsForCall)]
	fake.serviceBindArgsForCall = append(fake.serviceBindArgsForCall, struct {
		arg1 models.ServiceBindRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ServiceBindStub
	fakeReturns := fake.serviceBindReturns
	fake.recordInvocation("ServiceBind", []interface{}{arg1, arg2, arg3})
	fake.serviceBindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceBindCallCount() int {
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	return len(fake.serviceBindArgsForCall)
}

func (fake *FakeAPIClient) ServiceBindCalls(stub func(models.ServiceBindRequest, string, string) (models.Response, error)) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = stub
}

func (fake *FakeAPIClient) ServiceBindArgsForCall(i int) (models.ServiceBindRequest, string, string) {
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	argsForCall := fake.serviceBindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ServiceBindReturns(result1 models.Response, result2 error) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = nil
	fake.serviceBindReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceBindReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = nil
	if fake.serviceBindReturnsOnCall == nil {
		fake.serviceBindReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.serviceBindReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalog() (models.CatalogServices, error) {
	fake.serviceCatalogMutex.Lock()
	ret, specificReturn := fake.serviceCatalogReturnsOnCall[len(fake.serviceCatalogArgsForCall)]
	fake.serviceCatalogArgsForCall = append(fake.serviceCatalogArgsForCall, struct {
	}{})
	stub := fake.ServiceCatalogStub
	fakeReturns := fake.serviceCatalogReturns
	fake.recordInvocation("ServiceCatalog", []interface{}{})
	fake.serviceCatalogMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceCatalogCallCount() int {
	fake.serviceCatalogMutex.RLock()
	defer fake.serviceCatalogMutex.RUnlock()
	return len(fake.serviceCatalogArgsForCall)
}

func (fake *FakeAPIClient) ServiceCatalogCalls(stub func() (models.CatalogServices, error)) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = stub
}

func (fake *FakeAPIClient) ServiceCatalogReturns(result1 models.CatalogServices, result2 error) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = nil
	fake.serviceCatalogReturns = struct {
		result1 models.CatalogServices
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogReturnsOnCall(i int, result1 models.CatalogServices, result2 error) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = nil
	if fake.serviceCatalogReturnsOnCall == nil {
		fake.serviceCatalogReturnsOnCall = make(map[int]struct {
			result1 models.CatalogServices
			result2 error
		})
	}
	fake.serviceCatalogReturnsOnCall[i] = struct {
		result1 models.CatalogServices
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogMatch(arg1 string) (models.CatalogMatchResponse, error) {
	fake.serviceCatalogMatchMutex.Lock()
	ret, specificReturn := fake.serviceCatalogMatchReturnsOnCall[len(fake.serviceCatalogMatchArgsForCall)]
	fake.serviceCatalogMatchArgsForCall = append(fake.serviceCatalogMatchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceCatalogMatchStub
	fakeReturns := fake.serviceCatalogMatchReturns
	fake.recordInvocation("ServiceCatalogMatch", []interface{}{arg1})
	fake.serviceCatalogMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceCatalogMatchCallCount() int {
	fake.serviceCatalogMatchMutex.RLock()
	defer fake.serviceCatalogMatchMutex.RUnlock()
	return len(fake.serviceCatalogMatchArgsForCall)
}

func (fake *FakeAPIClient) ServiceCatalogMatchCalls(stub func(string) (models.CatalogMatchResponse, error)) {
	fake.serviceCatalogMatchMutex.Lock()
	defer fake.serviceCatalogMatchMutex.Unlock()
	fake.ServiceCatalogMatchStub = stub
}

func (fake *FakeAPIClient) ServiceCatalogMatchArgsForCall(i int) string {
	fake.serviceCatalogMatchMutex.RLock()
	defer fake.serviceCatalogMatchMutex.RUnlock()
	argsForCall := fake.serviceCatalogMatchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ServiceCatalogMatchReturns(result1 models.CatalogMatchResponse, result2 error) {
	fake.serviceCatalogMatchMutex.Lock()
	defer fake.serviceCatalogMatchMutex.Unlock()
	fake.ServiceCatalogMatchStub = nil
	fake.serviceCatalogMatchReturns = struct {
		result1 models.CatalogMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogMatchReturnsOnCall(i int, result1 models.CatalogMatchResponse, result2 error) {
	fake.serviceCatalogMatchMutex.Lock()
	defer fake.serviceCatalogMatchMutex.Unlock()
	fake.ServiceCatalogMatchStub = nil
	if fake.serviceCatalogMatchReturnsOnCall == nil {
		fake.serviceCatalogMatchReturnsOnCall = make(map[int]struct {
			result1 models.CatalogMatchResponse
			result2 error
		})
	}
	fake.serviceCatalogMatchReturnsOnCall[i] = struct {
		result1 models.CatalogMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogShow(arg1 string) (*models.CatalogService, error) {
	fake.serviceCatalogShowMutex.Lock()
	ret, specificReturn := fake.serviceCatalogShowReturnsOnCall[len(fake.serviceCatalogShowArgsForCall)]
	fake.serviceCatalogShowArgsForCall = append(fake.serviceCatalogShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceCatalogShowStub
	fakeReturns := fake.serviceCatalogShowReturns
	fake.recordInvocation("ServiceCatalogShow", []interface{}{arg1})
	fake.serviceCatalogShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceCatalogShowCallCount() int {
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	return len(fake.serviceCatalogShowArgsForCall)
}

func (fake *FakeAPIClient) ServiceCatalogShowCalls(stub func(string) (*models.CatalogService, error)) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = stub
}

func (fake *FakeAPIClient) ServiceCatalogShowArgsForCall(i int) string {
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	argsForCall := fake.serviceCatalogShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ServiceCatalogShowReturns(result1 *models.CatalogService, result2 error) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = nil
	fake.serviceCatalogShowReturns = struct {
		result1 *models.CatalogService
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogShowReturnsOnCall(i int, result1 *models.CatalogService, result2 error) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = nil
	if fake.serviceCatalogShowReturnsOnCall == nil {
		fake.serviceCatalogShowReturnsOnCall = make(map[int]struct {
			result1 *models.CatalogService
			result2 error
		})
	}
	fake.serviceCatalogShowReturnsOnCall[i] = struct {
		result1 *models.CatalogService
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCreate(arg1 models.ServiceCreateRequest, arg2 string) (models.Response, error) {
	fake.serviceCreateMutex.Lock()
	ret, specificReturn := fake.serviceCreateReturnsOnCall[len(fake.serviceCreateArgsForCall)]
	fake.serviceCreateArgsForCall = append(fake.serviceCreateArgsForCall, struct {
		arg1 models.ServiceCreateRequest
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceCreateStub
	fakeReturns := fake.serviceCreateReturns
	fake.recordInvocation("ServiceCreate", []interface{}{arg1, arg2})
	fake.serviceCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceCreateCallCount() int {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	return len(fake.serviceCreateArgsForCall)
}

func (fake *FakeAPIClient) ServiceCreateCalls(stub func(models.ServiceCreateRequest, string) (models.Response, error)) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = stub
}

func (fake *FakeAPIClient) ServiceCreateArgsForCall(i int) (models.ServiceCreateRequest, string) {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	argsForCall := fake.serviceCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ServiceCreateReturns(result1 models.Response, result2 error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = nil
	fake.serviceCreateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCreateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = nil
	if fake.serviceCreateReturnsOnCall == nil {
		fake.serviceCreateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.serviceCreateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceDelete(arg1 models.ServiceDeleteRequest, arg2 string, arg3 []string) (models.ServiceDeleteResponse, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.serviceDeleteMutex.Lock()
	ret, specificReturn := fake.serviceDeleteReturnsOnCall[len(fake.serviceDeleteArgsForCall)]
	fake.serviceDeleteArgsForCall = append(fake.serviceDeleteArgsForCall, struct {
		arg1 models.ServiceDeleteRequest
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.ServiceDeleteStub
	fakeReturns := fake.serviceDeleteReturns
	fake.recordInvocation("ServiceDelete", []interface{}{arg1, arg2, arg3Copy})
	fake.serviceDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceDeleteCallCount() int {
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	return len(fake.serviceDeleteArgsForCall)
}

func (fake *FakeAPIClient) ServiceDeleteCalls(stub func(models.ServiceDeleteRequest, string, []string) (models.ServiceDeleteResponse, error)) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = stub
}

func (fake *FakeAPIClient) ServiceDeleteArgsForCall(i int) (models.ServiceDeleteRequest, string, []string) {
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	argsForCall := fake.serviceDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ServiceDeleteReturns(result1 models.ServiceDeleteResponse, result2 error) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = nil
	fake.serviceDeleteReturns = struct {
		result1 models.ServiceDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceDeleteReturnsOnCall(i int, result1 models.ServiceDeleteResponse, result2 error) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = nil
	if fake.serviceDeleteReturnsOnCall == nil {
		fake.serviceDeleteReturnsOnCall = make(map[int]struct {
			result1 models.ServiceDeleteResponse
			result2 error
		})
	}
	fake.serviceDeleteReturnsOnCall[i] = struct {
		result1 models.ServiceDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceList(arg1 string) (models.ServiceList, error) {
	fake.serviceListMutex.Lock()
	ret, specificReturn := fake.serviceListReturnsOnCall[len(fake.serviceListArgsForCall)]
	fake.serviceListArgsForCall = append(fake.serviceListArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceListStub
	fakeReturns := fake.serviceListReturns
	fake.recordInvocation("ServiceList", []interface{}{arg1})
	fake.serviceListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceListCallCount() int {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	return len(fake.serviceListArgsForCall)
}

func (fake *FakeAPIClient) ServiceListCalls(stub func(string) (models.ServiceList, error)) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = stub
}

func (fake *FakeAPIClient) ServiceListArgsForCall(i int) string {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	argsForCall := fake.serviceListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ServiceListReturns(result1 models.ServiceList, result2 error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = nil
	fake.serviceListReturns = struct {
		result1 models.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceListReturnsOnCall(i int, result1 models.ServiceList, result2 error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = nil
	if fake.serviceListReturnsOnCall == nil {
		fake.serviceListReturnsOnCall = make(map[int]struct {
			result1 models.ServiceList
			result2 error
		})
	}
	fake.serviceListReturnsOnCall[i] = struct {
		result1 models.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceMatch(arg1 string, arg2 string) (models.ServiceMatchResponse, error) {
	fake.serviceMatchMutex.Lock()
	ret, specificReturn := fake.serviceMatchReturnsOnCall[len(fake.serviceMatchArgsForCall)]
	fake.serviceMatchArgsForCall = append(fake.serviceMatchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceMatchStub
	fakeReturns := fake.serviceMatchReturns
	fake.recordInvocation("ServiceMatch", []interface{}{arg1, arg2})
	fake.serviceMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceMatchCallCount() int {
	fake.serviceMatchMutex.RLock()
	defer fake.serviceMatchMutex.RUnlock()
	return len(fake.serviceMatchArgsForCall)
}

func (fake *FakeAPIClient) ServiceMatchCalls(stub func(string, string) (models.ServiceMatchResponse, error)) {
	fake.serviceMatchMutex.Lock()
	defer fake.serviceMatchMutex.Unlock()
	fake.ServiceMatchStub = stub
}

func (fake *FakeAPIClient) ServiceMatchArgsForCall(i int) (string, string) {
	fake.serviceMatchMutex.RLock()
	defer fake.serviceMatchMutex.RUnlock()
	argsForCall := fake.serviceMatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ServiceMatchReturns(result1 models.ServiceMatchResponse, result2 error) {
	fake.serviceMatchMutex.Lock()
	defer fake.serviceMatchMutex.Unlock()
	fake.ServiceMatchStub = nil
	fake.serviceMatchReturns = struct {
		result1 models.ServiceMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceMatchReturnsOnCall(i int, result1 models.ServiceMatchResponse, result2 error) {
	fake.serviceMatchMutex.Lock()
	defer fake.serviceMatchMutex.Unlock()
	fake.ServiceMatchStub = nil
	if fake.serviceMatchReturnsOnCall == nil {
		fake.serviceMatchReturnsOnCall = make(map[int]struct {
			result1 models.ServiceMatchResponse
			result2 error
		})
	}
	fake.serviceMatchReturnsOnCall[i] = struct {
		result1 models.ServiceMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServicePortForward(arg1 string, arg2 string, arg3 *client.PortForwardOpts) error {
	fake.servicePortForwardMutex.Lock()
	ret, specificReturn := fake.servicePortForwardReturnsOnCall[len(fake.servicePortForwardArgsForCall)]
	fake.servicePortForwardArgsForCall = append(fake.servicePortForwardArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *client.PortForwardOpts
	}{arg1, arg2, arg3})
	stub := fake.ServicePortForwardStub
	fakeReturns := fake.servicePortForwardReturns
	fake.recordInvocation("ServicePortForward", []interface{}{arg1, arg2, arg3})
	fake.servicePortForwardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) ServicePortForwardCallCount() int {
	fake.servicePortForwardMutex.RLock()
	defer fake.servicePortForwardMutex.RUnlock()
	return len(fake.servicePortForwardArgsForCall)
}

func (fake *FakeAPIClient) ServicePortForwardCalls(stub func(string, string, *client.PortForwardOpts) error) {
	fake.servicePortForwardMutex.Lock()
	defer fake.servicePortForwardMutex.Unlock()
	fake.ServicePortForwardStub = stub
}

func (fake *FakeAPIClient) ServicePortForwardArgsForCall(i int) (string, string, *client.PortForwardOpts) {
	fake.servicePortForwardMutex.RLock()
	defer fake.servicePortForwardMutex.RUnlock()
	argsForCall := fake.servicePortForwardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ServicePortForwardReturns(result1 error) {
	fake.servicePortForwardMutex.Lock()
	defer fake.servicePortForwardMutex.Unlock()
	fake.ServicePortForwardStub = nil
	fake.servicePortForwardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) ServicePortForwardReturnsOnCall(i int, result1 error) {
	fake.servicePortForwardMutex.Lock()
	defer fake.servicePortForwardMutex.Unlock()
	fake.ServicePortForwardStub = nil
	if fake.servicePortForwardReturnsOnCall == nil {
		fake.servicePortForwardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.servicePortForwardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) ServiceShow(arg1 string, arg2 string) (*models.Service, error) {
	fake.serviceShowMutex.Lock()
	ret, specificReturn := fake.serviceShowReturnsOnCall[len(fake.serviceShowArgsForCall)]
	fake.serviceShowArgsForCall = append(fake.serviceShowArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceShowStub
	fakeReturns := fake.serviceShowReturns
	fake.recordInvocation("ServiceShow", []interface{}{arg1, arg2})
	fake.serviceShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceShowCallCount() int {
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	return len(fake.serviceShowArgsForCall)
}

func (fake *FakeAPIClient) ServiceShowCalls(stub func(string, string) (*models.Service, error)) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = stub
}

func (fake *FakeAPIClient) ServiceShowArgsForCall(i int) (string, string) {
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	argsForCall := fake.serviceShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ServiceShowReturns(result1 *models.Service, result2 error) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = nil
	fake.serviceShowReturns = struct {
		result1 *models.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceShowReturnsOnCall(i int, result1 *models.Service, result2 error) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = nil
	if fake.serviceShowReturnsOnCall == nil {
		fake.serviceShowReturnsOnCall = make(map[int]struct {
			result1 *models.Service
			result2 error
		})
	}
	fake.serviceShowReturnsOnCall[i] = struct {
		result1 *models.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceUnbind(arg1 models.ServiceUnbindRequest, arg2 string, arg3 string) (models.Response, error) {
	fake.serviceUnbindMutex.Lock()
	ret, specificReturn := fake.serviceUnbindReturnsOnCall[len(fake.serviceUnbindArgsForCall)]
	fake.serviceUnbindArgsForCall = append(fake.serviceUnbindArgsForCall, struct {
		arg1 models.ServiceUnbindRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ServiceUnbindStub
	fakeReturns := fake.serviceUnbindReturns
	fake.recordInvocation("ServiceUnbind", []interface{}{arg1, arg2, arg3})
	fake.serviceUnbindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceUnbindCallCount() int {
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	return len(fake.serviceUnbindArgsForCall)
}

func (fake *FakeAPIClient) ServiceUnbindCalls(stub func(models.ServiceUnbindRequest, string, string) (models.Response, error)) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = stub
}

func (fake *FakeAPIClient) ServiceUnbindArgsForCall(i int) (models.ServiceUnbindRequest, string, string) {
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	argsForCall := fake.serviceUnbindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ServiceUnbindReturns(result1 models.Response, result2 error) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = nil
	fake.serviceUnbindReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceUnbindReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = nil
	if fake.serviceUnbindReturnsOnCall == nil {
		fake.serviceUnbindReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.serviceUnbindReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceUpdate(arg1 models.ServiceUpdateRequest, arg2 string, arg3 string) (models.Response, error) {
	fake.serviceUpdateMutex.Lock()
	ret, specificReturn := fake.serviceUpdateReturnsOnCall[len(fake.serviceUpdateArgsForCall)]
	fake.serviceUpdateArgsForCall = append(fake.serviceUpdateArgsForCall, struct {
		arg1 models.ServiceUpdateRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ServiceUpdateStub
	fakeReturns := fake.serviceUpdateReturns
	fake.recordInvocation("ServiceUpdate", []interface{}{arg1, arg2, arg3})
	fake.serviceUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceUpdateCallCount() int {
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	return len(fake.serviceUpdateArgsForCall)
}

func (fake *FakeAPIClient) ServiceUpdateCalls(stub func(models.ServiceUpdateRequest, string, string) (models.Response, error)) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = stub
}

func (fake *FakeAPIClient) ServiceUpdateArgsForCall(i int) (models.ServiceUpdateRequest, string, string) {
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	argsForCall := fake.serviceUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ServiceUpdateReturns(result1 models.Response, result2 error) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = nil
	fake.serviceUpdateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceUpdateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = nil
	if fake.serviceUpdateReturnsOnCall == nil {
		fake.serviceUpdateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.serviceUpdateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) SetHeader(arg1 string, arg2 string) {
	fake.setHeaderMutex.Lock()
	fake.setHeaderArgsForCall = append(fake.setHeaderArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetHeaderStub
	fake.recordInvocation("SetHeader", []interface{}{arg1, arg2})
	fake.setHeaderMutex.Unlock()
	if stub != nil {
		fake.SetHeaderStub(arg1, arg2)
	}
}

func (fake *FakeAPIClient) SetHeaderCallCount() int {
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	return len(fake.setHeaderArgsForCall)
}

func (fake *FakeAPIClient) SetHeaderCalls(stub func(string, string)) {
	fake.setHeaderMutex.Lock()
	defer fake.setHeaderMutex.Unlock()
	fake.SetHeaderStub = stub
}

func (fake *FakeAPIClient) SetHeaderArgsForCall(i int) (string, string) {
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	argsForCall := fake.setHeaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) StagingComplete(arg1 string, arg2 string) (models.Response, error) {
	fake.stagingCompleteMutex.Lock()
	ret, specificReturn := fake.stagingCompleteReturnsOnCall[len(fake.stagingCompleteArgsForCall)]
	fake.stagingCompleteArgsForCall = append(fake.stagingCompleteArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.StagingCompleteStub
	fakeReturns := fake.stagingCompleteReturns
	fake.recordInvocation("StagingComplete", []interface{}{arg1, arg2})
	fake.stagingCompleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) StagingCompleteCallCount() int {
	fake.stagingCompleteMutex.RLock()
	defer fake.stagingCompleteMutex.RUnlock()
	return len(fake.stagingCompleteArgsForCall)
}

func (fake *FakeAPIClient) StagingCompleteCalls(stub func(string, string) (models.Response, error)) {
	fake.stagingCompleteMutex.Lock()
	defer fake.stagingCompleteMutex.Unlock()
	fake.StagingCompleteStub = stub
}

func (fake *FakeAPIClient) StagingCompleteArgsForCall(i int) (string, string) {
	fake.stagingCompleteMutex.RLock()
	defer fake.stagingCompleteMutex.RUnlock()
	argsForCall := fake.stagingCompleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) StagingCompleteReturns(result1 models.Response, result2 error) {
	fake.stagingCompleteMutex.Lock()
	defer fake.stagingCompleteMutex.Unlock()
	fake.StagingCompleteStub = nil
	fake.stagingCompleteReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) StagingCompleteReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.stagingCompleteMutex.Lock()
	defer fake.stagingCompleteMutex.Unlock()
	fake.StagingCompleteStub = nil
	if fake.stagingCompleteReturnsOnCall == nil {
		fake.stagingCompleteReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.stagingCompleteReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) VersionWarningEnabled() bool {
	fake.versionWarningEnabledMutex.Lock()
	ret, specificReturn := fake.versionWarningEnabledReturnsOnCall[len(fake.versionWarningEnabledArgsForCall)]
	fake.versionWarningEnabledArgsForCall = append(fake.versionWarningEnabledArgsForCall, struct {
	}{})
	stub := fake.VersionWarningEnabledStub
	fakeReturns := fake.versionWarningEnabledReturns
	fake.recordInvocation("VersionWarningEnabled", []interface{}{})
	fake.versionWarningEnabledMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) VersionWarningEnabledCallCount() int {
	fake.versionWarningEnabledMutex.RLock()
	defer fake.versionWarningEnabledMutex.RUnlock()
	return len(fake.versionWarningEnabledArgsForCall)
}

func (fake *FakeAPIClient) VersionWarningEnabledCalls(stub func() bool) {
	fake.versionWarningEnabledMutex.Lock()
	defer fake.versionWarningEnabledMutex.Unlock()
	fake.VersionWarningEnabledStub = stub
}

func (fake *FakeAPIClient) VersionWarningEnabledReturns(result1 bool) {
	fake.versionWarningEnabledMutex.Lock()
	defer fake.versionWarningEnabledMutex.Unlock()
	fake.VersionWarningEnabledStub = nil
	fake.versionWarningEnabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAPIClient) VersionWarningEnabledReturnsOnCall(i int, result1 bool) {
	fake.versionWarningEnabledMutex.Lock()
	defer fake.versionWarningEnabledMutex.Unlock()
	fake.VersionWarningEnabledStub = nil
	if fake.versionWarningEnabledReturnsOnCall == nil {
		fake.versionWarningEnabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.versionWarningEnabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAPIClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allAppsMutex.RLock()
	defer fake.allAppsMutex.RUnlock()
	fake.allConfigurationsMutex.RLock()
	defer fake.allConfigurationsMutex.RUnlock()
	fake.allServicesMutex.RLock()
	defer fake.allServicesMutex.RUnlock()
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	fake.appDeployMutex.RLock()
	defer fake.appDeployMutex.RUnlock()
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	fake.appExportMutex.RLock()
	defer fake.appExportMutex.RUnlock()
	fake.appGetPartMutex.RLock()
	defer fake.appGetPartMutex.RUnlock()
	fake.appImportGitMutex.RLock()
	defer fake.appImportGitMutex.RUnlock()
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	fake.appMatchMutex.RLock()
	defer fake.appMatchMutex.RUnlock()
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	fake.appRunningMutex.RLock()
	defer fake.appRunningMutex.RUnlock()
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	fake.appStageMutex.RLock()
	defer fake.appStageMutex.RUnlock()
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	fake.appUploadMutex.RLock()
	defer fake.appUploadMutex.RUnlock()
	fake.appValidateCVMutex.RLock()
	defer fake.appValidateCVMutex.RUnlock()
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	fake.authTokenMutex.RLock()
	defer fake.authTokenMutex.RUnlock()
	fake.chartListMutex.RLock()
	defer fake.chartListMutex.RUnlock()
	fake.chartMatchMutex.RLock()
	defer fake.chartMatchMutex.RUnlock()
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	fake.configurationAppsMutex.RLock()
	defer fake.configurationAppsMutex.RUnlock()
	fake.configurationBindingCreateMutex.RLock()
	defer fake.configurationBindingCreateMutex.RUnlock()
	fake.configurationBindingDeleteMutex.RLock()
	defer fake.configurationBindingDeleteMutex.RUnlock()
	fake.configurationCreateMutex.RLock()
	defer fake.configurationCreateMutex.RUnlock()
	fake.configurationDeleteMutex.RLock()
	defer fake.configurationDeleteMutex.RUnlock()
	fake.configurationMatchMutex.RLock()
	defer fake.configurationMatchMutex.RUnlock()
	fake.configurationShowMutex.RLock()
	defer fake.configurationShowMutex.RUnlock()
	fake.configurationUpdateMutex.RLock()
	defer fake.configurationUpdateMutex.RUnlock()
	fake.configurationsMutex.RLock()
	defer fake.configurationsMutex.RUnlock()
	fake.disableVersionWarningMutex.RLock()
	defer fake.disableVersionWarningMutex.RUnlock()
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	fake.envMatchMutex.RLock()
	defer fake.envMatchMutex.RUnlock()
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	fake.exportregistryListMutex.RLock()
	defer fake.exportregistryListMutex.RUnlock()
	fake.exportregistryMatchMutex.RLock()
	defer fake.exportregistryMatchMutex.RUnlock()
	fake.gitconfigCreateMutex.RLock()
	defer fake.gitconfigCreateMutex.RUnlock()
	fake.gitconfigDeleteMutex.RLock()
	defer fake.gitconfigDeleteMutex.RUnlock()
	fake.gitconfigShowMutex.RLock()
	defer fake.gitconfigShowMutex.RUnlock()
	fake.gitconfigsMutex.RLock()
	defer fake.gitconfigsMutex.RUnlock()
	fake.gitconfigsMatchMutex.RLock()
	defer fake.gitconfigsMatchMutex.RUnlock()
	fake.headersMutex.RLock()
	defer fake.headersMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.meMutex.RLock()
	defer fake.meMutex.RUnlock()
	fake.namespaceCreateMutex.RLock()
	defer fake.namespaceCreateMutex.RUnlock()
	fake.namespaceDeleteMutex.RLock()
	defer fake.namespaceDeleteMutex.RUnlock()
	fake.namespaceShowMutex.RLock()
	defer fake.namespaceShowMutex.RUnlock()
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	fake.namespacesMatchMutex.RLock()
	defer fake.namespacesMatchMutex.RUnlock()
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	fake.serviceCatalogMutex.RLock()
	defer fake.serviceCatalogMutex.RUnlock()
	fake.serviceCatalogMatchMutex.RLock()
	defer fake.serviceCatalogMatchMutex.RUnlock()
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	fake.serviceMatchMutex.RLock()
	defer fake.serviceMatchMutex.RUnlock()
	fake.servicePortForwardMutex.RLock()
	defer fake.servicePortForwardMutex.RUnlock()
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	fake.stagingCompleteMutex.RLock()
	defer fake.stagingCompleteMutex.RUnlock()
	fake.versionWarningEnabledMutex.RLock()
	defer fake.versionWarningEnabledMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAPIClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ usercmd.APIClient = new(FakeAPIClient)
