// Copyright Â© 2021 - 2023 SUSE LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by counterfeiter. DO NOT EDIT.
package usercmdfakes

import (
	"context"
	"net/http"
	"sync"

	"github.com/epinio/epinio/helpers/kubernetes/tailer"
	"github.com/epinio/epinio/internal/cli/usercmd"
	"github.com/epinio/epinio/pkg/api/core/v1/client"
	"github.com/epinio/epinio/pkg/api/core/v1/models"
	"k8s.io/kubectl/pkg/util/term"
)

type FakeAPIClient struct {
	AllAppsStub        func() (models.AppList, error)
	allAppsMutex       sync.RWMutex
	allAppsArgsForCall []struct {
	}
	allAppsReturns struct {
		result1 models.AppList
		result2 error
	}
	allAppsReturnsOnCall map[int]struct {
		result1 models.AppList
		result2 error
	}
	AllConfigurationsStub        func() (models.ConfigurationResponseList, error)
	allConfigurationsMutex       sync.RWMutex
	allConfigurationsArgsForCall []struct {
	}
	allConfigurationsReturns struct {
		result1 models.ConfigurationResponseList
		result2 error
	}
	allConfigurationsReturnsOnCall map[int]struct {
		result1 models.ConfigurationResponseList
		result2 error
	}
	AllServicesStub        func() (models.ServiceList, error)
	allServicesMutex       sync.RWMutex
	allServicesArgsForCall []struct {
	}
	allServicesReturns struct {
		result1 models.ServiceList
		result2 error
	}
	allServicesReturnsOnCall map[int]struct {
		result1 models.ServiceList
		result2 error
	}
	AppCreateStub        func(models.ApplicationCreateRequest, string) (models.Response, error)
	appCreateMutex       sync.RWMutex
	appCreateArgsForCall []struct {
		arg1 models.ApplicationCreateRequest
		arg2 string
	}
	appCreateReturns struct {
		result1 models.Response
		result2 error
	}
	appCreateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppDeleteStub        func(string, []string) (models.ApplicationDeleteResponse, error)
	appDeleteMutex       sync.RWMutex
	appDeleteArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	appDeleteReturns struct {
		result1 models.ApplicationDeleteResponse
		result2 error
	}
	appDeleteReturnsOnCall map[int]struct {
		result1 models.ApplicationDeleteResponse
		result2 error
	}
	AppDeployStub        func(models.DeployRequest) (*models.DeployResponse, error)
	appDeployMutex       sync.RWMutex
	appDeployArgsForCall []struct {
		arg1 models.DeployRequest
	}
	appDeployReturns struct {
		result1 *models.DeployResponse
		result2 error
	}
	appDeployReturnsOnCall map[int]struct {
		result1 *models.DeployResponse
		result2 error
	}
	AppExecStub        func(context.Context, string, string, string, term.TTY) error
	appExecMutex       sync.RWMutex
	appExecArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 term.TTY
	}
	appExecReturns struct {
		result1 error
	}
	appExecReturnsOnCall map[int]struct {
		result1 error
	}
	AppGetPartStub        func(string, string, string, string) error
	appGetPartMutex       sync.RWMutex
	appGetPartArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	appGetPartReturns struct {
		result1 error
	}
	appGetPartReturnsOnCall map[int]struct {
		result1 error
	}
	AppImportGitStub        func(models.AppRef, models.GitRef) (*models.ImportGitResponse, error)
	appImportGitMutex       sync.RWMutex
	appImportGitArgsForCall []struct {
		arg1 models.AppRef
		arg2 models.GitRef
	}
	appImportGitReturns struct {
		result1 *models.ImportGitResponse
		result2 error
	}
	appImportGitReturnsOnCall map[int]struct {
		result1 *models.ImportGitResponse
		result2 error
	}
	AppLogsStub        func(string, string, string, bool, func(tailer.ContainerLogLine)) error
	appLogsMutex       sync.RWMutex
	appLogsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 bool
		arg5 func(tailer.ContainerLogLine)
	}
	appLogsReturns struct {
		result1 error
	}
	appLogsReturnsOnCall map[int]struct {
		result1 error
	}
	AppMatchStub        func(string, string) (models.AppMatchResponse, error)
	appMatchMutex       sync.RWMutex
	appMatchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appMatchReturns struct {
		result1 models.AppMatchResponse
		result2 error
	}
	appMatchReturnsOnCall map[int]struct {
		result1 models.AppMatchResponse
		result2 error
	}
	AppPortForwardStub        func(string, string, string, *client.PortForwardOpts) error
	appPortForwardMutex       sync.RWMutex
	appPortForwardArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *client.PortForwardOpts
	}
	appPortForwardReturns struct {
		result1 error
	}
	appPortForwardReturnsOnCall map[int]struct {
		result1 error
	}
	AppRestartStub        func(string, string) error
	appRestartMutex       sync.RWMutex
	appRestartArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appRestartReturns struct {
		result1 error
	}
	appRestartReturnsOnCall map[int]struct {
		result1 error
	}
	AppRunningStub        func(models.AppRef) (models.Response, error)
	appRunningMutex       sync.RWMutex
	appRunningArgsForCall []struct {
		arg1 models.AppRef
	}
	appRunningReturns struct {
		result1 models.Response
		result2 error
	}
	appRunningReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppShowStub        func(string, string) (models.App, error)
	appShowMutex       sync.RWMutex
	appShowArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appShowReturns struct {
		result1 models.App
		result2 error
	}
	appShowReturnsOnCall map[int]struct {
		result1 models.App
		result2 error
	}
	AppStageStub        func(models.StageRequest) (*models.StageResponse, error)
	appStageMutex       sync.RWMutex
	appStageArgsForCall []struct {
		arg1 models.StageRequest
	}
	appStageReturns struct {
		result1 *models.StageResponse
		result2 error
	}
	appStageReturnsOnCall map[int]struct {
		result1 *models.StageResponse
		result2 error
	}
	AppUpdateStub        func(models.ApplicationUpdateRequest, string, string) (models.Response, error)
	appUpdateMutex       sync.RWMutex
	appUpdateArgsForCall []struct {
		arg1 models.ApplicationUpdateRequest
		arg2 string
		arg3 string
	}
	appUpdateReturns struct {
		result1 models.Response
		result2 error
	}
	appUpdateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppUploadStub        func(string, string, string) (models.UploadResponse, error)
	appUploadMutex       sync.RWMutex
	appUploadArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	appUploadReturns struct {
		result1 models.UploadResponse
		result2 error
	}
	appUploadReturnsOnCall map[int]struct {
		result1 models.UploadResponse
		result2 error
	}
	AppValidateCVStub        func(string, string) (models.Response, error)
	appValidateCVMutex       sync.RWMutex
	appValidateCVArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appValidateCVReturns struct {
		result1 models.Response
		result2 error
	}
	appValidateCVReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	AppsStub        func(string) (models.AppList, error)
	appsMutex       sync.RWMutex
	appsArgsForCall []struct {
		arg1 string
	}
	appsReturns struct {
		result1 models.AppList
		result2 error
	}
	appsReturnsOnCall map[int]struct {
		result1 models.AppList
		result2 error
	}
	AuthTokenStub        func() (string, error)
	authTokenMutex       sync.RWMutex
	authTokenArgsForCall []struct {
	}
	authTokenReturns struct {
		result1 string
		result2 error
	}
	authTokenReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ChartListStub        func() ([]models.AppChart, error)
	chartListMutex       sync.RWMutex
	chartListArgsForCall []struct {
	}
	chartListReturns struct {
		result1 []models.AppChart
		result2 error
	}
	chartListReturnsOnCall map[int]struct {
		result1 []models.AppChart
		result2 error
	}
	ChartMatchStub        func(string) (models.ChartMatchResponse, error)
	chartMatchMutex       sync.RWMutex
	chartMatchArgsForCall []struct {
		arg1 string
	}
	chartMatchReturns struct {
		result1 models.ChartMatchResponse
		result2 error
	}
	chartMatchReturnsOnCall map[int]struct {
		result1 models.ChartMatchResponse
		result2 error
	}
	ChartShowStub        func(string) (models.AppChart, error)
	chartShowMutex       sync.RWMutex
	chartShowArgsForCall []struct {
		arg1 string
	}
	chartShowReturns struct {
		result1 models.AppChart
		result2 error
	}
	chartShowReturnsOnCall map[int]struct {
		result1 models.AppChart
		result2 error
	}
	ConfigurationAppsStub        func(string) (models.ConfigurationAppsResponse, error)
	configurationAppsMutex       sync.RWMutex
	configurationAppsArgsForCall []struct {
		arg1 string
	}
	configurationAppsReturns struct {
		result1 models.ConfigurationAppsResponse
		result2 error
	}
	configurationAppsReturnsOnCall map[int]struct {
		result1 models.ConfigurationAppsResponse
		result2 error
	}
	ConfigurationBindingCreateStub        func(models.BindRequest, string, string) (models.BindResponse, error)
	configurationBindingCreateMutex       sync.RWMutex
	configurationBindingCreateArgsForCall []struct {
		arg1 models.BindRequest
		arg2 string
		arg3 string
	}
	configurationBindingCreateReturns struct {
		result1 models.BindResponse
		result2 error
	}
	configurationBindingCreateReturnsOnCall map[int]struct {
		result1 models.BindResponse
		result2 error
	}
	ConfigurationBindingDeleteStub        func(string, string, string) (models.Response, error)
	configurationBindingDeleteMutex       sync.RWMutex
	configurationBindingDeleteArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	configurationBindingDeleteReturns struct {
		result1 models.Response
		result2 error
	}
	configurationBindingDeleteReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ConfigurationCreateStub        func(models.ConfigurationCreateRequest, string) (models.Response, error)
	configurationCreateMutex       sync.RWMutex
	configurationCreateArgsForCall []struct {
		arg1 models.ConfigurationCreateRequest
		arg2 string
	}
	configurationCreateReturns struct {
		result1 models.Response
		result2 error
	}
	configurationCreateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ConfigurationDeleteStub        func(models.ConfigurationDeleteRequest, string, []string, func(response *http.Response, bodyBytes []byte, err error) error) (models.ConfigurationDeleteResponse, error)
	configurationDeleteMutex       sync.RWMutex
	configurationDeleteArgsForCall []struct {
		arg1 models.ConfigurationDeleteRequest
		arg2 string
		arg3 []string
		arg4 func(response *http.Response, bodyBytes []byte, err error) error
	}
	configurationDeleteReturns struct {
		result1 models.ConfigurationDeleteResponse
		result2 error
	}
	configurationDeleteReturnsOnCall map[int]struct {
		result1 models.ConfigurationDeleteResponse
		result2 error
	}
	ConfigurationMatchStub        func(string, string) (models.ConfigurationMatchResponse, error)
	configurationMatchMutex       sync.RWMutex
	configurationMatchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	configurationMatchReturns struct {
		result1 models.ConfigurationMatchResponse
		result2 error
	}
	configurationMatchReturnsOnCall map[int]struct {
		result1 models.ConfigurationMatchResponse
		result2 error
	}
	ConfigurationShowStub        func(string, string) (models.ConfigurationResponse, error)
	configurationShowMutex       sync.RWMutex
	configurationShowArgsForCall []struct {
		arg1 string
		arg2 string
	}
	configurationShowReturns struct {
		result1 models.ConfigurationResponse
		result2 error
	}
	configurationShowReturnsOnCall map[int]struct {
		result1 models.ConfigurationResponse
		result2 error
	}
	ConfigurationUpdateStub        func(models.ConfigurationUpdateRequest, string, string) (models.Response, error)
	configurationUpdateMutex       sync.RWMutex
	configurationUpdateArgsForCall []struct {
		arg1 models.ConfigurationUpdateRequest
		arg2 string
		arg3 string
	}
	configurationUpdateReturns struct {
		result1 models.Response
		result2 error
	}
	configurationUpdateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	ConfigurationsStub        func(string) (models.ConfigurationResponseList, error)
	configurationsMutex       sync.RWMutex
	configurationsArgsForCall []struct {
		arg1 string
	}
	configurationsReturns struct {
		result1 models.ConfigurationResponseList
		result2 error
	}
	configurationsReturnsOnCall map[int]struct {
		result1 models.ConfigurationResponseList
		result2 error
	}
	DisableVersionWarningStub        func()
	disableVersionWarningMutex       sync.RWMutex
	disableVersionWarningArgsForCall []struct {
	}
	EnvListStub        func(string, string) (models.EnvVariableMap, error)
	envListMutex       sync.RWMutex
	envListArgsForCall []struct {
		arg1 string
		arg2 string
	}
	envListReturns struct {
		result1 models.EnvVariableMap
		result2 error
	}
	envListReturnsOnCall map[int]struct {
		result1 models.EnvVariableMap
		result2 error
	}
	EnvMatchStub        func(string, string, string) (models.EnvMatchResponse, error)
	envMatchMutex       sync.RWMutex
	envMatchArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	envMatchReturns struct {
		result1 models.EnvMatchResponse
		result2 error
	}
	envMatchReturnsOnCall map[int]struct {
		result1 models.EnvMatchResponse
		result2 error
	}
	EnvSetStub        func(models.EnvVariableMap, string, string) (models.Response, error)
	envSetMutex       sync.RWMutex
	envSetArgsForCall []struct {
		arg1 models.EnvVariableMap
		arg2 string
		arg3 string
	}
	envSetReturns struct {
		result1 models.Response
		result2 error
	}
	envSetReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	EnvShowStub        func(string, string, string) (models.EnvVariable, error)
	envShowMutex       sync.RWMutex
	envShowArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	envShowReturns struct {
		result1 models.EnvVariable
		result2 error
	}
	envShowReturnsOnCall map[int]struct {
		result1 models.EnvVariable
		result2 error
	}
	EnvUnsetStub        func(string, string, string) (models.Response, error)
	envUnsetMutex       sync.RWMutex
	envUnsetArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	envUnsetReturns struct {
		result1 models.Response
		result2 error
	}
	envUnsetReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	InfoStub        func() (models.InfoResponse, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
	}
	infoReturns struct {
		result1 models.InfoResponse
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 models.InfoResponse
		result2 error
	}
	NamespaceCreateStub        func(models.NamespaceCreateRequest) (models.Response, error)
	namespaceCreateMutex       sync.RWMutex
	namespaceCreateArgsForCall []struct {
		arg1 models.NamespaceCreateRequest
	}
	namespaceCreateReturns struct {
		result1 models.Response
		result2 error
	}
	namespaceCreateReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	NamespaceDeleteStub        func([]string) (models.Response, error)
	namespaceDeleteMutex       sync.RWMutex
	namespaceDeleteArgsForCall []struct {
		arg1 []string
	}
	namespaceDeleteReturns struct {
		result1 models.Response
		result2 error
	}
	namespaceDeleteReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	NamespaceShowStub        func(string) (models.Namespace, error)
	namespaceShowMutex       sync.RWMutex
	namespaceShowArgsForCall []struct {
		arg1 string
	}
	namespaceShowReturns struct {
		result1 models.Namespace
		result2 error
	}
	namespaceShowReturnsOnCall map[int]struct {
		result1 models.Namespace
		result2 error
	}
	NamespacesStub        func() (models.NamespaceList, error)
	namespacesMutex       sync.RWMutex
	namespacesArgsForCall []struct {
	}
	namespacesReturns struct {
		result1 models.NamespaceList
		result2 error
	}
	namespacesReturnsOnCall map[int]struct {
		result1 models.NamespaceList
		result2 error
	}
	NamespacesMatchStub        func(string) (models.NamespacesMatchResponse, error)
	namespacesMatchMutex       sync.RWMutex
	namespacesMatchArgsForCall []struct {
		arg1 string
	}
	namespacesMatchReturns struct {
		result1 models.NamespacesMatchResponse
		result2 error
	}
	namespacesMatchReturnsOnCall map[int]struct {
		result1 models.NamespacesMatchResponse
		result2 error
	}
	ServiceBindStub        func(*models.ServiceBindRequest, string, string) error
	serviceBindMutex       sync.RWMutex
	serviceBindArgsForCall []struct {
		arg1 *models.ServiceBindRequest
		arg2 string
		arg3 string
	}
	serviceBindReturns struct {
		result1 error
	}
	serviceBindReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceCatalogStub        func() (models.CatalogServices, error)
	serviceCatalogMutex       sync.RWMutex
	serviceCatalogArgsForCall []struct {
	}
	serviceCatalogReturns struct {
		result1 models.CatalogServices
		result2 error
	}
	serviceCatalogReturnsOnCall map[int]struct {
		result1 models.CatalogServices
		result2 error
	}
	ServiceCatalogMatchStub        func(string) (models.CatalogMatchResponse, error)
	serviceCatalogMatchMutex       sync.RWMutex
	serviceCatalogMatchArgsForCall []struct {
		arg1 string
	}
	serviceCatalogMatchReturns struct {
		result1 models.CatalogMatchResponse
		result2 error
	}
	serviceCatalogMatchReturnsOnCall map[int]struct {
		result1 models.CatalogMatchResponse
		result2 error
	}
	ServiceCatalogShowStub        func(string) (*models.CatalogService, error)
	serviceCatalogShowMutex       sync.RWMutex
	serviceCatalogShowArgsForCall []struct {
		arg1 string
	}
	serviceCatalogShowReturns struct {
		result1 *models.CatalogService
		result2 error
	}
	serviceCatalogShowReturnsOnCall map[int]struct {
		result1 *models.CatalogService
		result2 error
	}
	ServiceCreateStub        func(*models.ServiceCreateRequest, string) error
	serviceCreateMutex       sync.RWMutex
	serviceCreateArgsForCall []struct {
		arg1 *models.ServiceCreateRequest
		arg2 string
	}
	serviceCreateReturns struct {
		result1 error
	}
	serviceCreateReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceDeleteStub        func(models.ServiceDeleteRequest, string, []string, func(response *http.Response, bodyBytes []byte, err error) error) (models.ServiceDeleteResponse, error)
	serviceDeleteMutex       sync.RWMutex
	serviceDeleteArgsForCall []struct {
		arg1 models.ServiceDeleteRequest
		arg2 string
		arg3 []string
		arg4 func(response *http.Response, bodyBytes []byte, err error) error
	}
	serviceDeleteReturns struct {
		result1 models.ServiceDeleteResponse
		result2 error
	}
	serviceDeleteReturnsOnCall map[int]struct {
		result1 models.ServiceDeleteResponse
		result2 error
	}
	ServiceListStub        func(string) (models.ServiceList, error)
	serviceListMutex       sync.RWMutex
	serviceListArgsForCall []struct {
		arg1 string
	}
	serviceListReturns struct {
		result1 models.ServiceList
		result2 error
	}
	serviceListReturnsOnCall map[int]struct {
		result1 models.ServiceList
		result2 error
	}
	ServiceMatchStub        func(string, string) (models.ServiceMatchResponse, error)
	serviceMatchMutex       sync.RWMutex
	serviceMatchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	serviceMatchReturns struct {
		result1 models.ServiceMatchResponse
		result2 error
	}
	serviceMatchReturnsOnCall map[int]struct {
		result1 models.ServiceMatchResponse
		result2 error
	}
	ServiceShowStub        func(*models.ServiceShowRequest, string) (*models.Service, error)
	serviceShowMutex       sync.RWMutex
	serviceShowArgsForCall []struct {
		arg1 *models.ServiceShowRequest
		arg2 string
	}
	serviceShowReturns struct {
		result1 *models.Service
		result2 error
	}
	serviceShowReturnsOnCall map[int]struct {
		result1 *models.Service
		result2 error
	}
	ServiceUnbindStub        func(*models.ServiceUnbindRequest, string, string) error
	serviceUnbindMutex       sync.RWMutex
	serviceUnbindArgsForCall []struct {
		arg1 *models.ServiceUnbindRequest
		arg2 string
		arg3 string
	}
	serviceUnbindReturns struct {
		result1 error
	}
	serviceUnbindReturnsOnCall map[int]struct {
		result1 error
	}
	StagingCompleteStub        func(string, string) (models.Response, error)
	stagingCompleteMutex       sync.RWMutex
	stagingCompleteArgsForCall []struct {
		arg1 string
		arg2 string
	}
	stagingCompleteReturns struct {
		result1 models.Response
		result2 error
	}
	stagingCompleteReturnsOnCall map[int]struct {
		result1 models.Response
		result2 error
	}
	VersionWarningEnabledStub        func() bool
	versionWarningEnabledMutex       sync.RWMutex
	versionWarningEnabledArgsForCall []struct {
	}
	versionWarningEnabledReturns struct {
		result1 bool
	}
	versionWarningEnabledReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAPIClient) AllApps() (models.AppList, error) {
	fake.allAppsMutex.Lock()
	ret, specificReturn := fake.allAppsReturnsOnCall[len(fake.allAppsArgsForCall)]
	fake.allAppsArgsForCall = append(fake.allAppsArgsForCall, struct {
	}{})
	stub := fake.AllAppsStub
	fakeReturns := fake.allAppsReturns
	fake.recordInvocation("AllApps", []interface{}{})
	fake.allAppsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AllAppsCallCount() int {
	fake.allAppsMutex.RLock()
	defer fake.allAppsMutex.RUnlock()
	return len(fake.allAppsArgsForCall)
}

func (fake *FakeAPIClient) AllAppsCalls(stub func() (models.AppList, error)) {
	fake.allAppsMutex.Lock()
	defer fake.allAppsMutex.Unlock()
	fake.AllAppsStub = stub
}

func (fake *FakeAPIClient) AllAppsReturns(result1 models.AppList, result2 error) {
	fake.allAppsMutex.Lock()
	defer fake.allAppsMutex.Unlock()
	fake.AllAppsStub = nil
	fake.allAppsReturns = struct {
		result1 models.AppList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllAppsReturnsOnCall(i int, result1 models.AppList, result2 error) {
	fake.allAppsMutex.Lock()
	defer fake.allAppsMutex.Unlock()
	fake.AllAppsStub = nil
	if fake.allAppsReturnsOnCall == nil {
		fake.allAppsReturnsOnCall = make(map[int]struct {
			result1 models.AppList
			result2 error
		})
	}
	fake.allAppsReturnsOnCall[i] = struct {
		result1 models.AppList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllConfigurations() (models.ConfigurationResponseList, error) {
	fake.allConfigurationsMutex.Lock()
	ret, specificReturn := fake.allConfigurationsReturnsOnCall[len(fake.allConfigurationsArgsForCall)]
	fake.allConfigurationsArgsForCall = append(fake.allConfigurationsArgsForCall, struct {
	}{})
	stub := fake.AllConfigurationsStub
	fakeReturns := fake.allConfigurationsReturns
	fake.recordInvocation("AllConfigurations", []interface{}{})
	fake.allConfigurationsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AllConfigurationsCallCount() int {
	fake.allConfigurationsMutex.RLock()
	defer fake.allConfigurationsMutex.RUnlock()
	return len(fake.allConfigurationsArgsForCall)
}

func (fake *FakeAPIClient) AllConfigurationsCalls(stub func() (models.ConfigurationResponseList, error)) {
	fake.allConfigurationsMutex.Lock()
	defer fake.allConfigurationsMutex.Unlock()
	fake.AllConfigurationsStub = stub
}

func (fake *FakeAPIClient) AllConfigurationsReturns(result1 models.ConfigurationResponseList, result2 error) {
	fake.allConfigurationsMutex.Lock()
	defer fake.allConfigurationsMutex.Unlock()
	fake.AllConfigurationsStub = nil
	fake.allConfigurationsReturns = struct {
		result1 models.ConfigurationResponseList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllConfigurationsReturnsOnCall(i int, result1 models.ConfigurationResponseList, result2 error) {
	fake.allConfigurationsMutex.Lock()
	defer fake.allConfigurationsMutex.Unlock()
	fake.AllConfigurationsStub = nil
	if fake.allConfigurationsReturnsOnCall == nil {
		fake.allConfigurationsReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationResponseList
			result2 error
		})
	}
	fake.allConfigurationsReturnsOnCall[i] = struct {
		result1 models.ConfigurationResponseList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllServices() (models.ServiceList, error) {
	fake.allServicesMutex.Lock()
	ret, specificReturn := fake.allServicesReturnsOnCall[len(fake.allServicesArgsForCall)]
	fake.allServicesArgsForCall = append(fake.allServicesArgsForCall, struct {
	}{})
	stub := fake.AllServicesStub
	fakeReturns := fake.allServicesReturns
	fake.recordInvocation("AllServices", []interface{}{})
	fake.allServicesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AllServicesCallCount() int {
	fake.allServicesMutex.RLock()
	defer fake.allServicesMutex.RUnlock()
	return len(fake.allServicesArgsForCall)
}

func (fake *FakeAPIClient) AllServicesCalls(stub func() (models.ServiceList, error)) {
	fake.allServicesMutex.Lock()
	defer fake.allServicesMutex.Unlock()
	fake.AllServicesStub = stub
}

func (fake *FakeAPIClient) AllServicesReturns(result1 models.ServiceList, result2 error) {
	fake.allServicesMutex.Lock()
	defer fake.allServicesMutex.Unlock()
	fake.AllServicesStub = nil
	fake.allServicesReturns = struct {
		result1 models.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AllServicesReturnsOnCall(i int, result1 models.ServiceList, result2 error) {
	fake.allServicesMutex.Lock()
	defer fake.allServicesMutex.Unlock()
	fake.AllServicesStub = nil
	if fake.allServicesReturnsOnCall == nil {
		fake.allServicesReturnsOnCall = make(map[int]struct {
			result1 models.ServiceList
			result2 error
		})
	}
	fake.allServicesReturnsOnCall[i] = struct {
		result1 models.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppCreate(arg1 models.ApplicationCreateRequest, arg2 string) (models.Response, error) {
	fake.appCreateMutex.Lock()
	ret, specificReturn := fake.appCreateReturnsOnCall[len(fake.appCreateArgsForCall)]
	fake.appCreateArgsForCall = append(fake.appCreateArgsForCall, struct {
		arg1 models.ApplicationCreateRequest
		arg2 string
	}{arg1, arg2})
	stub := fake.AppCreateStub
	fakeReturns := fake.appCreateReturns
	fake.recordInvocation("AppCreate", []interface{}{arg1, arg2})
	fake.appCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppCreateCallCount() int {
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	return len(fake.appCreateArgsForCall)
}

func (fake *FakeAPIClient) AppCreateCalls(stub func(models.ApplicationCreateRequest, string) (models.Response, error)) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = stub
}

func (fake *FakeAPIClient) AppCreateArgsForCall(i int) (models.ApplicationCreateRequest, string) {
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	argsForCall := fake.appCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppCreateReturns(result1 models.Response, result2 error) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = nil
	fake.appCreateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppCreateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = nil
	if fake.appCreateReturnsOnCall == nil {
		fake.appCreateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appCreateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppDelete(arg1 string, arg2 []string) (models.ApplicationDeleteResponse, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.appDeleteMutex.Lock()
	ret, specificReturn := fake.appDeleteReturnsOnCall[len(fake.appDeleteArgsForCall)]
	fake.appDeleteArgsForCall = append(fake.appDeleteArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.AppDeleteStub
	fakeReturns := fake.appDeleteReturns
	fake.recordInvocation("AppDelete", []interface{}{arg1, arg2Copy})
	fake.appDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppDeleteCallCount() int {
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	return len(fake.appDeleteArgsForCall)
}

func (fake *FakeAPIClient) AppDeleteCalls(stub func(string, []string) (models.ApplicationDeleteResponse, error)) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = stub
}

func (fake *FakeAPIClient) AppDeleteArgsForCall(i int) (string, []string) {
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	argsForCall := fake.appDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppDeleteReturns(result1 models.ApplicationDeleteResponse, result2 error) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = nil
	fake.appDeleteReturns = struct {
		result1 models.ApplicationDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppDeleteReturnsOnCall(i int, result1 models.ApplicationDeleteResponse, result2 error) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = nil
	if fake.appDeleteReturnsOnCall == nil {
		fake.appDeleteReturnsOnCall = make(map[int]struct {
			result1 models.ApplicationDeleteResponse
			result2 error
		})
	}
	fake.appDeleteReturnsOnCall[i] = struct {
		result1 models.ApplicationDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppDeploy(arg1 models.DeployRequest) (*models.DeployResponse, error) {
	fake.appDeployMutex.Lock()
	ret, specificReturn := fake.appDeployReturnsOnCall[len(fake.appDeployArgsForCall)]
	fake.appDeployArgsForCall = append(fake.appDeployArgsForCall, struct {
		arg1 models.DeployRequest
	}{arg1})
	stub := fake.AppDeployStub
	fakeReturns := fake.appDeployReturns
	fake.recordInvocation("AppDeploy", []interface{}{arg1})
	fake.appDeployMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppDeployCallCount() int {
	fake.appDeployMutex.RLock()
	defer fake.appDeployMutex.RUnlock()
	return len(fake.appDeployArgsForCall)
}

func (fake *FakeAPIClient) AppDeployCalls(stub func(models.DeployRequest) (*models.DeployResponse, error)) {
	fake.appDeployMutex.Lock()
	defer fake.appDeployMutex.Unlock()
	fake.AppDeployStub = stub
}

func (fake *FakeAPIClient) AppDeployArgsForCall(i int) models.DeployRequest {
	fake.appDeployMutex.RLock()
	defer fake.appDeployMutex.RUnlock()
	argsForCall := fake.appDeployArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) AppDeployReturns(result1 *models.DeployResponse, result2 error) {
	fake.appDeployMutex.Lock()
	defer fake.appDeployMutex.Unlock()
	fake.AppDeployStub = nil
	fake.appDeployReturns = struct {
		result1 *models.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppDeployReturnsOnCall(i int, result1 *models.DeployResponse, result2 error) {
	fake.appDeployMutex.Lock()
	defer fake.appDeployMutex.Unlock()
	fake.AppDeployStub = nil
	if fake.appDeployReturnsOnCall == nil {
		fake.appDeployReturnsOnCall = make(map[int]struct {
			result1 *models.DeployResponse
			result2 error
		})
	}
	fake.appDeployReturnsOnCall[i] = struct {
		result1 *models.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppExec(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 term.TTY) error {
	fake.appExecMutex.Lock()
	ret, specificReturn := fake.appExecReturnsOnCall[len(fake.appExecArgsForCall)]
	fake.appExecArgsForCall = append(fake.appExecArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 term.TTY
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AppExecStub
	fakeReturns := fake.appExecReturns
	fake.recordInvocation("AppExec", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.appExecMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) AppExecCallCount() int {
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	return len(fake.appExecArgsForCall)
}

func (fake *FakeAPIClient) AppExecCalls(stub func(context.Context, string, string, string, term.TTY) error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = stub
}

func (fake *FakeAPIClient) AppExecArgsForCall(i int) (context.Context, string, string, string, term.TTY) {
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	argsForCall := fake.appExecArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeAPIClient) AppExecReturns(result1 error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = nil
	fake.appExecReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppExecReturnsOnCall(i int, result1 error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = nil
	if fake.appExecReturnsOnCall == nil {
		fake.appExecReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appExecReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppGetPart(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.appGetPartMutex.Lock()
	ret, specificReturn := fake.appGetPartReturnsOnCall[len(fake.appGetPartArgsForCall)]
	fake.appGetPartArgsForCall = append(fake.appGetPartArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.AppGetPartStub
	fakeReturns := fake.appGetPartReturns
	fake.recordInvocation("AppGetPart", []interface{}{arg1, arg2, arg3, arg4})
	fake.appGetPartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) AppGetPartCallCount() int {
	fake.appGetPartMutex.RLock()
	defer fake.appGetPartMutex.RUnlock()
	return len(fake.appGetPartArgsForCall)
}

func (fake *FakeAPIClient) AppGetPartCalls(stub func(string, string, string, string) error) {
	fake.appGetPartMutex.Lock()
	defer fake.appGetPartMutex.Unlock()
	fake.AppGetPartStub = stub
}

func (fake *FakeAPIClient) AppGetPartArgsForCall(i int) (string, string, string, string) {
	fake.appGetPartMutex.RLock()
	defer fake.appGetPartMutex.RUnlock()
	argsForCall := fake.appGetPartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAPIClient) AppGetPartReturns(result1 error) {
	fake.appGetPartMutex.Lock()
	defer fake.appGetPartMutex.Unlock()
	fake.AppGetPartStub = nil
	fake.appGetPartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppGetPartReturnsOnCall(i int, result1 error) {
	fake.appGetPartMutex.Lock()
	defer fake.appGetPartMutex.Unlock()
	fake.AppGetPartStub = nil
	if fake.appGetPartReturnsOnCall == nil {
		fake.appGetPartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appGetPartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppImportGit(arg1 models.AppRef, arg2 models.GitRef) (*models.ImportGitResponse, error) {
	fake.appImportGitMutex.Lock()
	ret, specificReturn := fake.appImportGitReturnsOnCall[len(fake.appImportGitArgsForCall)]
	fake.appImportGitArgsForCall = append(fake.appImportGitArgsForCall, struct {
		arg1 models.AppRef
		arg2 models.GitRef
	}{arg1, arg2})
	stub := fake.AppImportGitStub
	fakeReturns := fake.appImportGitReturns
	fake.recordInvocation("AppImportGit", []interface{}{arg1, arg2})
	fake.appImportGitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppImportGitCallCount() int {
	fake.appImportGitMutex.RLock()
	defer fake.appImportGitMutex.RUnlock()
	return len(fake.appImportGitArgsForCall)
}

func (fake *FakeAPIClient) AppImportGitCalls(stub func(models.AppRef, models.GitRef) (*models.ImportGitResponse, error)) {
	fake.appImportGitMutex.Lock()
	defer fake.appImportGitMutex.Unlock()
	fake.AppImportGitStub = stub
}

func (fake *FakeAPIClient) AppImportGitArgsForCall(i int) (models.AppRef, models.GitRef) {
	fake.appImportGitMutex.RLock()
	defer fake.appImportGitMutex.RUnlock()
	argsForCall := fake.appImportGitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppImportGitReturns(result1 *models.ImportGitResponse, result2 error) {
	fake.appImportGitMutex.Lock()
	defer fake.appImportGitMutex.Unlock()
	fake.AppImportGitStub = nil
	fake.appImportGitReturns = struct {
		result1 *models.ImportGitResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppImportGitReturnsOnCall(i int, result1 *models.ImportGitResponse, result2 error) {
	fake.appImportGitMutex.Lock()
	defer fake.appImportGitMutex.Unlock()
	fake.AppImportGitStub = nil
	if fake.appImportGitReturnsOnCall == nil {
		fake.appImportGitReturnsOnCall = make(map[int]struct {
			result1 *models.ImportGitResponse
			result2 error
		})
	}
	fake.appImportGitReturnsOnCall[i] = struct {
		result1 *models.ImportGitResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppLogs(arg1 string, arg2 string, arg3 string, arg4 bool, arg5 func(tailer.ContainerLogLine)) error {
	fake.appLogsMutex.Lock()
	ret, specificReturn := fake.appLogsReturnsOnCall[len(fake.appLogsArgsForCall)]
	fake.appLogsArgsForCall = append(fake.appLogsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 bool
		arg5 func(tailer.ContainerLogLine)
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AppLogsStub
	fakeReturns := fake.appLogsReturns
	fake.recordInvocation("AppLogs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.appLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) AppLogsCallCount() int {
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	return len(fake.appLogsArgsForCall)
}

func (fake *FakeAPIClient) AppLogsCalls(stub func(string, string, string, bool, func(tailer.ContainerLogLine)) error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = stub
}

func (fake *FakeAPIClient) AppLogsArgsForCall(i int) (string, string, string, bool, func(tailer.ContainerLogLine)) {
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	argsForCall := fake.appLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeAPIClient) AppLogsReturns(result1 error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = nil
	fake.appLogsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppLogsReturnsOnCall(i int, result1 error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = nil
	if fake.appLogsReturnsOnCall == nil {
		fake.appLogsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appLogsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppMatch(arg1 string, arg2 string) (models.AppMatchResponse, error) {
	fake.appMatchMutex.Lock()
	ret, specificReturn := fake.appMatchReturnsOnCall[len(fake.appMatchArgsForCall)]
	fake.appMatchArgsForCall = append(fake.appMatchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppMatchStub
	fakeReturns := fake.appMatchReturns
	fake.recordInvocation("AppMatch", []interface{}{arg1, arg2})
	fake.appMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppMatchCallCount() int {
	fake.appMatchMutex.RLock()
	defer fake.appMatchMutex.RUnlock()
	return len(fake.appMatchArgsForCall)
}

func (fake *FakeAPIClient) AppMatchCalls(stub func(string, string) (models.AppMatchResponse, error)) {
	fake.appMatchMutex.Lock()
	defer fake.appMatchMutex.Unlock()
	fake.AppMatchStub = stub
}

func (fake *FakeAPIClient) AppMatchArgsForCall(i int) (string, string) {
	fake.appMatchMutex.RLock()
	defer fake.appMatchMutex.RUnlock()
	argsForCall := fake.appMatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppMatchReturns(result1 models.AppMatchResponse, result2 error) {
	fake.appMatchMutex.Lock()
	defer fake.appMatchMutex.Unlock()
	fake.AppMatchStub = nil
	fake.appMatchReturns = struct {
		result1 models.AppMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppMatchReturnsOnCall(i int, result1 models.AppMatchResponse, result2 error) {
	fake.appMatchMutex.Lock()
	defer fake.appMatchMutex.Unlock()
	fake.AppMatchStub = nil
	if fake.appMatchReturnsOnCall == nil {
		fake.appMatchReturnsOnCall = make(map[int]struct {
			result1 models.AppMatchResponse
			result2 error
		})
	}
	fake.appMatchReturnsOnCall[i] = struct {
		result1 models.AppMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppPortForward(arg1 string, arg2 string, arg3 string, arg4 *client.PortForwardOpts) error {
	fake.appPortForwardMutex.Lock()
	ret, specificReturn := fake.appPortForwardReturnsOnCall[len(fake.appPortForwardArgsForCall)]
	fake.appPortForwardArgsForCall = append(fake.appPortForwardArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *client.PortForwardOpts
	}{arg1, arg2, arg3, arg4})
	stub := fake.AppPortForwardStub
	fakeReturns := fake.appPortForwardReturns
	fake.recordInvocation("AppPortForward", []interface{}{arg1, arg2, arg3, arg4})
	fake.appPortForwardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) AppPortForwardCallCount() int {
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	return len(fake.appPortForwardArgsForCall)
}

func (fake *FakeAPIClient) AppPortForwardCalls(stub func(string, string, string, *client.PortForwardOpts) error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = stub
}

func (fake *FakeAPIClient) AppPortForwardArgsForCall(i int) (string, string, string, *client.PortForwardOpts) {
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	argsForCall := fake.appPortForwardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAPIClient) AppPortForwardReturns(result1 error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = nil
	fake.appPortForwardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppPortForwardReturnsOnCall(i int, result1 error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = nil
	if fake.appPortForwardReturnsOnCall == nil {
		fake.appPortForwardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appPortForwardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppRestart(arg1 string, arg2 string) error {
	fake.appRestartMutex.Lock()
	ret, specificReturn := fake.appRestartReturnsOnCall[len(fake.appRestartArgsForCall)]
	fake.appRestartArgsForCall = append(fake.appRestartArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppRestartStub
	fakeReturns := fake.appRestartReturns
	fake.recordInvocation("AppRestart", []interface{}{arg1, arg2})
	fake.appRestartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) AppRestartCallCount() int {
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	return len(fake.appRestartArgsForCall)
}

func (fake *FakeAPIClient) AppRestartCalls(stub func(string, string) error) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = stub
}

func (fake *FakeAPIClient) AppRestartArgsForCall(i int) (string, string) {
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	argsForCall := fake.appRestartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppRestartReturns(result1 error) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = nil
	fake.appRestartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppRestartReturnsOnCall(i int, result1 error) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = nil
	if fake.appRestartReturnsOnCall == nil {
		fake.appRestartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appRestartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) AppRunning(arg1 models.AppRef) (models.Response, error) {
	fake.appRunningMutex.Lock()
	ret, specificReturn := fake.appRunningReturnsOnCall[len(fake.appRunningArgsForCall)]
	fake.appRunningArgsForCall = append(fake.appRunningArgsForCall, struct {
		arg1 models.AppRef
	}{arg1})
	stub := fake.AppRunningStub
	fakeReturns := fake.appRunningReturns
	fake.recordInvocation("AppRunning", []interface{}{arg1})
	fake.appRunningMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppRunningCallCount() int {
	fake.appRunningMutex.RLock()
	defer fake.appRunningMutex.RUnlock()
	return len(fake.appRunningArgsForCall)
}

func (fake *FakeAPIClient) AppRunningCalls(stub func(models.AppRef) (models.Response, error)) {
	fake.appRunningMutex.Lock()
	defer fake.appRunningMutex.Unlock()
	fake.AppRunningStub = stub
}

func (fake *FakeAPIClient) AppRunningArgsForCall(i int) models.AppRef {
	fake.appRunningMutex.RLock()
	defer fake.appRunningMutex.RUnlock()
	argsForCall := fake.appRunningArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) AppRunningReturns(result1 models.Response, result2 error) {
	fake.appRunningMutex.Lock()
	defer fake.appRunningMutex.Unlock()
	fake.AppRunningStub = nil
	fake.appRunningReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppRunningReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appRunningMutex.Lock()
	defer fake.appRunningMutex.Unlock()
	fake.AppRunningStub = nil
	if fake.appRunningReturnsOnCall == nil {
		fake.appRunningReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appRunningReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppShow(arg1 string, arg2 string) (models.App, error) {
	fake.appShowMutex.Lock()
	ret, specificReturn := fake.appShowReturnsOnCall[len(fake.appShowArgsForCall)]
	fake.appShowArgsForCall = append(fake.appShowArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppShowStub
	fakeReturns := fake.appShowReturns
	fake.recordInvocation("AppShow", []interface{}{arg1, arg2})
	fake.appShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppShowCallCount() int {
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	return len(fake.appShowArgsForCall)
}

func (fake *FakeAPIClient) AppShowCalls(stub func(string, string) (models.App, error)) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = stub
}

func (fake *FakeAPIClient) AppShowArgsForCall(i int) (string, string) {
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	argsForCall := fake.appShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppShowReturns(result1 models.App, result2 error) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = nil
	fake.appShowReturns = struct {
		result1 models.App
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppShowReturnsOnCall(i int, result1 models.App, result2 error) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = nil
	if fake.appShowReturnsOnCall == nil {
		fake.appShowReturnsOnCall = make(map[int]struct {
			result1 models.App
			result2 error
		})
	}
	fake.appShowReturnsOnCall[i] = struct {
		result1 models.App
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppStage(arg1 models.StageRequest) (*models.StageResponse, error) {
	fake.appStageMutex.Lock()
	ret, specificReturn := fake.appStageReturnsOnCall[len(fake.appStageArgsForCall)]
	fake.appStageArgsForCall = append(fake.appStageArgsForCall, struct {
		arg1 models.StageRequest
	}{arg1})
	stub := fake.AppStageStub
	fakeReturns := fake.appStageReturns
	fake.recordInvocation("AppStage", []interface{}{arg1})
	fake.appStageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppStageCallCount() int {
	fake.appStageMutex.RLock()
	defer fake.appStageMutex.RUnlock()
	return len(fake.appStageArgsForCall)
}

func (fake *FakeAPIClient) AppStageCalls(stub func(models.StageRequest) (*models.StageResponse, error)) {
	fake.appStageMutex.Lock()
	defer fake.appStageMutex.Unlock()
	fake.AppStageStub = stub
}

func (fake *FakeAPIClient) AppStageArgsForCall(i int) models.StageRequest {
	fake.appStageMutex.RLock()
	defer fake.appStageMutex.RUnlock()
	argsForCall := fake.appStageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) AppStageReturns(result1 *models.StageResponse, result2 error) {
	fake.appStageMutex.Lock()
	defer fake.appStageMutex.Unlock()
	fake.AppStageStub = nil
	fake.appStageReturns = struct {
		result1 *models.StageResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppStageReturnsOnCall(i int, result1 *models.StageResponse, result2 error) {
	fake.appStageMutex.Lock()
	defer fake.appStageMutex.Unlock()
	fake.AppStageStub = nil
	if fake.appStageReturnsOnCall == nil {
		fake.appStageReturnsOnCall = make(map[int]struct {
			result1 *models.StageResponse
			result2 error
		})
	}
	fake.appStageReturnsOnCall[i] = struct {
		result1 *models.StageResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppUpdate(arg1 models.ApplicationUpdateRequest, arg2 string, arg3 string) (models.Response, error) {
	fake.appUpdateMutex.Lock()
	ret, specificReturn := fake.appUpdateReturnsOnCall[len(fake.appUpdateArgsForCall)]
	fake.appUpdateArgsForCall = append(fake.appUpdateArgsForCall, struct {
		arg1 models.ApplicationUpdateRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AppUpdateStub
	fakeReturns := fake.appUpdateReturns
	fake.recordInvocation("AppUpdate", []interface{}{arg1, arg2, arg3})
	fake.appUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppUpdateCallCount() int {
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	return len(fake.appUpdateArgsForCall)
}

func (fake *FakeAPIClient) AppUpdateCalls(stub func(models.ApplicationUpdateRequest, string, string) (models.Response, error)) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = stub
}

func (fake *FakeAPIClient) AppUpdateArgsForCall(i int) (models.ApplicationUpdateRequest, string, string) {
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	argsForCall := fake.appUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) AppUpdateReturns(result1 models.Response, result2 error) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = nil
	fake.appUpdateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppUpdateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = nil
	if fake.appUpdateReturnsOnCall == nil {
		fake.appUpdateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appUpdateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppUpload(arg1 string, arg2 string, arg3 string) (models.UploadResponse, error) {
	fake.appUploadMutex.Lock()
	ret, specificReturn := fake.appUploadReturnsOnCall[len(fake.appUploadArgsForCall)]
	fake.appUploadArgsForCall = append(fake.appUploadArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AppUploadStub
	fakeReturns := fake.appUploadReturns
	fake.recordInvocation("AppUpload", []interface{}{arg1, arg2, arg3})
	fake.appUploadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppUploadCallCount() int {
	fake.appUploadMutex.RLock()
	defer fake.appUploadMutex.RUnlock()
	return len(fake.appUploadArgsForCall)
}

func (fake *FakeAPIClient) AppUploadCalls(stub func(string, string, string) (models.UploadResponse, error)) {
	fake.appUploadMutex.Lock()
	defer fake.appUploadMutex.Unlock()
	fake.AppUploadStub = stub
}

func (fake *FakeAPIClient) AppUploadArgsForCall(i int) (string, string, string) {
	fake.appUploadMutex.RLock()
	defer fake.appUploadMutex.RUnlock()
	argsForCall := fake.appUploadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) AppUploadReturns(result1 models.UploadResponse, result2 error) {
	fake.appUploadMutex.Lock()
	defer fake.appUploadMutex.Unlock()
	fake.AppUploadStub = nil
	fake.appUploadReturns = struct {
		result1 models.UploadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppUploadReturnsOnCall(i int, result1 models.UploadResponse, result2 error) {
	fake.appUploadMutex.Lock()
	defer fake.appUploadMutex.Unlock()
	fake.AppUploadStub = nil
	if fake.appUploadReturnsOnCall == nil {
		fake.appUploadReturnsOnCall = make(map[int]struct {
			result1 models.UploadResponse
			result2 error
		})
	}
	fake.appUploadReturnsOnCall[i] = struct {
		result1 models.UploadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppValidateCV(arg1 string, arg2 string) (models.Response, error) {
	fake.appValidateCVMutex.Lock()
	ret, specificReturn := fake.appValidateCVReturnsOnCall[len(fake.appValidateCVArgsForCall)]
	fake.appValidateCVArgsForCall = append(fake.appValidateCVArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppValidateCVStub
	fakeReturns := fake.appValidateCVReturns
	fake.recordInvocation("AppValidateCV", []interface{}{arg1, arg2})
	fake.appValidateCVMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppValidateCVCallCount() int {
	fake.appValidateCVMutex.RLock()
	defer fake.appValidateCVMutex.RUnlock()
	return len(fake.appValidateCVArgsForCall)
}

func (fake *FakeAPIClient) AppValidateCVCalls(stub func(string, string) (models.Response, error)) {
	fake.appValidateCVMutex.Lock()
	defer fake.appValidateCVMutex.Unlock()
	fake.AppValidateCVStub = stub
}

func (fake *FakeAPIClient) AppValidateCVArgsForCall(i int) (string, string) {
	fake.appValidateCVMutex.RLock()
	defer fake.appValidateCVMutex.RUnlock()
	argsForCall := fake.appValidateCVArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) AppValidateCVReturns(result1 models.Response, result2 error) {
	fake.appValidateCVMutex.Lock()
	defer fake.appValidateCVMutex.Unlock()
	fake.AppValidateCVStub = nil
	fake.appValidateCVReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppValidateCVReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.appValidateCVMutex.Lock()
	defer fake.appValidateCVMutex.Unlock()
	fake.AppValidateCVStub = nil
	if fake.appValidateCVReturnsOnCall == nil {
		fake.appValidateCVReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.appValidateCVReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Apps(arg1 string) (models.AppList, error) {
	fake.appsMutex.Lock()
	ret, specificReturn := fake.appsReturnsOnCall[len(fake.appsArgsForCall)]
	fake.appsArgsForCall = append(fake.appsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AppsStub
	fakeReturns := fake.appsReturns
	fake.recordInvocation("Apps", []interface{}{arg1})
	fake.appsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AppsCallCount() int {
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	return len(fake.appsArgsForCall)
}

func (fake *FakeAPIClient) AppsCalls(stub func(string) (models.AppList, error)) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = stub
}

func (fake *FakeAPIClient) AppsArgsForCall(i int) string {
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	argsForCall := fake.appsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) AppsReturns(result1 models.AppList, result2 error) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = nil
	fake.appsReturns = struct {
		result1 models.AppList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AppsReturnsOnCall(i int, result1 models.AppList, result2 error) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = nil
	if fake.appsReturnsOnCall == nil {
		fake.appsReturnsOnCall = make(map[int]struct {
			result1 models.AppList
			result2 error
		})
	}
	fake.appsReturnsOnCall[i] = struct {
		result1 models.AppList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AuthToken() (string, error) {
	fake.authTokenMutex.Lock()
	ret, specificReturn := fake.authTokenReturnsOnCall[len(fake.authTokenArgsForCall)]
	fake.authTokenArgsForCall = append(fake.authTokenArgsForCall, struct {
	}{})
	stub := fake.AuthTokenStub
	fakeReturns := fake.authTokenReturns
	fake.recordInvocation("AuthToken", []interface{}{})
	fake.authTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) AuthTokenCallCount() int {
	fake.authTokenMutex.RLock()
	defer fake.authTokenMutex.RUnlock()
	return len(fake.authTokenArgsForCall)
}

func (fake *FakeAPIClient) AuthTokenCalls(stub func() (string, error)) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = stub
}

func (fake *FakeAPIClient) AuthTokenReturns(result1 string, result2 error) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = nil
	fake.authTokenReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) AuthTokenReturnsOnCall(i int, result1 string, result2 error) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = nil
	if fake.authTokenReturnsOnCall == nil {
		fake.authTokenReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.authTokenReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartList() ([]models.AppChart, error) {
	fake.chartListMutex.Lock()
	ret, specificReturn := fake.chartListReturnsOnCall[len(fake.chartListArgsForCall)]
	fake.chartListArgsForCall = append(fake.chartListArgsForCall, struct {
	}{})
	stub := fake.ChartListStub
	fakeReturns := fake.chartListReturns
	fake.recordInvocation("ChartList", []interface{}{})
	fake.chartListMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ChartListCallCount() int {
	fake.chartListMutex.RLock()
	defer fake.chartListMutex.RUnlock()
	return len(fake.chartListArgsForCall)
}

func (fake *FakeAPIClient) ChartListCalls(stub func() ([]models.AppChart, error)) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = stub
}

func (fake *FakeAPIClient) ChartListReturns(result1 []models.AppChart, result2 error) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = nil
	fake.chartListReturns = struct {
		result1 []models.AppChart
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartListReturnsOnCall(i int, result1 []models.AppChart, result2 error) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = nil
	if fake.chartListReturnsOnCall == nil {
		fake.chartListReturnsOnCall = make(map[int]struct {
			result1 []models.AppChart
			result2 error
		})
	}
	fake.chartListReturnsOnCall[i] = struct {
		result1 []models.AppChart
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartMatch(arg1 string) (models.ChartMatchResponse, error) {
	fake.chartMatchMutex.Lock()
	ret, specificReturn := fake.chartMatchReturnsOnCall[len(fake.chartMatchArgsForCall)]
	fake.chartMatchArgsForCall = append(fake.chartMatchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ChartMatchStub
	fakeReturns := fake.chartMatchReturns
	fake.recordInvocation("ChartMatch", []interface{}{arg1})
	fake.chartMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ChartMatchCallCount() int {
	fake.chartMatchMutex.RLock()
	defer fake.chartMatchMutex.RUnlock()
	return len(fake.chartMatchArgsForCall)
}

func (fake *FakeAPIClient) ChartMatchCalls(stub func(string) (models.ChartMatchResponse, error)) {
	fake.chartMatchMutex.Lock()
	defer fake.chartMatchMutex.Unlock()
	fake.ChartMatchStub = stub
}

func (fake *FakeAPIClient) ChartMatchArgsForCall(i int) string {
	fake.chartMatchMutex.RLock()
	defer fake.chartMatchMutex.RUnlock()
	argsForCall := fake.chartMatchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ChartMatchReturns(result1 models.ChartMatchResponse, result2 error) {
	fake.chartMatchMutex.Lock()
	defer fake.chartMatchMutex.Unlock()
	fake.ChartMatchStub = nil
	fake.chartMatchReturns = struct {
		result1 models.ChartMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartMatchReturnsOnCall(i int, result1 models.ChartMatchResponse, result2 error) {
	fake.chartMatchMutex.Lock()
	defer fake.chartMatchMutex.Unlock()
	fake.ChartMatchStub = nil
	if fake.chartMatchReturnsOnCall == nil {
		fake.chartMatchReturnsOnCall = make(map[int]struct {
			result1 models.ChartMatchResponse
			result2 error
		})
	}
	fake.chartMatchReturnsOnCall[i] = struct {
		result1 models.ChartMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartShow(arg1 string) (models.AppChart, error) {
	fake.chartShowMutex.Lock()
	ret, specificReturn := fake.chartShowReturnsOnCall[len(fake.chartShowArgsForCall)]
	fake.chartShowArgsForCall = append(fake.chartShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ChartShowStub
	fakeReturns := fake.chartShowReturns
	fake.recordInvocation("ChartShow", []interface{}{arg1})
	fake.chartShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ChartShowCallCount() int {
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	return len(fake.chartShowArgsForCall)
}

func (fake *FakeAPIClient) ChartShowCalls(stub func(string) (models.AppChart, error)) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = stub
}

func (fake *FakeAPIClient) ChartShowArgsForCall(i int) string {
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	argsForCall := fake.chartShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ChartShowReturns(result1 models.AppChart, result2 error) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = nil
	fake.chartShowReturns = struct {
		result1 models.AppChart
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ChartShowReturnsOnCall(i int, result1 models.AppChart, result2 error) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = nil
	if fake.chartShowReturnsOnCall == nil {
		fake.chartShowReturnsOnCall = make(map[int]struct {
			result1 models.AppChart
			result2 error
		})
	}
	fake.chartShowReturnsOnCall[i] = struct {
		result1 models.AppChart
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationApps(arg1 string) (models.ConfigurationAppsResponse, error) {
	fake.configurationAppsMutex.Lock()
	ret, specificReturn := fake.configurationAppsReturnsOnCall[len(fake.configurationAppsArgsForCall)]
	fake.configurationAppsArgsForCall = append(fake.configurationAppsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ConfigurationAppsStub
	fakeReturns := fake.configurationAppsReturns
	fake.recordInvocation("ConfigurationApps", []interface{}{arg1})
	fake.configurationAppsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationAppsCallCount() int {
	fake.configurationAppsMutex.RLock()
	defer fake.configurationAppsMutex.RUnlock()
	return len(fake.configurationAppsArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationAppsCalls(stub func(string) (models.ConfigurationAppsResponse, error)) {
	fake.configurationAppsMutex.Lock()
	defer fake.configurationAppsMutex.Unlock()
	fake.ConfigurationAppsStub = stub
}

func (fake *FakeAPIClient) ConfigurationAppsArgsForCall(i int) string {
	fake.configurationAppsMutex.RLock()
	defer fake.configurationAppsMutex.RUnlock()
	argsForCall := fake.configurationAppsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ConfigurationAppsReturns(result1 models.ConfigurationAppsResponse, result2 error) {
	fake.configurationAppsMutex.Lock()
	defer fake.configurationAppsMutex.Unlock()
	fake.ConfigurationAppsStub = nil
	fake.configurationAppsReturns = struct {
		result1 models.ConfigurationAppsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationAppsReturnsOnCall(i int, result1 models.ConfigurationAppsResponse, result2 error) {
	fake.configurationAppsMutex.Lock()
	defer fake.configurationAppsMutex.Unlock()
	fake.ConfigurationAppsStub = nil
	if fake.configurationAppsReturnsOnCall == nil {
		fake.configurationAppsReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationAppsResponse
			result2 error
		})
	}
	fake.configurationAppsReturnsOnCall[i] = struct {
		result1 models.ConfigurationAppsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationBindingCreate(arg1 models.BindRequest, arg2 string, arg3 string) (models.BindResponse, error) {
	fake.configurationBindingCreateMutex.Lock()
	ret, specificReturn := fake.configurationBindingCreateReturnsOnCall[len(fake.configurationBindingCreateArgsForCall)]
	fake.configurationBindingCreateArgsForCall = append(fake.configurationBindingCreateArgsForCall, struct {
		arg1 models.BindRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ConfigurationBindingCreateStub
	fakeReturns := fake.configurationBindingCreateReturns
	fake.recordInvocation("ConfigurationBindingCreate", []interface{}{arg1, arg2, arg3})
	fake.configurationBindingCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationBindingCreateCallCount() int {
	fake.configurationBindingCreateMutex.RLock()
	defer fake.configurationBindingCreateMutex.RUnlock()
	return len(fake.configurationBindingCreateArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationBindingCreateCalls(stub func(models.BindRequest, string, string) (models.BindResponse, error)) {
	fake.configurationBindingCreateMutex.Lock()
	defer fake.configurationBindingCreateMutex.Unlock()
	fake.ConfigurationBindingCreateStub = stub
}

func (fake *FakeAPIClient) ConfigurationBindingCreateArgsForCall(i int) (models.BindRequest, string, string) {
	fake.configurationBindingCreateMutex.RLock()
	defer fake.configurationBindingCreateMutex.RUnlock()
	argsForCall := fake.configurationBindingCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ConfigurationBindingCreateReturns(result1 models.BindResponse, result2 error) {
	fake.configurationBindingCreateMutex.Lock()
	defer fake.configurationBindingCreateMutex.Unlock()
	fake.ConfigurationBindingCreateStub = nil
	fake.configurationBindingCreateReturns = struct {
		result1 models.BindResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationBindingCreateReturnsOnCall(i int, result1 models.BindResponse, result2 error) {
	fake.configurationBindingCreateMutex.Lock()
	defer fake.configurationBindingCreateMutex.Unlock()
	fake.ConfigurationBindingCreateStub = nil
	if fake.configurationBindingCreateReturnsOnCall == nil {
		fake.configurationBindingCreateReturnsOnCall = make(map[int]struct {
			result1 models.BindResponse
			result2 error
		})
	}
	fake.configurationBindingCreateReturnsOnCall[i] = struct {
		result1 models.BindResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationBindingDelete(arg1 string, arg2 string, arg3 string) (models.Response, error) {
	fake.configurationBindingDeleteMutex.Lock()
	ret, specificReturn := fake.configurationBindingDeleteReturnsOnCall[len(fake.configurationBindingDeleteArgsForCall)]
	fake.configurationBindingDeleteArgsForCall = append(fake.configurationBindingDeleteArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ConfigurationBindingDeleteStub
	fakeReturns := fake.configurationBindingDeleteReturns
	fake.recordInvocation("ConfigurationBindingDelete", []interface{}{arg1, arg2, arg3})
	fake.configurationBindingDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteCallCount() int {
	fake.configurationBindingDeleteMutex.RLock()
	defer fake.configurationBindingDeleteMutex.RUnlock()
	return len(fake.configurationBindingDeleteArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteCalls(stub func(string, string, string) (models.Response, error)) {
	fake.configurationBindingDeleteMutex.Lock()
	defer fake.configurationBindingDeleteMutex.Unlock()
	fake.ConfigurationBindingDeleteStub = stub
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteArgsForCall(i int) (string, string, string) {
	fake.configurationBindingDeleteMutex.RLock()
	defer fake.configurationBindingDeleteMutex.RUnlock()
	argsForCall := fake.configurationBindingDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteReturns(result1 models.Response, result2 error) {
	fake.configurationBindingDeleteMutex.Lock()
	defer fake.configurationBindingDeleteMutex.Unlock()
	fake.ConfigurationBindingDeleteStub = nil
	fake.configurationBindingDeleteReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationBindingDeleteReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.configurationBindingDeleteMutex.Lock()
	defer fake.configurationBindingDeleteMutex.Unlock()
	fake.ConfigurationBindingDeleteStub = nil
	if fake.configurationBindingDeleteReturnsOnCall == nil {
		fake.configurationBindingDeleteReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.configurationBindingDeleteReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationCreate(arg1 models.ConfigurationCreateRequest, arg2 string) (models.Response, error) {
	fake.configurationCreateMutex.Lock()
	ret, specificReturn := fake.configurationCreateReturnsOnCall[len(fake.configurationCreateArgsForCall)]
	fake.configurationCreateArgsForCall = append(fake.configurationCreateArgsForCall, struct {
		arg1 models.ConfigurationCreateRequest
		arg2 string
	}{arg1, arg2})
	stub := fake.ConfigurationCreateStub
	fakeReturns := fake.configurationCreateReturns
	fake.recordInvocation("ConfigurationCreate", []interface{}{arg1, arg2})
	fake.configurationCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationCreateCallCount() int {
	fake.configurationCreateMutex.RLock()
	defer fake.configurationCreateMutex.RUnlock()
	return len(fake.configurationCreateArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationCreateCalls(stub func(models.ConfigurationCreateRequest, string) (models.Response, error)) {
	fake.configurationCreateMutex.Lock()
	defer fake.configurationCreateMutex.Unlock()
	fake.ConfigurationCreateStub = stub
}

func (fake *FakeAPIClient) ConfigurationCreateArgsForCall(i int) (models.ConfigurationCreateRequest, string) {
	fake.configurationCreateMutex.RLock()
	defer fake.configurationCreateMutex.RUnlock()
	argsForCall := fake.configurationCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ConfigurationCreateReturns(result1 models.Response, result2 error) {
	fake.configurationCreateMutex.Lock()
	defer fake.configurationCreateMutex.Unlock()
	fake.ConfigurationCreateStub = nil
	fake.configurationCreateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationCreateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.configurationCreateMutex.Lock()
	defer fake.configurationCreateMutex.Unlock()
	fake.ConfigurationCreateStub = nil
	if fake.configurationCreateReturnsOnCall == nil {
		fake.configurationCreateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.configurationCreateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationDelete(arg1 models.ConfigurationDeleteRequest, arg2 string, arg3 []string, arg4 func(response *http.Response, bodyBytes []byte, err error) error) (models.ConfigurationDeleteResponse, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.configurationDeleteMutex.Lock()
	ret, specificReturn := fake.configurationDeleteReturnsOnCall[len(fake.configurationDeleteArgsForCall)]
	fake.configurationDeleteArgsForCall = append(fake.configurationDeleteArgsForCall, struct {
		arg1 models.ConfigurationDeleteRequest
		arg2 string
		arg3 []string
		arg4 func(response *http.Response, bodyBytes []byte, err error) error
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.ConfigurationDeleteStub
	fakeReturns := fake.configurationDeleteReturns
	fake.recordInvocation("ConfigurationDelete", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.configurationDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationDeleteCallCount() int {
	fake.configurationDeleteMutex.RLock()
	defer fake.configurationDeleteMutex.RUnlock()
	return len(fake.configurationDeleteArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationDeleteCalls(stub func(models.ConfigurationDeleteRequest, string, []string, func(response *http.Response, bodyBytes []byte, err error) error) (models.ConfigurationDeleteResponse, error)) {
	fake.configurationDeleteMutex.Lock()
	defer fake.configurationDeleteMutex.Unlock()
	fake.ConfigurationDeleteStub = stub
}

func (fake *FakeAPIClient) ConfigurationDeleteArgsForCall(i int) (models.ConfigurationDeleteRequest, string, []string, func(response *http.Response, bodyBytes []byte, err error) error) {
	fake.configurationDeleteMutex.RLock()
	defer fake.configurationDeleteMutex.RUnlock()
	argsForCall := fake.configurationDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAPIClient) ConfigurationDeleteReturns(result1 models.ConfigurationDeleteResponse, result2 error) {
	fake.configurationDeleteMutex.Lock()
	defer fake.configurationDeleteMutex.Unlock()
	fake.ConfigurationDeleteStub = nil
	fake.configurationDeleteReturns = struct {
		result1 models.ConfigurationDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationDeleteReturnsOnCall(i int, result1 models.ConfigurationDeleteResponse, result2 error) {
	fake.configurationDeleteMutex.Lock()
	defer fake.configurationDeleteMutex.Unlock()
	fake.ConfigurationDeleteStub = nil
	if fake.configurationDeleteReturnsOnCall == nil {
		fake.configurationDeleteReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationDeleteResponse
			result2 error
		})
	}
	fake.configurationDeleteReturnsOnCall[i] = struct {
		result1 models.ConfigurationDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationMatch(arg1 string, arg2 string) (models.ConfigurationMatchResponse, error) {
	fake.configurationMatchMutex.Lock()
	ret, specificReturn := fake.configurationMatchReturnsOnCall[len(fake.configurationMatchArgsForCall)]
	fake.configurationMatchArgsForCall = append(fake.configurationMatchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ConfigurationMatchStub
	fakeReturns := fake.configurationMatchReturns
	fake.recordInvocation("ConfigurationMatch", []interface{}{arg1, arg2})
	fake.configurationMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationMatchCallCount() int {
	fake.configurationMatchMutex.RLock()
	defer fake.configurationMatchMutex.RUnlock()
	return len(fake.configurationMatchArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationMatchCalls(stub func(string, string) (models.ConfigurationMatchResponse, error)) {
	fake.configurationMatchMutex.Lock()
	defer fake.configurationMatchMutex.Unlock()
	fake.ConfigurationMatchStub = stub
}

func (fake *FakeAPIClient) ConfigurationMatchArgsForCall(i int) (string, string) {
	fake.configurationMatchMutex.RLock()
	defer fake.configurationMatchMutex.RUnlock()
	argsForCall := fake.configurationMatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ConfigurationMatchReturns(result1 models.ConfigurationMatchResponse, result2 error) {
	fake.configurationMatchMutex.Lock()
	defer fake.configurationMatchMutex.Unlock()
	fake.ConfigurationMatchStub = nil
	fake.configurationMatchReturns = struct {
		result1 models.ConfigurationMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationMatchReturnsOnCall(i int, result1 models.ConfigurationMatchResponse, result2 error) {
	fake.configurationMatchMutex.Lock()
	defer fake.configurationMatchMutex.Unlock()
	fake.ConfigurationMatchStub = nil
	if fake.configurationMatchReturnsOnCall == nil {
		fake.configurationMatchReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationMatchResponse
			result2 error
		})
	}
	fake.configurationMatchReturnsOnCall[i] = struct {
		result1 models.ConfigurationMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationShow(arg1 string, arg2 string) (models.ConfigurationResponse, error) {
	fake.configurationShowMutex.Lock()
	ret, specificReturn := fake.configurationShowReturnsOnCall[len(fake.configurationShowArgsForCall)]
	fake.configurationShowArgsForCall = append(fake.configurationShowArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ConfigurationShowStub
	fakeReturns := fake.configurationShowReturns
	fake.recordInvocation("ConfigurationShow", []interface{}{arg1, arg2})
	fake.configurationShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationShowCallCount() int {
	fake.configurationShowMutex.RLock()
	defer fake.configurationShowMutex.RUnlock()
	return len(fake.configurationShowArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationShowCalls(stub func(string, string) (models.ConfigurationResponse, error)) {
	fake.configurationShowMutex.Lock()
	defer fake.configurationShowMutex.Unlock()
	fake.ConfigurationShowStub = stub
}

func (fake *FakeAPIClient) ConfigurationShowArgsForCall(i int) (string, string) {
	fake.configurationShowMutex.RLock()
	defer fake.configurationShowMutex.RUnlock()
	argsForCall := fake.configurationShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ConfigurationShowReturns(result1 models.ConfigurationResponse, result2 error) {
	fake.configurationShowMutex.Lock()
	defer fake.configurationShowMutex.Unlock()
	fake.ConfigurationShowStub = nil
	fake.configurationShowReturns = struct {
		result1 models.ConfigurationResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationShowReturnsOnCall(i int, result1 models.ConfigurationResponse, result2 error) {
	fake.configurationShowMutex.Lock()
	defer fake.configurationShowMutex.Unlock()
	fake.ConfigurationShowStub = nil
	if fake.configurationShowReturnsOnCall == nil {
		fake.configurationShowReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationResponse
			result2 error
		})
	}
	fake.configurationShowReturnsOnCall[i] = struct {
		result1 models.ConfigurationResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationUpdate(arg1 models.ConfigurationUpdateRequest, arg2 string, arg3 string) (models.Response, error) {
	fake.configurationUpdateMutex.Lock()
	ret, specificReturn := fake.configurationUpdateReturnsOnCall[len(fake.configurationUpdateArgsForCall)]
	fake.configurationUpdateArgsForCall = append(fake.configurationUpdateArgsForCall, struct {
		arg1 models.ConfigurationUpdateRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ConfigurationUpdateStub
	fakeReturns := fake.configurationUpdateReturns
	fake.recordInvocation("ConfigurationUpdate", []interface{}{arg1, arg2, arg3})
	fake.configurationUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationUpdateCallCount() int {
	fake.configurationUpdateMutex.RLock()
	defer fake.configurationUpdateMutex.RUnlock()
	return len(fake.configurationUpdateArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationUpdateCalls(stub func(models.ConfigurationUpdateRequest, string, string) (models.Response, error)) {
	fake.configurationUpdateMutex.Lock()
	defer fake.configurationUpdateMutex.Unlock()
	fake.ConfigurationUpdateStub = stub
}

func (fake *FakeAPIClient) ConfigurationUpdateArgsForCall(i int) (models.ConfigurationUpdateRequest, string, string) {
	fake.configurationUpdateMutex.RLock()
	defer fake.configurationUpdateMutex.RUnlock()
	argsForCall := fake.configurationUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ConfigurationUpdateReturns(result1 models.Response, result2 error) {
	fake.configurationUpdateMutex.Lock()
	defer fake.configurationUpdateMutex.Unlock()
	fake.ConfigurationUpdateStub = nil
	fake.configurationUpdateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationUpdateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.configurationUpdateMutex.Lock()
	defer fake.configurationUpdateMutex.Unlock()
	fake.ConfigurationUpdateStub = nil
	if fake.configurationUpdateReturnsOnCall == nil {
		fake.configurationUpdateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.configurationUpdateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Configurations(arg1 string) (models.ConfigurationResponseList, error) {
	fake.configurationsMutex.Lock()
	ret, specificReturn := fake.configurationsReturnsOnCall[len(fake.configurationsArgsForCall)]
	fake.configurationsArgsForCall = append(fake.configurationsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ConfigurationsStub
	fakeReturns := fake.configurationsReturns
	fake.recordInvocation("Configurations", []interface{}{arg1})
	fake.configurationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ConfigurationsCallCount() int {
	fake.configurationsMutex.RLock()
	defer fake.configurationsMutex.RUnlock()
	return len(fake.configurationsArgsForCall)
}

func (fake *FakeAPIClient) ConfigurationsCalls(stub func(string) (models.ConfigurationResponseList, error)) {
	fake.configurationsMutex.Lock()
	defer fake.configurationsMutex.Unlock()
	fake.ConfigurationsStub = stub
}

func (fake *FakeAPIClient) ConfigurationsArgsForCall(i int) string {
	fake.configurationsMutex.RLock()
	defer fake.configurationsMutex.RUnlock()
	argsForCall := fake.configurationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ConfigurationsReturns(result1 models.ConfigurationResponseList, result2 error) {
	fake.configurationsMutex.Lock()
	defer fake.configurationsMutex.Unlock()
	fake.ConfigurationsStub = nil
	fake.configurationsReturns = struct {
		result1 models.ConfigurationResponseList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ConfigurationsReturnsOnCall(i int, result1 models.ConfigurationResponseList, result2 error) {
	fake.configurationsMutex.Lock()
	defer fake.configurationsMutex.Unlock()
	fake.ConfigurationsStub = nil
	if fake.configurationsReturnsOnCall == nil {
		fake.configurationsReturnsOnCall = make(map[int]struct {
			result1 models.ConfigurationResponseList
			result2 error
		})
	}
	fake.configurationsReturnsOnCall[i] = struct {
		result1 models.ConfigurationResponseList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) DisableVersionWarning() {
	fake.disableVersionWarningMutex.Lock()
	fake.disableVersionWarningArgsForCall = append(fake.disableVersionWarningArgsForCall, struct {
	}{})
	stub := fake.DisableVersionWarningStub
	fake.recordInvocation("DisableVersionWarning", []interface{}{})
	fake.disableVersionWarningMutex.Unlock()
	if stub != nil {
		fake.DisableVersionWarningStub()
	}
}

func (fake *FakeAPIClient) DisableVersionWarningCallCount() int {
	fake.disableVersionWarningMutex.RLock()
	defer fake.disableVersionWarningMutex.RUnlock()
	return len(fake.disableVersionWarningArgsForCall)
}

func (fake *FakeAPIClient) DisableVersionWarningCalls(stub func()) {
	fake.disableVersionWarningMutex.Lock()
	defer fake.disableVersionWarningMutex.Unlock()
	fake.DisableVersionWarningStub = stub
}

func (fake *FakeAPIClient) EnvList(arg1 string, arg2 string) (models.EnvVariableMap, error) {
	fake.envListMutex.Lock()
	ret, specificReturn := fake.envListReturnsOnCall[len(fake.envListArgsForCall)]
	fake.envListArgsForCall = append(fake.envListArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.EnvListStub
	fakeReturns := fake.envListReturns
	fake.recordInvocation("EnvList", []interface{}{arg1, arg2})
	fake.envListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvListCallCount() int {
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	return len(fake.envListArgsForCall)
}

func (fake *FakeAPIClient) EnvListCalls(stub func(string, string) (models.EnvVariableMap, error)) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = stub
}

func (fake *FakeAPIClient) EnvListArgsForCall(i int) (string, string) {
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	argsForCall := fake.envListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) EnvListReturns(result1 models.EnvVariableMap, result2 error) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = nil
	fake.envListReturns = struct {
		result1 models.EnvVariableMap
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvListReturnsOnCall(i int, result1 models.EnvVariableMap, result2 error) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = nil
	if fake.envListReturnsOnCall == nil {
		fake.envListReturnsOnCall = make(map[int]struct {
			result1 models.EnvVariableMap
			result2 error
		})
	}
	fake.envListReturnsOnCall[i] = struct {
		result1 models.EnvVariableMap
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvMatch(arg1 string, arg2 string, arg3 string) (models.EnvMatchResponse, error) {
	fake.envMatchMutex.Lock()
	ret, specificReturn := fake.envMatchReturnsOnCall[len(fake.envMatchArgsForCall)]
	fake.envMatchArgsForCall = append(fake.envMatchArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvMatchStub
	fakeReturns := fake.envMatchReturns
	fake.recordInvocation("EnvMatch", []interface{}{arg1, arg2, arg3})
	fake.envMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvMatchCallCount() int {
	fake.envMatchMutex.RLock()
	defer fake.envMatchMutex.RUnlock()
	return len(fake.envMatchArgsForCall)
}

func (fake *FakeAPIClient) EnvMatchCalls(stub func(string, string, string) (models.EnvMatchResponse, error)) {
	fake.envMatchMutex.Lock()
	defer fake.envMatchMutex.Unlock()
	fake.EnvMatchStub = stub
}

func (fake *FakeAPIClient) EnvMatchArgsForCall(i int) (string, string, string) {
	fake.envMatchMutex.RLock()
	defer fake.envMatchMutex.RUnlock()
	argsForCall := fake.envMatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) EnvMatchReturns(result1 models.EnvMatchResponse, result2 error) {
	fake.envMatchMutex.Lock()
	defer fake.envMatchMutex.Unlock()
	fake.EnvMatchStub = nil
	fake.envMatchReturns = struct {
		result1 models.EnvMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvMatchReturnsOnCall(i int, result1 models.EnvMatchResponse, result2 error) {
	fake.envMatchMutex.Lock()
	defer fake.envMatchMutex.Unlock()
	fake.EnvMatchStub = nil
	if fake.envMatchReturnsOnCall == nil {
		fake.envMatchReturnsOnCall = make(map[int]struct {
			result1 models.EnvMatchResponse
			result2 error
		})
	}
	fake.envMatchReturnsOnCall[i] = struct {
		result1 models.EnvMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvSet(arg1 models.EnvVariableMap, arg2 string, arg3 string) (models.Response, error) {
	fake.envSetMutex.Lock()
	ret, specificReturn := fake.envSetReturnsOnCall[len(fake.envSetArgsForCall)]
	fake.envSetArgsForCall = append(fake.envSetArgsForCall, struct {
		arg1 models.EnvVariableMap
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvSetStub
	fakeReturns := fake.envSetReturns
	fake.recordInvocation("EnvSet", []interface{}{arg1, arg2, arg3})
	fake.envSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvSetCallCount() int {
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	return len(fake.envSetArgsForCall)
}

func (fake *FakeAPIClient) EnvSetCalls(stub func(models.EnvVariableMap, string, string) (models.Response, error)) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = stub
}

func (fake *FakeAPIClient) EnvSetArgsForCall(i int) (models.EnvVariableMap, string, string) {
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	argsForCall := fake.envSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) EnvSetReturns(result1 models.Response, result2 error) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = nil
	fake.envSetReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvSetReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = nil
	if fake.envSetReturnsOnCall == nil {
		fake.envSetReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.envSetReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvShow(arg1 string, arg2 string, arg3 string) (models.EnvVariable, error) {
	fake.envShowMutex.Lock()
	ret, specificReturn := fake.envShowReturnsOnCall[len(fake.envShowArgsForCall)]
	fake.envShowArgsForCall = append(fake.envShowArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvShowStub
	fakeReturns := fake.envShowReturns
	fake.recordInvocation("EnvShow", []interface{}{arg1, arg2, arg3})
	fake.envShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvShowCallCount() int {
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	return len(fake.envShowArgsForCall)
}

func (fake *FakeAPIClient) EnvShowCalls(stub func(string, string, string) (models.EnvVariable, error)) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = stub
}

func (fake *FakeAPIClient) EnvShowArgsForCall(i int) (string, string, string) {
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	argsForCall := fake.envShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) EnvShowReturns(result1 models.EnvVariable, result2 error) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = nil
	fake.envShowReturns = struct {
		result1 models.EnvVariable
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvShowReturnsOnCall(i int, result1 models.EnvVariable, result2 error) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = nil
	if fake.envShowReturnsOnCall == nil {
		fake.envShowReturnsOnCall = make(map[int]struct {
			result1 models.EnvVariable
			result2 error
		})
	}
	fake.envShowReturnsOnCall[i] = struct {
		result1 models.EnvVariable
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvUnset(arg1 string, arg2 string, arg3 string) (models.Response, error) {
	fake.envUnsetMutex.Lock()
	ret, specificReturn := fake.envUnsetReturnsOnCall[len(fake.envUnsetArgsForCall)]
	fake.envUnsetArgsForCall = append(fake.envUnsetArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvUnsetStub
	fakeReturns := fake.envUnsetReturns
	fake.recordInvocation("EnvUnset", []interface{}{arg1, arg2, arg3})
	fake.envUnsetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) EnvUnsetCallCount() int {
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	return len(fake.envUnsetArgsForCall)
}

func (fake *FakeAPIClient) EnvUnsetCalls(stub func(string, string, string) (models.Response, error)) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = stub
}

func (fake *FakeAPIClient) EnvUnsetArgsForCall(i int) (string, string, string) {
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	argsForCall := fake.envUnsetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) EnvUnsetReturns(result1 models.Response, result2 error) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = nil
	fake.envUnsetReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) EnvUnsetReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = nil
	if fake.envUnsetReturnsOnCall == nil {
		fake.envUnsetReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.envUnsetReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Info() (models.InfoResponse, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
	}{})
	stub := fake.InfoStub
	fakeReturns := fake.infoReturns
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeAPIClient) InfoCalls(stub func() (models.InfoResponse, error)) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeAPIClient) InfoReturns(result1 models.InfoResponse, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 models.InfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) InfoReturnsOnCall(i int, result1 models.InfoResponse, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 models.InfoResponse
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 models.InfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceCreate(arg1 models.NamespaceCreateRequest) (models.Response, error) {
	fake.namespaceCreateMutex.Lock()
	ret, specificReturn := fake.namespaceCreateReturnsOnCall[len(fake.namespaceCreateArgsForCall)]
	fake.namespaceCreateArgsForCall = append(fake.namespaceCreateArgsForCall, struct {
		arg1 models.NamespaceCreateRequest
	}{arg1})
	stub := fake.NamespaceCreateStub
	fakeReturns := fake.namespaceCreateReturns
	fake.recordInvocation("NamespaceCreate", []interface{}{arg1})
	fake.namespaceCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespaceCreateCallCount() int {
	fake.namespaceCreateMutex.RLock()
	defer fake.namespaceCreateMutex.RUnlock()
	return len(fake.namespaceCreateArgsForCall)
}

func (fake *FakeAPIClient) NamespaceCreateCalls(stub func(models.NamespaceCreateRequest) (models.Response, error)) {
	fake.namespaceCreateMutex.Lock()
	defer fake.namespaceCreateMutex.Unlock()
	fake.NamespaceCreateStub = stub
}

func (fake *FakeAPIClient) NamespaceCreateArgsForCall(i int) models.NamespaceCreateRequest {
	fake.namespaceCreateMutex.RLock()
	defer fake.namespaceCreateMutex.RUnlock()
	argsForCall := fake.namespaceCreateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) NamespaceCreateReturns(result1 models.Response, result2 error) {
	fake.namespaceCreateMutex.Lock()
	defer fake.namespaceCreateMutex.Unlock()
	fake.NamespaceCreateStub = nil
	fake.namespaceCreateReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceCreateReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.namespaceCreateMutex.Lock()
	defer fake.namespaceCreateMutex.Unlock()
	fake.NamespaceCreateStub = nil
	if fake.namespaceCreateReturnsOnCall == nil {
		fake.namespaceCreateReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.namespaceCreateReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceDelete(arg1 []string) (models.Response, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.namespaceDeleteMutex.Lock()
	ret, specificReturn := fake.namespaceDeleteReturnsOnCall[len(fake.namespaceDeleteArgsForCall)]
	fake.namespaceDeleteArgsForCall = append(fake.namespaceDeleteArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.NamespaceDeleteStub
	fakeReturns := fake.namespaceDeleteReturns
	fake.recordInvocation("NamespaceDelete", []interface{}{arg1Copy})
	fake.namespaceDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespaceDeleteCallCount() int {
	fake.namespaceDeleteMutex.RLock()
	defer fake.namespaceDeleteMutex.RUnlock()
	return len(fake.namespaceDeleteArgsForCall)
}

func (fake *FakeAPIClient) NamespaceDeleteCalls(stub func([]string) (models.Response, error)) {
	fake.namespaceDeleteMutex.Lock()
	defer fake.namespaceDeleteMutex.Unlock()
	fake.NamespaceDeleteStub = stub
}

func (fake *FakeAPIClient) NamespaceDeleteArgsForCall(i int) []string {
	fake.namespaceDeleteMutex.RLock()
	defer fake.namespaceDeleteMutex.RUnlock()
	argsForCall := fake.namespaceDeleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) NamespaceDeleteReturns(result1 models.Response, result2 error) {
	fake.namespaceDeleteMutex.Lock()
	defer fake.namespaceDeleteMutex.Unlock()
	fake.NamespaceDeleteStub = nil
	fake.namespaceDeleteReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceDeleteReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.namespaceDeleteMutex.Lock()
	defer fake.namespaceDeleteMutex.Unlock()
	fake.NamespaceDeleteStub = nil
	if fake.namespaceDeleteReturnsOnCall == nil {
		fake.namespaceDeleteReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.namespaceDeleteReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceShow(arg1 string) (models.Namespace, error) {
	fake.namespaceShowMutex.Lock()
	ret, specificReturn := fake.namespaceShowReturnsOnCall[len(fake.namespaceShowArgsForCall)]
	fake.namespaceShowArgsForCall = append(fake.namespaceShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NamespaceShowStub
	fakeReturns := fake.namespaceShowReturns
	fake.recordInvocation("NamespaceShow", []interface{}{arg1})
	fake.namespaceShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespaceShowCallCount() int {
	fake.namespaceShowMutex.RLock()
	defer fake.namespaceShowMutex.RUnlock()
	return len(fake.namespaceShowArgsForCall)
}

func (fake *FakeAPIClient) NamespaceShowCalls(stub func(string) (models.Namespace, error)) {
	fake.namespaceShowMutex.Lock()
	defer fake.namespaceShowMutex.Unlock()
	fake.NamespaceShowStub = stub
}

func (fake *FakeAPIClient) NamespaceShowArgsForCall(i int) string {
	fake.namespaceShowMutex.RLock()
	defer fake.namespaceShowMutex.RUnlock()
	argsForCall := fake.namespaceShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) NamespaceShowReturns(result1 models.Namespace, result2 error) {
	fake.namespaceShowMutex.Lock()
	defer fake.namespaceShowMutex.Unlock()
	fake.NamespaceShowStub = nil
	fake.namespaceShowReturns = struct {
		result1 models.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespaceShowReturnsOnCall(i int, result1 models.Namespace, result2 error) {
	fake.namespaceShowMutex.Lock()
	defer fake.namespaceShowMutex.Unlock()
	fake.NamespaceShowStub = nil
	if fake.namespaceShowReturnsOnCall == nil {
		fake.namespaceShowReturnsOnCall = make(map[int]struct {
			result1 models.Namespace
			result2 error
		})
	}
	fake.namespaceShowReturnsOnCall[i] = struct {
		result1 models.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) Namespaces() (models.NamespaceList, error) {
	fake.namespacesMutex.Lock()
	ret, specificReturn := fake.namespacesReturnsOnCall[len(fake.namespacesArgsForCall)]
	fake.namespacesArgsForCall = append(fake.namespacesArgsForCall, struct {
	}{})
	stub := fake.NamespacesStub
	fakeReturns := fake.namespacesReturns
	fake.recordInvocation("Namespaces", []interface{}{})
	fake.namespacesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespacesCallCount() int {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	return len(fake.namespacesArgsForCall)
}

func (fake *FakeAPIClient) NamespacesCalls(stub func() (models.NamespaceList, error)) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = stub
}

func (fake *FakeAPIClient) NamespacesReturns(result1 models.NamespaceList, result2 error) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	fake.namespacesReturns = struct {
		result1 models.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespacesReturnsOnCall(i int, result1 models.NamespaceList, result2 error) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	if fake.namespacesReturnsOnCall == nil {
		fake.namespacesReturnsOnCall = make(map[int]struct {
			result1 models.NamespaceList
			result2 error
		})
	}
	fake.namespacesReturnsOnCall[i] = struct {
		result1 models.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespacesMatch(arg1 string) (models.NamespacesMatchResponse, error) {
	fake.namespacesMatchMutex.Lock()
	ret, specificReturn := fake.namespacesMatchReturnsOnCall[len(fake.namespacesMatchArgsForCall)]
	fake.namespacesMatchArgsForCall = append(fake.namespacesMatchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NamespacesMatchStub
	fakeReturns := fake.namespacesMatchReturns
	fake.recordInvocation("NamespacesMatch", []interface{}{arg1})
	fake.namespacesMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) NamespacesMatchCallCount() int {
	fake.namespacesMatchMutex.RLock()
	defer fake.namespacesMatchMutex.RUnlock()
	return len(fake.namespacesMatchArgsForCall)
}

func (fake *FakeAPIClient) NamespacesMatchCalls(stub func(string) (models.NamespacesMatchResponse, error)) {
	fake.namespacesMatchMutex.Lock()
	defer fake.namespacesMatchMutex.Unlock()
	fake.NamespacesMatchStub = stub
}

func (fake *FakeAPIClient) NamespacesMatchArgsForCall(i int) string {
	fake.namespacesMatchMutex.RLock()
	defer fake.namespacesMatchMutex.RUnlock()
	argsForCall := fake.namespacesMatchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) NamespacesMatchReturns(result1 models.NamespacesMatchResponse, result2 error) {
	fake.namespacesMatchMutex.Lock()
	defer fake.namespacesMatchMutex.Unlock()
	fake.NamespacesMatchStub = nil
	fake.namespacesMatchReturns = struct {
		result1 models.NamespacesMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) NamespacesMatchReturnsOnCall(i int, result1 models.NamespacesMatchResponse, result2 error) {
	fake.namespacesMatchMutex.Lock()
	defer fake.namespacesMatchMutex.Unlock()
	fake.NamespacesMatchStub = nil
	if fake.namespacesMatchReturnsOnCall == nil {
		fake.namespacesMatchReturnsOnCall = make(map[int]struct {
			result1 models.NamespacesMatchResponse
			result2 error
		})
	}
	fake.namespacesMatchReturnsOnCall[i] = struct {
		result1 models.NamespacesMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceBind(arg1 *models.ServiceBindRequest, arg2 string, arg3 string) error {
	fake.serviceBindMutex.Lock()
	ret, specificReturn := fake.serviceBindReturnsOnCall[len(fake.serviceBindArgsForCall)]
	fake.serviceBindArgsForCall = append(fake.serviceBindArgsForCall, struct {
		arg1 *models.ServiceBindRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ServiceBindStub
	fakeReturns := fake.serviceBindReturns
	fake.recordInvocation("ServiceBind", []interface{}{arg1, arg2, arg3})
	fake.serviceBindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) ServiceBindCallCount() int {
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	return len(fake.serviceBindArgsForCall)
}

func (fake *FakeAPIClient) ServiceBindCalls(stub func(*models.ServiceBindRequest, string, string) error) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = stub
}

func (fake *FakeAPIClient) ServiceBindArgsForCall(i int) (*models.ServiceBindRequest, string, string) {
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	argsForCall := fake.serviceBindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ServiceBindReturns(result1 error) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = nil
	fake.serviceBindReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) ServiceBindReturnsOnCall(i int, result1 error) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = nil
	if fake.serviceBindReturnsOnCall == nil {
		fake.serviceBindReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceBindReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) ServiceCatalog() (models.CatalogServices, error) {
	fake.serviceCatalogMutex.Lock()
	ret, specificReturn := fake.serviceCatalogReturnsOnCall[len(fake.serviceCatalogArgsForCall)]
	fake.serviceCatalogArgsForCall = append(fake.serviceCatalogArgsForCall, struct {
	}{})
	stub := fake.ServiceCatalogStub
	fakeReturns := fake.serviceCatalogReturns
	fake.recordInvocation("ServiceCatalog", []interface{}{})
	fake.serviceCatalogMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceCatalogCallCount() int {
	fake.serviceCatalogMutex.RLock()
	defer fake.serviceCatalogMutex.RUnlock()
	return len(fake.serviceCatalogArgsForCall)
}

func (fake *FakeAPIClient) ServiceCatalogCalls(stub func() (models.CatalogServices, error)) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = stub
}

func (fake *FakeAPIClient) ServiceCatalogReturns(result1 models.CatalogServices, result2 error) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = nil
	fake.serviceCatalogReturns = struct {
		result1 models.CatalogServices
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogReturnsOnCall(i int, result1 models.CatalogServices, result2 error) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = nil
	if fake.serviceCatalogReturnsOnCall == nil {
		fake.serviceCatalogReturnsOnCall = make(map[int]struct {
			result1 models.CatalogServices
			result2 error
		})
	}
	fake.serviceCatalogReturnsOnCall[i] = struct {
		result1 models.CatalogServices
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogMatch(arg1 string) (models.CatalogMatchResponse, error) {
	fake.serviceCatalogMatchMutex.Lock()
	ret, specificReturn := fake.serviceCatalogMatchReturnsOnCall[len(fake.serviceCatalogMatchArgsForCall)]
	fake.serviceCatalogMatchArgsForCall = append(fake.serviceCatalogMatchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceCatalogMatchStub
	fakeReturns := fake.serviceCatalogMatchReturns
	fake.recordInvocation("ServiceCatalogMatch", []interface{}{arg1})
	fake.serviceCatalogMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceCatalogMatchCallCount() int {
	fake.serviceCatalogMatchMutex.RLock()
	defer fake.serviceCatalogMatchMutex.RUnlock()
	return len(fake.serviceCatalogMatchArgsForCall)
}

func (fake *FakeAPIClient) ServiceCatalogMatchCalls(stub func(string) (models.CatalogMatchResponse, error)) {
	fake.serviceCatalogMatchMutex.Lock()
	defer fake.serviceCatalogMatchMutex.Unlock()
	fake.ServiceCatalogMatchStub = stub
}

func (fake *FakeAPIClient) ServiceCatalogMatchArgsForCall(i int) string {
	fake.serviceCatalogMatchMutex.RLock()
	defer fake.serviceCatalogMatchMutex.RUnlock()
	argsForCall := fake.serviceCatalogMatchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ServiceCatalogMatchReturns(result1 models.CatalogMatchResponse, result2 error) {
	fake.serviceCatalogMatchMutex.Lock()
	defer fake.serviceCatalogMatchMutex.Unlock()
	fake.ServiceCatalogMatchStub = nil
	fake.serviceCatalogMatchReturns = struct {
		result1 models.CatalogMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogMatchReturnsOnCall(i int, result1 models.CatalogMatchResponse, result2 error) {
	fake.serviceCatalogMatchMutex.Lock()
	defer fake.serviceCatalogMatchMutex.Unlock()
	fake.ServiceCatalogMatchStub = nil
	if fake.serviceCatalogMatchReturnsOnCall == nil {
		fake.serviceCatalogMatchReturnsOnCall = make(map[int]struct {
			result1 models.CatalogMatchResponse
			result2 error
		})
	}
	fake.serviceCatalogMatchReturnsOnCall[i] = struct {
		result1 models.CatalogMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogShow(arg1 string) (*models.CatalogService, error) {
	fake.serviceCatalogShowMutex.Lock()
	ret, specificReturn := fake.serviceCatalogShowReturnsOnCall[len(fake.serviceCatalogShowArgsForCall)]
	fake.serviceCatalogShowArgsForCall = append(fake.serviceCatalogShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceCatalogShowStub
	fakeReturns := fake.serviceCatalogShowReturns
	fake.recordInvocation("ServiceCatalogShow", []interface{}{arg1})
	fake.serviceCatalogShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceCatalogShowCallCount() int {
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	return len(fake.serviceCatalogShowArgsForCall)
}

func (fake *FakeAPIClient) ServiceCatalogShowCalls(stub func(string) (*models.CatalogService, error)) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = stub
}

func (fake *FakeAPIClient) ServiceCatalogShowArgsForCall(i int) string {
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	argsForCall := fake.serviceCatalogShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ServiceCatalogShowReturns(result1 *models.CatalogService, result2 error) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = nil
	fake.serviceCatalogShowReturns = struct {
		result1 *models.CatalogService
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCatalogShowReturnsOnCall(i int, result1 *models.CatalogService, result2 error) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = nil
	if fake.serviceCatalogShowReturnsOnCall == nil {
		fake.serviceCatalogShowReturnsOnCall = make(map[int]struct {
			result1 *models.CatalogService
			result2 error
		})
	}
	fake.serviceCatalogShowReturnsOnCall[i] = struct {
		result1 *models.CatalogService
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceCreate(arg1 *models.ServiceCreateRequest, arg2 string) error {
	fake.serviceCreateMutex.Lock()
	ret, specificReturn := fake.serviceCreateReturnsOnCall[len(fake.serviceCreateArgsForCall)]
	fake.serviceCreateArgsForCall = append(fake.serviceCreateArgsForCall, struct {
		arg1 *models.ServiceCreateRequest
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceCreateStub
	fakeReturns := fake.serviceCreateReturns
	fake.recordInvocation("ServiceCreate", []interface{}{arg1, arg2})
	fake.serviceCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) ServiceCreateCallCount() int {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	return len(fake.serviceCreateArgsForCall)
}

func (fake *FakeAPIClient) ServiceCreateCalls(stub func(*models.ServiceCreateRequest, string) error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = stub
}

func (fake *FakeAPIClient) ServiceCreateArgsForCall(i int) (*models.ServiceCreateRequest, string) {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	argsForCall := fake.serviceCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ServiceCreateReturns(result1 error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = nil
	fake.serviceCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) ServiceCreateReturnsOnCall(i int, result1 error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = nil
	if fake.serviceCreateReturnsOnCall == nil {
		fake.serviceCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) ServiceDelete(arg1 models.ServiceDeleteRequest, arg2 string, arg3 []string, arg4 func(response *http.Response, bodyBytes []byte, err error) error) (models.ServiceDeleteResponse, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.serviceDeleteMutex.Lock()
	ret, specificReturn := fake.serviceDeleteReturnsOnCall[len(fake.serviceDeleteArgsForCall)]
	fake.serviceDeleteArgsForCall = append(fake.serviceDeleteArgsForCall, struct {
		arg1 models.ServiceDeleteRequest
		arg2 string
		arg3 []string
		arg4 func(response *http.Response, bodyBytes []byte, err error) error
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.ServiceDeleteStub
	fakeReturns := fake.serviceDeleteReturns
	fake.recordInvocation("ServiceDelete", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.serviceDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceDeleteCallCount() int {
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	return len(fake.serviceDeleteArgsForCall)
}

func (fake *FakeAPIClient) ServiceDeleteCalls(stub func(models.ServiceDeleteRequest, string, []string, func(response *http.Response, bodyBytes []byte, err error) error) (models.ServiceDeleteResponse, error)) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = stub
}

func (fake *FakeAPIClient) ServiceDeleteArgsForCall(i int) (models.ServiceDeleteRequest, string, []string, func(response *http.Response, bodyBytes []byte, err error) error) {
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	argsForCall := fake.serviceDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAPIClient) ServiceDeleteReturns(result1 models.ServiceDeleteResponse, result2 error) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = nil
	fake.serviceDeleteReturns = struct {
		result1 models.ServiceDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceDeleteReturnsOnCall(i int, result1 models.ServiceDeleteResponse, result2 error) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = nil
	if fake.serviceDeleteReturnsOnCall == nil {
		fake.serviceDeleteReturnsOnCall = make(map[int]struct {
			result1 models.ServiceDeleteResponse
			result2 error
		})
	}
	fake.serviceDeleteReturnsOnCall[i] = struct {
		result1 models.ServiceDeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceList(arg1 string) (models.ServiceList, error) {
	fake.serviceListMutex.Lock()
	ret, specificReturn := fake.serviceListReturnsOnCall[len(fake.serviceListArgsForCall)]
	fake.serviceListArgsForCall = append(fake.serviceListArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceListStub
	fakeReturns := fake.serviceListReturns
	fake.recordInvocation("ServiceList", []interface{}{arg1})
	fake.serviceListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceListCallCount() int {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	return len(fake.serviceListArgsForCall)
}

func (fake *FakeAPIClient) ServiceListCalls(stub func(string) (models.ServiceList, error)) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = stub
}

func (fake *FakeAPIClient) ServiceListArgsForCall(i int) string {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	argsForCall := fake.serviceListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIClient) ServiceListReturns(result1 models.ServiceList, result2 error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = nil
	fake.serviceListReturns = struct {
		result1 models.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceListReturnsOnCall(i int, result1 models.ServiceList, result2 error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = nil
	if fake.serviceListReturnsOnCall == nil {
		fake.serviceListReturnsOnCall = make(map[int]struct {
			result1 models.ServiceList
			result2 error
		})
	}
	fake.serviceListReturnsOnCall[i] = struct {
		result1 models.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceMatch(arg1 string, arg2 string) (models.ServiceMatchResponse, error) {
	fake.serviceMatchMutex.Lock()
	ret, specificReturn := fake.serviceMatchReturnsOnCall[len(fake.serviceMatchArgsForCall)]
	fake.serviceMatchArgsForCall = append(fake.serviceMatchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceMatchStub
	fakeReturns := fake.serviceMatchReturns
	fake.recordInvocation("ServiceMatch", []interface{}{arg1, arg2})
	fake.serviceMatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceMatchCallCount() int {
	fake.serviceMatchMutex.RLock()
	defer fake.serviceMatchMutex.RUnlock()
	return len(fake.serviceMatchArgsForCall)
}

func (fake *FakeAPIClient) ServiceMatchCalls(stub func(string, string) (models.ServiceMatchResponse, error)) {
	fake.serviceMatchMutex.Lock()
	defer fake.serviceMatchMutex.Unlock()
	fake.ServiceMatchStub = stub
}

func (fake *FakeAPIClient) ServiceMatchArgsForCall(i int) (string, string) {
	fake.serviceMatchMutex.RLock()
	defer fake.serviceMatchMutex.RUnlock()
	argsForCall := fake.serviceMatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ServiceMatchReturns(result1 models.ServiceMatchResponse, result2 error) {
	fake.serviceMatchMutex.Lock()
	defer fake.serviceMatchMutex.Unlock()
	fake.ServiceMatchStub = nil
	fake.serviceMatchReturns = struct {
		result1 models.ServiceMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceMatchReturnsOnCall(i int, result1 models.ServiceMatchResponse, result2 error) {
	fake.serviceMatchMutex.Lock()
	defer fake.serviceMatchMutex.Unlock()
	fake.ServiceMatchStub = nil
	if fake.serviceMatchReturnsOnCall == nil {
		fake.serviceMatchReturnsOnCall = make(map[int]struct {
			result1 models.ServiceMatchResponse
			result2 error
		})
	}
	fake.serviceMatchReturnsOnCall[i] = struct {
		result1 models.ServiceMatchResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceShow(arg1 *models.ServiceShowRequest, arg2 string) (*models.Service, error) {
	fake.serviceShowMutex.Lock()
	ret, specificReturn := fake.serviceShowReturnsOnCall[len(fake.serviceShowArgsForCall)]
	fake.serviceShowArgsForCall = append(fake.serviceShowArgsForCall, struct {
		arg1 *models.ServiceShowRequest
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceShowStub
	fakeReturns := fake.serviceShowReturns
	fake.recordInvocation("ServiceShow", []interface{}{arg1, arg2})
	fake.serviceShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) ServiceShowCallCount() int {
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	return len(fake.serviceShowArgsForCall)
}

func (fake *FakeAPIClient) ServiceShowCalls(stub func(*models.ServiceShowRequest, string) (*models.Service, error)) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = stub
}

func (fake *FakeAPIClient) ServiceShowArgsForCall(i int) (*models.ServiceShowRequest, string) {
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	argsForCall := fake.serviceShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) ServiceShowReturns(result1 *models.Service, result2 error) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = nil
	fake.serviceShowReturns = struct {
		result1 *models.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceShowReturnsOnCall(i int, result1 *models.Service, result2 error) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = nil
	if fake.serviceShowReturnsOnCall == nil {
		fake.serviceShowReturnsOnCall = make(map[int]struct {
			result1 *models.Service
			result2 error
		})
	}
	fake.serviceShowReturnsOnCall[i] = struct {
		result1 *models.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) ServiceUnbind(arg1 *models.ServiceUnbindRequest, arg2 string, arg3 string) error {
	fake.serviceUnbindMutex.Lock()
	ret, specificReturn := fake.serviceUnbindReturnsOnCall[len(fake.serviceUnbindArgsForCall)]
	fake.serviceUnbindArgsForCall = append(fake.serviceUnbindArgsForCall, struct {
		arg1 *models.ServiceUnbindRequest
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ServiceUnbindStub
	fakeReturns := fake.serviceUnbindReturns
	fake.recordInvocation("ServiceUnbind", []interface{}{arg1, arg2, arg3})
	fake.serviceUnbindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) ServiceUnbindCallCount() int {
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	return len(fake.serviceUnbindArgsForCall)
}

func (fake *FakeAPIClient) ServiceUnbindCalls(stub func(*models.ServiceUnbindRequest, string, string) error) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = stub
}

func (fake *FakeAPIClient) ServiceUnbindArgsForCall(i int) (*models.ServiceUnbindRequest, string, string) {
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	argsForCall := fake.serviceUnbindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIClient) ServiceUnbindReturns(result1 error) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = nil
	fake.serviceUnbindReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) ServiceUnbindReturnsOnCall(i int, result1 error) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = nil
	if fake.serviceUnbindReturnsOnCall == nil {
		fake.serviceUnbindReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceUnbindReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAPIClient) StagingComplete(arg1 string, arg2 string) (models.Response, error) {
	fake.stagingCompleteMutex.Lock()
	ret, specificReturn := fake.stagingCompleteReturnsOnCall[len(fake.stagingCompleteArgsForCall)]
	fake.stagingCompleteArgsForCall = append(fake.stagingCompleteArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.StagingCompleteStub
	fakeReturns := fake.stagingCompleteReturns
	fake.recordInvocation("StagingComplete", []interface{}{arg1, arg2})
	fake.stagingCompleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAPIClient) StagingCompleteCallCount() int {
	fake.stagingCompleteMutex.RLock()
	defer fake.stagingCompleteMutex.RUnlock()
	return len(fake.stagingCompleteArgsForCall)
}

func (fake *FakeAPIClient) StagingCompleteCalls(stub func(string, string) (models.Response, error)) {
	fake.stagingCompleteMutex.Lock()
	defer fake.stagingCompleteMutex.Unlock()
	fake.StagingCompleteStub = stub
}

func (fake *FakeAPIClient) StagingCompleteArgsForCall(i int) (string, string) {
	fake.stagingCompleteMutex.RLock()
	defer fake.stagingCompleteMutex.RUnlock()
	argsForCall := fake.stagingCompleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIClient) StagingCompleteReturns(result1 models.Response, result2 error) {
	fake.stagingCompleteMutex.Lock()
	defer fake.stagingCompleteMutex.Unlock()
	fake.StagingCompleteStub = nil
	fake.stagingCompleteReturns = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) StagingCompleteReturnsOnCall(i int, result1 models.Response, result2 error) {
	fake.stagingCompleteMutex.Lock()
	defer fake.stagingCompleteMutex.Unlock()
	fake.StagingCompleteStub = nil
	if fake.stagingCompleteReturnsOnCall == nil {
		fake.stagingCompleteReturnsOnCall = make(map[int]struct {
			result1 models.Response
			result2 error
		})
	}
	fake.stagingCompleteReturnsOnCall[i] = struct {
		result1 models.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeAPIClient) VersionWarningEnabled() bool {
	fake.versionWarningEnabledMutex.Lock()
	ret, specificReturn := fake.versionWarningEnabledReturnsOnCall[len(fake.versionWarningEnabledArgsForCall)]
	fake.versionWarningEnabledArgsForCall = append(fake.versionWarningEnabledArgsForCall, struct {
	}{})
	stub := fake.VersionWarningEnabledStub
	fakeReturns := fake.versionWarningEnabledReturns
	fake.recordInvocation("VersionWarningEnabled", []interface{}{})
	fake.versionWarningEnabledMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIClient) VersionWarningEnabledCallCount() int {
	fake.versionWarningEnabledMutex.RLock()
	defer fake.versionWarningEnabledMutex.RUnlock()
	return len(fake.versionWarningEnabledArgsForCall)
}

func (fake *FakeAPIClient) VersionWarningEnabledCalls(stub func() bool) {
	fake.versionWarningEnabledMutex.Lock()
	defer fake.versionWarningEnabledMutex.Unlock()
	fake.VersionWarningEnabledStub = stub
}

func (fake *FakeAPIClient) VersionWarningEnabledReturns(result1 bool) {
	fake.versionWarningEnabledMutex.Lock()
	defer fake.versionWarningEnabledMutex.Unlock()
	fake.VersionWarningEnabledStub = nil
	fake.versionWarningEnabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAPIClient) VersionWarningEnabledReturnsOnCall(i int, result1 bool) {
	fake.versionWarningEnabledMutex.Lock()
	defer fake.versionWarningEnabledMutex.Unlock()
	fake.VersionWarningEnabledStub = nil
	if fake.versionWarningEnabledReturnsOnCall == nil {
		fake.versionWarningEnabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.versionWarningEnabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAPIClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allAppsMutex.RLock()
	defer fake.allAppsMutex.RUnlock()
	fake.allConfigurationsMutex.RLock()
	defer fake.allConfigurationsMutex.RUnlock()
	fake.allServicesMutex.RLock()
	defer fake.allServicesMutex.RUnlock()
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	fake.appDeployMutex.RLock()
	defer fake.appDeployMutex.RUnlock()
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	fake.appGetPartMutex.RLock()
	defer fake.appGetPartMutex.RUnlock()
	fake.appImportGitMutex.RLock()
	defer fake.appImportGitMutex.RUnlock()
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	fake.appMatchMutex.RLock()
	defer fake.appMatchMutex.RUnlock()
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	fake.appRunningMutex.RLock()
	defer fake.appRunningMutex.RUnlock()
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	fake.appStageMutex.RLock()
	defer fake.appStageMutex.RUnlock()
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	fake.appUploadMutex.RLock()
	defer fake.appUploadMutex.RUnlock()
	fake.appValidateCVMutex.RLock()
	defer fake.appValidateCVMutex.RUnlock()
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	fake.authTokenMutex.RLock()
	defer fake.authTokenMutex.RUnlock()
	fake.chartListMutex.RLock()
	defer fake.chartListMutex.RUnlock()
	fake.chartMatchMutex.RLock()
	defer fake.chartMatchMutex.RUnlock()
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	fake.configurationAppsMutex.RLock()
	defer fake.configurationAppsMutex.RUnlock()
	fake.configurationBindingCreateMutex.RLock()
	defer fake.configurationBindingCreateMutex.RUnlock()
	fake.configurationBindingDeleteMutex.RLock()
	defer fake.configurationBindingDeleteMutex.RUnlock()
	fake.configurationCreateMutex.RLock()
	defer fake.configurationCreateMutex.RUnlock()
	fake.configurationDeleteMutex.RLock()
	defer fake.configurationDeleteMutex.RUnlock()
	fake.configurationMatchMutex.RLock()
	defer fake.configurationMatchMutex.RUnlock()
	fake.configurationShowMutex.RLock()
	defer fake.configurationShowMutex.RUnlock()
	fake.configurationUpdateMutex.RLock()
	defer fake.configurationUpdateMutex.RUnlock()
	fake.configurationsMutex.RLock()
	defer fake.configurationsMutex.RUnlock()
	fake.disableVersionWarningMutex.RLock()
	defer fake.disableVersionWarningMutex.RUnlock()
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	fake.envMatchMutex.RLock()
	defer fake.envMatchMutex.RUnlock()
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.namespaceCreateMutex.RLock()
	defer fake.namespaceCreateMutex.RUnlock()
	fake.namespaceDeleteMutex.RLock()
	defer fake.namespaceDeleteMutex.RUnlock()
	fake.namespaceShowMutex.RLock()
	defer fake.namespaceShowMutex.RUnlock()
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	fake.namespacesMatchMutex.RLock()
	defer fake.namespacesMatchMutex.RUnlock()
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	fake.serviceCatalogMutex.RLock()
	defer fake.serviceCatalogMutex.RUnlock()
	fake.serviceCatalogMatchMutex.RLock()
	defer fake.serviceCatalogMatchMutex.RUnlock()
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	fake.serviceMatchMutex.RLock()
	defer fake.serviceMatchMutex.RUnlock()
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	fake.stagingCompleteMutex.RLock()
	defer fake.stagingCompleteMutex.RUnlock()
	fake.versionWarningEnabledMutex.RLock()
	defer fake.versionWarningEnabledMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAPIClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ usercmd.APIClient = new(FakeAPIClient)
