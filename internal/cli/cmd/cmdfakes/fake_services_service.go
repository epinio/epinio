// Copyright Â© 2021 - 2023 SUSE LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by counterfeiter. DO NOT EDIT.
package cmdfakes

import (
	"context"
	"sync"

	"github.com/epinio/epinio/internal/cli/cmd"
	"github.com/epinio/epinio/internal/cli/usercmd"
	"github.com/epinio/epinio/pkg/api/core/v1/models"
)

type FakeServicesService struct {
	AppsMatchingStub        func(string) []string
	appsMatchingMutex       sync.RWMutex
	appsMatchingArgsForCall []struct {
		arg1 string
	}
	appsMatchingReturns struct {
		result1 []string
	}
	appsMatchingReturnsOnCall map[int]struct {
		result1 []string
	}
	CatalogMatchingStub        func(string) []string
	catalogMatchingMutex       sync.RWMutex
	catalogMatchingArgsForCall []struct {
		arg1 string
	}
	catalogMatchingReturns struct {
		result1 []string
	}
	catalogMatchingReturnsOnCall map[int]struct {
		result1 []string
	}
	GetAPIStub        func() usercmd.APIClient
	getAPIMutex       sync.RWMutex
	getAPIArgsForCall []struct {
	}
	getAPIReturns struct {
		result1 usercmd.APIClient
	}
	getAPIReturnsOnCall map[int]struct {
		result1 usercmd.APIClient
	}
	ServiceBindStub        func(string, string) error
	serviceBindMutex       sync.RWMutex
	serviceBindArgsForCall []struct {
		arg1 string
		arg2 string
	}
	serviceBindReturns struct {
		result1 error
	}
	serviceBindReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceCatalogStub        func() error
	serviceCatalogMutex       sync.RWMutex
	serviceCatalogArgsForCall []struct {
	}
	serviceCatalogReturns struct {
		result1 error
	}
	serviceCatalogReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceCatalogShowStub        func(context.Context, string) error
	serviceCatalogShowMutex       sync.RWMutex
	serviceCatalogShowArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	serviceCatalogShowReturns struct {
		result1 error
	}
	serviceCatalogShowReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceCreateStub        func(string, string, bool, models.ChartValueSettings) error
	serviceCreateMutex       sync.RWMutex
	serviceCreateArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 models.ChartValueSettings
	}
	serviceCreateReturns struct {
		result1 error
	}
	serviceCreateReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceDeleteStub        func([]string, bool, bool) error
	serviceDeleteMutex       sync.RWMutex
	serviceDeleteArgsForCall []struct {
		arg1 []string
		arg2 bool
		arg3 bool
	}
	serviceDeleteReturns struct {
		result1 error
	}
	serviceDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceListStub        func() error
	serviceListMutex       sync.RWMutex
	serviceListArgsForCall []struct {
	}
	serviceListReturns struct {
		result1 error
	}
	serviceListReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceListAllStub        func() error
	serviceListAllMutex       sync.RWMutex
	serviceListAllArgsForCall []struct {
	}
	serviceListAllReturns struct {
		result1 error
	}
	serviceListAllReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceMatchingStub        func(string) []string
	serviceMatchingMutex       sync.RWMutex
	serviceMatchingArgsForCall []struct {
		arg1 string
	}
	serviceMatchingReturns struct {
		result1 []string
	}
	serviceMatchingReturnsOnCall map[int]struct {
		result1 []string
	}
	ServicePortForwardStub        func(context.Context, string, []string, []string) error
	servicePortForwardMutex       sync.RWMutex
	servicePortForwardArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []string
	}
	servicePortForwardReturns struct {
		result1 error
	}
	servicePortForwardReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceShowStub        func(string) error
	serviceShowMutex       sync.RWMutex
	serviceShowArgsForCall []struct {
		arg1 string
	}
	serviceShowReturns struct {
		result1 error
	}
	serviceShowReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceUnbindStub        func(string, string) error
	serviceUnbindMutex       sync.RWMutex
	serviceUnbindArgsForCall []struct {
		arg1 string
		arg2 string
	}
	serviceUnbindReturns struct {
		result1 error
	}
	serviceUnbindReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceUpdateStub        func(string, bool, []string, map[string]string) error
	serviceUpdateMutex       sync.RWMutex
	serviceUpdateArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 []string
		arg4 map[string]string
	}
	serviceUpdateReturns struct {
		result1 error
	}
	serviceUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeServicesService) AppsMatching(arg1 string) []string {
	fake.appsMatchingMutex.Lock()
	ret, specificReturn := fake.appsMatchingReturnsOnCall[len(fake.appsMatchingArgsForCall)]
	fake.appsMatchingArgsForCall = append(fake.appsMatchingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AppsMatchingStub
	fakeReturns := fake.appsMatchingReturns
	fake.recordInvocation("AppsMatching", []interface{}{arg1})
	fake.appsMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) AppsMatchingCallCount() int {
	fake.appsMatchingMutex.RLock()
	defer fake.appsMatchingMutex.RUnlock()
	return len(fake.appsMatchingArgsForCall)
}

func (fake *FakeServicesService) AppsMatchingCalls(stub func(string) []string) {
	fake.appsMatchingMutex.Lock()
	defer fake.appsMatchingMutex.Unlock()
	fake.AppsMatchingStub = stub
}

func (fake *FakeServicesService) AppsMatchingArgsForCall(i int) string {
	fake.appsMatchingMutex.RLock()
	defer fake.appsMatchingMutex.RUnlock()
	argsForCall := fake.appsMatchingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServicesService) AppsMatchingReturns(result1 []string) {
	fake.appsMatchingMutex.Lock()
	defer fake.appsMatchingMutex.Unlock()
	fake.AppsMatchingStub = nil
	fake.appsMatchingReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeServicesService) AppsMatchingReturnsOnCall(i int, result1 []string) {
	fake.appsMatchingMutex.Lock()
	defer fake.appsMatchingMutex.Unlock()
	fake.AppsMatchingStub = nil
	if fake.appsMatchingReturnsOnCall == nil {
		fake.appsMatchingReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.appsMatchingReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeServicesService) CatalogMatching(arg1 string) []string {
	fake.catalogMatchingMutex.Lock()
	ret, specificReturn := fake.catalogMatchingReturnsOnCall[len(fake.catalogMatchingArgsForCall)]
	fake.catalogMatchingArgsForCall = append(fake.catalogMatchingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CatalogMatchingStub
	fakeReturns := fake.catalogMatchingReturns
	fake.recordInvocation("CatalogMatching", []interface{}{arg1})
	fake.catalogMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) CatalogMatchingCallCount() int {
	fake.catalogMatchingMutex.RLock()
	defer fake.catalogMatchingMutex.RUnlock()
	return len(fake.catalogMatchingArgsForCall)
}

func (fake *FakeServicesService) CatalogMatchingCalls(stub func(string) []string) {
	fake.catalogMatchingMutex.Lock()
	defer fake.catalogMatchingMutex.Unlock()
	fake.CatalogMatchingStub = stub
}

func (fake *FakeServicesService) CatalogMatchingArgsForCall(i int) string {
	fake.catalogMatchingMutex.RLock()
	defer fake.catalogMatchingMutex.RUnlock()
	argsForCall := fake.catalogMatchingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServicesService) CatalogMatchingReturns(result1 []string) {
	fake.catalogMatchingMutex.Lock()
	defer fake.catalogMatchingMutex.Unlock()
	fake.CatalogMatchingStub = nil
	fake.catalogMatchingReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeServicesService) CatalogMatchingReturnsOnCall(i int, result1 []string) {
	fake.catalogMatchingMutex.Lock()
	defer fake.catalogMatchingMutex.Unlock()
	fake.CatalogMatchingStub = nil
	if fake.catalogMatchingReturnsOnCall == nil {
		fake.catalogMatchingReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.catalogMatchingReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeServicesService) GetAPI() usercmd.APIClient {
	fake.getAPIMutex.Lock()
	ret, specificReturn := fake.getAPIReturnsOnCall[len(fake.getAPIArgsForCall)]
	fake.getAPIArgsForCall = append(fake.getAPIArgsForCall, struct {
	}{})
	stub := fake.GetAPIStub
	fakeReturns := fake.getAPIReturns
	fake.recordInvocation("GetAPI", []interface{}{})
	fake.getAPIMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) GetAPICallCount() int {
	fake.getAPIMutex.RLock()
	defer fake.getAPIMutex.RUnlock()
	return len(fake.getAPIArgsForCall)
}

func (fake *FakeServicesService) GetAPICalls(stub func() usercmd.APIClient) {
	fake.getAPIMutex.Lock()
	defer fake.getAPIMutex.Unlock()
	fake.GetAPIStub = stub
}

func (fake *FakeServicesService) GetAPIReturns(result1 usercmd.APIClient) {
	fake.getAPIMutex.Lock()
	defer fake.getAPIMutex.Unlock()
	fake.GetAPIStub = nil
	fake.getAPIReturns = struct {
		result1 usercmd.APIClient
	}{result1}
}

func (fake *FakeServicesService) GetAPIReturnsOnCall(i int, result1 usercmd.APIClient) {
	fake.getAPIMutex.Lock()
	defer fake.getAPIMutex.Unlock()
	fake.GetAPIStub = nil
	if fake.getAPIReturnsOnCall == nil {
		fake.getAPIReturnsOnCall = make(map[int]struct {
			result1 usercmd.APIClient
		})
	}
	fake.getAPIReturnsOnCall[i] = struct {
		result1 usercmd.APIClient
	}{result1}
}

func (fake *FakeServicesService) ServiceBind(arg1 string, arg2 string) error {
	fake.serviceBindMutex.Lock()
	ret, specificReturn := fake.serviceBindReturnsOnCall[len(fake.serviceBindArgsForCall)]
	fake.serviceBindArgsForCall = append(fake.serviceBindArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceBindStub
	fakeReturns := fake.serviceBindReturns
	fake.recordInvocation("ServiceBind", []interface{}{arg1, arg2})
	fake.serviceBindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceBindCallCount() int {
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	return len(fake.serviceBindArgsForCall)
}

func (fake *FakeServicesService) ServiceBindCalls(stub func(string, string) error) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = stub
}

func (fake *FakeServicesService) ServiceBindArgsForCall(i int) (string, string) {
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	argsForCall := fake.serviceBindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServicesService) ServiceBindReturns(result1 error) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = nil
	fake.serviceBindReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceBindReturnsOnCall(i int, result1 error) {
	fake.serviceBindMutex.Lock()
	defer fake.serviceBindMutex.Unlock()
	fake.ServiceBindStub = nil
	if fake.serviceBindReturnsOnCall == nil {
		fake.serviceBindReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceBindReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceCatalog() error {
	fake.serviceCatalogMutex.Lock()
	ret, specificReturn := fake.serviceCatalogReturnsOnCall[len(fake.serviceCatalogArgsForCall)]
	fake.serviceCatalogArgsForCall = append(fake.serviceCatalogArgsForCall, struct {
	}{})
	stub := fake.ServiceCatalogStub
	fakeReturns := fake.serviceCatalogReturns
	fake.recordInvocation("ServiceCatalog", []interface{}{})
	fake.serviceCatalogMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceCatalogCallCount() int {
	fake.serviceCatalogMutex.RLock()
	defer fake.serviceCatalogMutex.RUnlock()
	return len(fake.serviceCatalogArgsForCall)
}

func (fake *FakeServicesService) ServiceCatalogCalls(stub func() error) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = stub
}

func (fake *FakeServicesService) ServiceCatalogReturns(result1 error) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = nil
	fake.serviceCatalogReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceCatalogReturnsOnCall(i int, result1 error) {
	fake.serviceCatalogMutex.Lock()
	defer fake.serviceCatalogMutex.Unlock()
	fake.ServiceCatalogStub = nil
	if fake.serviceCatalogReturnsOnCall == nil {
		fake.serviceCatalogReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceCatalogReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceCatalogShow(arg1 context.Context, arg2 string) error {
	fake.serviceCatalogShowMutex.Lock()
	ret, specificReturn := fake.serviceCatalogShowReturnsOnCall[len(fake.serviceCatalogShowArgsForCall)]
	fake.serviceCatalogShowArgsForCall = append(fake.serviceCatalogShowArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceCatalogShowStub
	fakeReturns := fake.serviceCatalogShowReturns
	fake.recordInvocation("ServiceCatalogShow", []interface{}{arg1, arg2})
	fake.serviceCatalogShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceCatalogShowCallCount() int {
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	return len(fake.serviceCatalogShowArgsForCall)
}

func (fake *FakeServicesService) ServiceCatalogShowCalls(stub func(context.Context, string) error) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = stub
}

func (fake *FakeServicesService) ServiceCatalogShowArgsForCall(i int) (context.Context, string) {
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	argsForCall := fake.serviceCatalogShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServicesService) ServiceCatalogShowReturns(result1 error) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = nil
	fake.serviceCatalogShowReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceCatalogShowReturnsOnCall(i int, result1 error) {
	fake.serviceCatalogShowMutex.Lock()
	defer fake.serviceCatalogShowMutex.Unlock()
	fake.ServiceCatalogShowStub = nil
	if fake.serviceCatalogShowReturnsOnCall == nil {
		fake.serviceCatalogShowReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceCatalogShowReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceCreate(arg1 string, arg2 string, arg3 bool, arg4 models.ChartValueSettings) error {
	fake.serviceCreateMutex.Lock()
	ret, specificReturn := fake.serviceCreateReturnsOnCall[len(fake.serviceCreateArgsForCall)]
	fake.serviceCreateArgsForCall = append(fake.serviceCreateArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 models.ChartValueSettings
	}{arg1, arg2, arg3, arg4})
	stub := fake.ServiceCreateStub
	fakeReturns := fake.serviceCreateReturns
	fake.recordInvocation("ServiceCreate", []interface{}{arg1, arg2, arg3, arg4})
	fake.serviceCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceCreateCallCount() int {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	return len(fake.serviceCreateArgsForCall)
}

func (fake *FakeServicesService) ServiceCreateCalls(stub func(string, string, bool, models.ChartValueSettings) error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = stub
}

func (fake *FakeServicesService) ServiceCreateArgsForCall(i int) (string, string, bool, models.ChartValueSettings) {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	argsForCall := fake.serviceCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeServicesService) ServiceCreateReturns(result1 error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = nil
	fake.serviceCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceCreateReturnsOnCall(i int, result1 error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = nil
	if fake.serviceCreateReturnsOnCall == nil {
		fake.serviceCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceDelete(arg1 []string, arg2 bool, arg3 bool) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.serviceDeleteMutex.Lock()
	ret, specificReturn := fake.serviceDeleteReturnsOnCall[len(fake.serviceDeleteArgsForCall)]
	fake.serviceDeleteArgsForCall = append(fake.serviceDeleteArgsForCall, struct {
		arg1 []string
		arg2 bool
		arg3 bool
	}{arg1Copy, arg2, arg3})
	stub := fake.ServiceDeleteStub
	fakeReturns := fake.serviceDeleteReturns
	fake.recordInvocation("ServiceDelete", []interface{}{arg1Copy, arg2, arg3})
	fake.serviceDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceDeleteCallCount() int {
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	return len(fake.serviceDeleteArgsForCall)
}

func (fake *FakeServicesService) ServiceDeleteCalls(stub func([]string, bool, bool) error) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = stub
}

func (fake *FakeServicesService) ServiceDeleteArgsForCall(i int) ([]string, bool, bool) {
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	argsForCall := fake.serviceDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeServicesService) ServiceDeleteReturns(result1 error) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = nil
	fake.serviceDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceDeleteReturnsOnCall(i int, result1 error) {
	fake.serviceDeleteMutex.Lock()
	defer fake.serviceDeleteMutex.Unlock()
	fake.ServiceDeleteStub = nil
	if fake.serviceDeleteReturnsOnCall == nil {
		fake.serviceDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceList() error {
	fake.serviceListMutex.Lock()
	ret, specificReturn := fake.serviceListReturnsOnCall[len(fake.serviceListArgsForCall)]
	fake.serviceListArgsForCall = append(fake.serviceListArgsForCall, struct {
	}{})
	stub := fake.ServiceListStub
	fakeReturns := fake.serviceListReturns
	fake.recordInvocation("ServiceList", []interface{}{})
	fake.serviceListMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceListCallCount() int {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	return len(fake.serviceListArgsForCall)
}

func (fake *FakeServicesService) ServiceListCalls(stub func() error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = stub
}

func (fake *FakeServicesService) ServiceListReturns(result1 error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = nil
	fake.serviceListReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceListReturnsOnCall(i int, result1 error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = nil
	if fake.serviceListReturnsOnCall == nil {
		fake.serviceListReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceListReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceListAll() error {
	fake.serviceListAllMutex.Lock()
	ret, specificReturn := fake.serviceListAllReturnsOnCall[len(fake.serviceListAllArgsForCall)]
	fake.serviceListAllArgsForCall = append(fake.serviceListAllArgsForCall, struct {
	}{})
	stub := fake.ServiceListAllStub
	fakeReturns := fake.serviceListAllReturns
	fake.recordInvocation("ServiceListAll", []interface{}{})
	fake.serviceListAllMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceListAllCallCount() int {
	fake.serviceListAllMutex.RLock()
	defer fake.serviceListAllMutex.RUnlock()
	return len(fake.serviceListAllArgsForCall)
}

func (fake *FakeServicesService) ServiceListAllCalls(stub func() error) {
	fake.serviceListAllMutex.Lock()
	defer fake.serviceListAllMutex.Unlock()
	fake.ServiceListAllStub = stub
}

func (fake *FakeServicesService) ServiceListAllReturns(result1 error) {
	fake.serviceListAllMutex.Lock()
	defer fake.serviceListAllMutex.Unlock()
	fake.ServiceListAllStub = nil
	fake.serviceListAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceListAllReturnsOnCall(i int, result1 error) {
	fake.serviceListAllMutex.Lock()
	defer fake.serviceListAllMutex.Unlock()
	fake.ServiceListAllStub = nil
	if fake.serviceListAllReturnsOnCall == nil {
		fake.serviceListAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceListAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceMatching(arg1 string) []string {
	fake.serviceMatchingMutex.Lock()
	ret, specificReturn := fake.serviceMatchingReturnsOnCall[len(fake.serviceMatchingArgsForCall)]
	fake.serviceMatchingArgsForCall = append(fake.serviceMatchingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceMatchingStub
	fakeReturns := fake.serviceMatchingReturns
	fake.recordInvocation("ServiceMatching", []interface{}{arg1})
	fake.serviceMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceMatchingCallCount() int {
	fake.serviceMatchingMutex.RLock()
	defer fake.serviceMatchingMutex.RUnlock()
	return len(fake.serviceMatchingArgsForCall)
}

func (fake *FakeServicesService) ServiceMatchingCalls(stub func(string) []string) {
	fake.serviceMatchingMutex.Lock()
	defer fake.serviceMatchingMutex.Unlock()
	fake.ServiceMatchingStub = stub
}

func (fake *FakeServicesService) ServiceMatchingArgsForCall(i int) string {
	fake.serviceMatchingMutex.RLock()
	defer fake.serviceMatchingMutex.RUnlock()
	argsForCall := fake.serviceMatchingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServicesService) ServiceMatchingReturns(result1 []string) {
	fake.serviceMatchingMutex.Lock()
	defer fake.serviceMatchingMutex.Unlock()
	fake.ServiceMatchingStub = nil
	fake.serviceMatchingReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeServicesService) ServiceMatchingReturnsOnCall(i int, result1 []string) {
	fake.serviceMatchingMutex.Lock()
	defer fake.serviceMatchingMutex.Unlock()
	fake.ServiceMatchingStub = nil
	if fake.serviceMatchingReturnsOnCall == nil {
		fake.serviceMatchingReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.serviceMatchingReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeServicesService) ServicePortForward(arg1 context.Context, arg2 string, arg3 []string, arg4 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.servicePortForwardMutex.Lock()
	ret, specificReturn := fake.servicePortForwardReturnsOnCall[len(fake.servicePortForwardArgsForCall)]
	fake.servicePortForwardArgsForCall = append(fake.servicePortForwardArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []string
	}{arg1, arg2, arg3Copy, arg4Copy})
	stub := fake.ServicePortForwardStub
	fakeReturns := fake.servicePortForwardReturns
	fake.recordInvocation("ServicePortForward", []interface{}{arg1, arg2, arg3Copy, arg4Copy})
	fake.servicePortForwardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServicePortForwardCallCount() int {
	fake.servicePortForwardMutex.RLock()
	defer fake.servicePortForwardMutex.RUnlock()
	return len(fake.servicePortForwardArgsForCall)
}

func (fake *FakeServicesService) ServicePortForwardCalls(stub func(context.Context, string, []string, []string) error) {
	fake.servicePortForwardMutex.Lock()
	defer fake.servicePortForwardMutex.Unlock()
	fake.ServicePortForwardStub = stub
}

func (fake *FakeServicesService) ServicePortForwardArgsForCall(i int) (context.Context, string, []string, []string) {
	fake.servicePortForwardMutex.RLock()
	defer fake.servicePortForwardMutex.RUnlock()
	argsForCall := fake.servicePortForwardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeServicesService) ServicePortForwardReturns(result1 error) {
	fake.servicePortForwardMutex.Lock()
	defer fake.servicePortForwardMutex.Unlock()
	fake.ServicePortForwardStub = nil
	fake.servicePortForwardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServicePortForwardReturnsOnCall(i int, result1 error) {
	fake.servicePortForwardMutex.Lock()
	defer fake.servicePortForwardMutex.Unlock()
	fake.ServicePortForwardStub = nil
	if fake.servicePortForwardReturnsOnCall == nil {
		fake.servicePortForwardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.servicePortForwardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceShow(arg1 string) error {
	fake.serviceShowMutex.Lock()
	ret, specificReturn := fake.serviceShowReturnsOnCall[len(fake.serviceShowArgsForCall)]
	fake.serviceShowArgsForCall = append(fake.serviceShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceShowStub
	fakeReturns := fake.serviceShowReturns
	fake.recordInvocation("ServiceShow", []interface{}{arg1})
	fake.serviceShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceShowCallCount() int {
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	return len(fake.serviceShowArgsForCall)
}

func (fake *FakeServicesService) ServiceShowCalls(stub func(string) error) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = stub
}

func (fake *FakeServicesService) ServiceShowArgsForCall(i int) string {
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	argsForCall := fake.serviceShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServicesService) ServiceShowReturns(result1 error) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = nil
	fake.serviceShowReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceShowReturnsOnCall(i int, result1 error) {
	fake.serviceShowMutex.Lock()
	defer fake.serviceShowMutex.Unlock()
	fake.ServiceShowStub = nil
	if fake.serviceShowReturnsOnCall == nil {
		fake.serviceShowReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceShowReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceUnbind(arg1 string, arg2 string) error {
	fake.serviceUnbindMutex.Lock()
	ret, specificReturn := fake.serviceUnbindReturnsOnCall[len(fake.serviceUnbindArgsForCall)]
	fake.serviceUnbindArgsForCall = append(fake.serviceUnbindArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ServiceUnbindStub
	fakeReturns := fake.serviceUnbindReturns
	fake.recordInvocation("ServiceUnbind", []interface{}{arg1, arg2})
	fake.serviceUnbindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceUnbindCallCount() int {
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	return len(fake.serviceUnbindArgsForCall)
}

func (fake *FakeServicesService) ServiceUnbindCalls(stub func(string, string) error) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = stub
}

func (fake *FakeServicesService) ServiceUnbindArgsForCall(i int) (string, string) {
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	argsForCall := fake.serviceUnbindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServicesService) ServiceUnbindReturns(result1 error) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = nil
	fake.serviceUnbindReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceUnbindReturnsOnCall(i int, result1 error) {
	fake.serviceUnbindMutex.Lock()
	defer fake.serviceUnbindMutex.Unlock()
	fake.ServiceUnbindStub = nil
	if fake.serviceUnbindReturnsOnCall == nil {
		fake.serviceUnbindReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceUnbindReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceUpdate(arg1 string, arg2 bool, arg3 []string, arg4 map[string]string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.serviceUpdateMutex.Lock()
	ret, specificReturn := fake.serviceUpdateReturnsOnCall[len(fake.serviceUpdateArgsForCall)]
	fake.serviceUpdateArgsForCall = append(fake.serviceUpdateArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 []string
		arg4 map[string]string
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.ServiceUpdateStub
	fakeReturns := fake.serviceUpdateReturns
	fake.recordInvocation("ServiceUpdate", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.serviceUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServicesService) ServiceUpdateCallCount() int {
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	return len(fake.serviceUpdateArgsForCall)
}

func (fake *FakeServicesService) ServiceUpdateCalls(stub func(string, bool, []string, map[string]string) error) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = stub
}

func (fake *FakeServicesService) ServiceUpdateArgsForCall(i int) (string, bool, []string, map[string]string) {
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	argsForCall := fake.serviceUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeServicesService) ServiceUpdateReturns(result1 error) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = nil
	fake.serviceUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) ServiceUpdateReturnsOnCall(i int, result1 error) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = nil
	if fake.serviceUpdateReturnsOnCall == nil {
		fake.serviceUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServicesService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appsMatchingMutex.RLock()
	defer fake.appsMatchingMutex.RUnlock()
	fake.catalogMatchingMutex.RLock()
	defer fake.catalogMatchingMutex.RUnlock()
	fake.getAPIMutex.RLock()
	defer fake.getAPIMutex.RUnlock()
	fake.serviceBindMutex.RLock()
	defer fake.serviceBindMutex.RUnlock()
	fake.serviceCatalogMutex.RLock()
	defer fake.serviceCatalogMutex.RUnlock()
	fake.serviceCatalogShowMutex.RLock()
	defer fake.serviceCatalogShowMutex.RUnlock()
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	fake.serviceDeleteMutex.RLock()
	defer fake.serviceDeleteMutex.RUnlock()
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	fake.serviceListAllMutex.RLock()
	defer fake.serviceListAllMutex.RUnlock()
	fake.serviceMatchingMutex.RLock()
	defer fake.serviceMatchingMutex.RUnlock()
	fake.servicePortForwardMutex.RLock()
	defer fake.servicePortForwardMutex.RUnlock()
	fake.serviceShowMutex.RLock()
	defer fake.serviceShowMutex.RUnlock()
	fake.serviceUnbindMutex.RLock()
	defer fake.serviceUnbindMutex.RUnlock()
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeServicesService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cmd.ServicesService = new(FakeServicesService)
