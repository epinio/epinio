// Copyright Â© 2021 - 2023 SUSE LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by counterfeiter. DO NOT EDIT.
package cmdfakes

import (
	"context"
	"sync"

	"github.com/epinio/epinio/internal/cli/cmd"
	"github.com/epinio/epinio/internal/cli/usercmd"
	"github.com/epinio/epinio/pkg/api/core/v1/models"
)

type FakeApplicationsService struct {
	AppCreateStub        func(string, models.ApplicationUpdateRequest) error
	appCreateMutex       sync.RWMutex
	appCreateArgsForCall []struct {
		arg1 string
		arg2 models.ApplicationUpdateRequest
	}
	appCreateReturns struct {
		result1 error
	}
	appCreateReturnsOnCall map[int]struct {
		result1 error
	}
	AppDeleteStub        func(context.Context, []string, bool) error
	appDeleteMutex       sync.RWMutex
	appDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 []string
		arg3 bool
	}
	appDeleteReturns struct {
		result1 error
	}
	appDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	AppExecStub        func(context.Context, string, string) error
	appExecMutex       sync.RWMutex
	appExecArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	appExecReturns struct {
		result1 error
	}
	appExecReturnsOnCall map[int]struct {
		result1 error
	}
	AppExportStub        func(string, bool, models.AppExportRequest) error
	appExportMutex       sync.RWMutex
	appExportArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 models.AppExportRequest
	}
	appExportReturns struct {
		result1 error
	}
	appExportReturnsOnCall map[int]struct {
		result1 error
	}
	AppLogsStub        func(string, string, bool) error
	appLogsMutex       sync.RWMutex
	appLogsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	appLogsReturns struct {
		result1 error
	}
	appLogsReturnsOnCall map[int]struct {
		result1 error
	}
	AppManifestStub        func(string, string) error
	appManifestMutex       sync.RWMutex
	appManifestArgsForCall []struct {
		arg1 string
		arg2 string
	}
	appManifestReturns struct {
		result1 error
	}
	appManifestReturnsOnCall map[int]struct {
		result1 error
	}
	AppPortForwardStub        func(context.Context, string, string, []string, []string) error
	appPortForwardMutex       sync.RWMutex
	appPortForwardArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
		arg5 []string
	}
	appPortForwardReturns struct {
		result1 error
	}
	appPortForwardReturnsOnCall map[int]struct {
		result1 error
	}
	AppPushStub        func(context.Context, models.ApplicationManifest) error
	appPushMutex       sync.RWMutex
	appPushArgsForCall []struct {
		arg1 context.Context
		arg2 models.ApplicationManifest
	}
	appPushReturns struct {
		result1 error
	}
	appPushReturnsOnCall map[int]struct {
		result1 error
	}
	AppRestageStub        func(string, bool) error
	appRestageMutex       sync.RWMutex
	appRestageArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	appRestageReturns struct {
		result1 error
	}
	appRestageReturnsOnCall map[int]struct {
		result1 error
	}
	AppRestartStub        func(string) error
	appRestartMutex       sync.RWMutex
	appRestartArgsForCall []struct {
		arg1 string
	}
	appRestartReturns struct {
		result1 error
	}
	appRestartReturnsOnCall map[int]struct {
		result1 error
	}
	AppShowStub        func(string) error
	appShowMutex       sync.RWMutex
	appShowArgsForCall []struct {
		arg1 string
	}
	appShowReturns struct {
		result1 error
	}
	appShowReturnsOnCall map[int]struct {
		result1 error
	}
	AppStageIDStub        func(string) (string, error)
	appStageIDMutex       sync.RWMutex
	appStageIDArgsForCall []struct {
		arg1 string
	}
	appStageIDReturns struct {
		result1 string
		result2 error
	}
	appStageIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	AppUpdateStub        func(string, models.ApplicationUpdateRequest) error
	appUpdateMutex       sync.RWMutex
	appUpdateArgsForCall []struct {
		arg1 string
		arg2 models.ApplicationUpdateRequest
	}
	appUpdateReturns struct {
		result1 error
	}
	appUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	AppsStub        func(bool) error
	appsMutex       sync.RWMutex
	appsArgsForCall []struct {
		arg1 bool
	}
	appsReturns struct {
		result1 error
	}
	appsReturnsOnCall map[int]struct {
		result1 error
	}
	AppsMatchingStub        func(string) []string
	appsMatchingMutex       sync.RWMutex
	appsMatchingArgsForCall []struct {
		arg1 string
	}
	appsMatchingReturns struct {
		result1 []string
	}
	appsMatchingReturnsOnCall map[int]struct {
		result1 []string
	}
	ChartDefaultSetStub        func(context.Context, string) error
	chartDefaultSetMutex       sync.RWMutex
	chartDefaultSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	chartDefaultSetReturns struct {
		result1 error
	}
	chartDefaultSetReturnsOnCall map[int]struct {
		result1 error
	}
	ChartDefaultShowStub        func(context.Context) error
	chartDefaultShowMutex       sync.RWMutex
	chartDefaultShowArgsForCall []struct {
		arg1 context.Context
	}
	chartDefaultShowReturns struct {
		result1 error
	}
	chartDefaultShowReturnsOnCall map[int]struct {
		result1 error
	}
	ChartListStub        func(context.Context) error
	chartListMutex       sync.RWMutex
	chartListArgsForCall []struct {
		arg1 context.Context
	}
	chartListReturns struct {
		result1 error
	}
	chartListReturnsOnCall map[int]struct {
		result1 error
	}
	ChartMatchingStub        func(string) []string
	chartMatchingMutex       sync.RWMutex
	chartMatchingArgsForCall []struct {
		arg1 string
	}
	chartMatchingReturns struct {
		result1 []string
	}
	chartMatchingReturnsOnCall map[int]struct {
		result1 []string
	}
	ChartShowStub        func(context.Context, string) error
	chartShowMutex       sync.RWMutex
	chartShowArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	chartShowReturns struct {
		result1 error
	}
	chartShowReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigurationMatchingStub        func(string) []string
	configurationMatchingMutex       sync.RWMutex
	configurationMatchingArgsForCall []struct {
		arg1 string
	}
	configurationMatchingReturns struct {
		result1 []string
	}
	configurationMatchingReturnsOnCall map[int]struct {
		result1 []string
	}
	EnvListStub        func(context.Context, string) error
	envListMutex       sync.RWMutex
	envListArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	envListReturns struct {
		result1 error
	}
	envListReturnsOnCall map[int]struct {
		result1 error
	}
	EnvMatchingStub        func(context.Context, string, string) []string
	envMatchingMutex       sync.RWMutex
	envMatchingArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	envMatchingReturns struct {
		result1 []string
	}
	envMatchingReturnsOnCall map[int]struct {
		result1 []string
	}
	EnvSetStub        func(context.Context, string, string, string) error
	envSetMutex       sync.RWMutex
	envSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	envSetReturns struct {
		result1 error
	}
	envSetReturnsOnCall map[int]struct {
		result1 error
	}
	EnvShowStub        func(context.Context, string, string) error
	envShowMutex       sync.RWMutex
	envShowArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	envShowReturns struct {
		result1 error
	}
	envShowReturnsOnCall map[int]struct {
		result1 error
	}
	EnvUnsetStub        func(context.Context, string, string) error
	envUnsetMutex       sync.RWMutex
	envUnsetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	envUnsetReturns struct {
		result1 error
	}
	envUnsetReturnsOnCall map[int]struct {
		result1 error
	}
	ExportregistryMatchingStub        func(string) []string
	exportregistryMatchingMutex       sync.RWMutex
	exportregistryMatchingArgsForCall []struct {
		arg1 string
	}
	exportregistryMatchingReturns struct {
		result1 []string
	}
	exportregistryMatchingReturnsOnCall map[int]struct {
		result1 []string
	}
	GetAPIStub        func() usercmd.APIClient
	getAPIMutex       sync.RWMutex
	getAPIArgsForCall []struct {
	}
	getAPIReturns struct {
		result1 usercmd.APIClient
	}
	getAPIReturnsOnCall map[int]struct {
		result1 usercmd.APIClient
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeApplicationsService) AppCreate(arg1 string, arg2 models.ApplicationUpdateRequest) error {
	fake.appCreateMutex.Lock()
	ret, specificReturn := fake.appCreateReturnsOnCall[len(fake.appCreateArgsForCall)]
	fake.appCreateArgsForCall = append(fake.appCreateArgsForCall, struct {
		arg1 string
		arg2 models.ApplicationUpdateRequest
	}{arg1, arg2})
	stub := fake.AppCreateStub
	fakeReturns := fake.appCreateReturns
	fake.recordInvocation("AppCreate", []interface{}{arg1, arg2})
	fake.appCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppCreateCallCount() int {
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	return len(fake.appCreateArgsForCall)
}

func (fake *FakeApplicationsService) AppCreateCalls(stub func(string, models.ApplicationUpdateRequest) error) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = stub
}

func (fake *FakeApplicationsService) AppCreateArgsForCall(i int) (string, models.ApplicationUpdateRequest) {
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	argsForCall := fake.appCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationsService) AppCreateReturns(result1 error) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = nil
	fake.appCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppCreateReturnsOnCall(i int, result1 error) {
	fake.appCreateMutex.Lock()
	defer fake.appCreateMutex.Unlock()
	fake.AppCreateStub = nil
	if fake.appCreateReturnsOnCall == nil {
		fake.appCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppDelete(arg1 context.Context, arg2 []string, arg3 bool) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.appDeleteMutex.Lock()
	ret, specificReturn := fake.appDeleteReturnsOnCall[len(fake.appDeleteArgsForCall)]
	fake.appDeleteArgsForCall = append(fake.appDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 []string
		arg3 bool
	}{arg1, arg2Copy, arg3})
	stub := fake.AppDeleteStub
	fakeReturns := fake.appDeleteReturns
	fake.recordInvocation("AppDelete", []interface{}{arg1, arg2Copy, arg3})
	fake.appDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppDeleteCallCount() int {
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	return len(fake.appDeleteArgsForCall)
}

func (fake *FakeApplicationsService) AppDeleteCalls(stub func(context.Context, []string, bool) error) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = stub
}

func (fake *FakeApplicationsService) AppDeleteArgsForCall(i int) (context.Context, []string, bool) {
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	argsForCall := fake.appDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeApplicationsService) AppDeleteReturns(result1 error) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = nil
	fake.appDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppDeleteReturnsOnCall(i int, result1 error) {
	fake.appDeleteMutex.Lock()
	defer fake.appDeleteMutex.Unlock()
	fake.AppDeleteStub = nil
	if fake.appDeleteReturnsOnCall == nil {
		fake.appDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppExec(arg1 context.Context, arg2 string, arg3 string) error {
	fake.appExecMutex.Lock()
	ret, specificReturn := fake.appExecReturnsOnCall[len(fake.appExecArgsForCall)]
	fake.appExecArgsForCall = append(fake.appExecArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AppExecStub
	fakeReturns := fake.appExecReturns
	fake.recordInvocation("AppExec", []interface{}{arg1, arg2, arg3})
	fake.appExecMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppExecCallCount() int {
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	return len(fake.appExecArgsForCall)
}

func (fake *FakeApplicationsService) AppExecCalls(stub func(context.Context, string, string) error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = stub
}

func (fake *FakeApplicationsService) AppExecArgsForCall(i int) (context.Context, string, string) {
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	argsForCall := fake.appExecArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeApplicationsService) AppExecReturns(result1 error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = nil
	fake.appExecReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppExecReturnsOnCall(i int, result1 error) {
	fake.appExecMutex.Lock()
	defer fake.appExecMutex.Unlock()
	fake.AppExecStub = nil
	if fake.appExecReturnsOnCall == nil {
		fake.appExecReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appExecReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppExport(arg1 string, arg2 bool, arg3 models.AppExportRequest) error {
	fake.appExportMutex.Lock()
	ret, specificReturn := fake.appExportReturnsOnCall[len(fake.appExportArgsForCall)]
	fake.appExportArgsForCall = append(fake.appExportArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 models.AppExportRequest
	}{arg1, arg2, arg3})
	stub := fake.AppExportStub
	fakeReturns := fake.appExportReturns
	fake.recordInvocation("AppExport", []interface{}{arg1, arg2, arg3})
	fake.appExportMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppExportCallCount() int {
	fake.appExportMutex.RLock()
	defer fake.appExportMutex.RUnlock()
	return len(fake.appExportArgsForCall)
}

func (fake *FakeApplicationsService) AppExportCalls(stub func(string, bool, models.AppExportRequest) error) {
	fake.appExportMutex.Lock()
	defer fake.appExportMutex.Unlock()
	fake.AppExportStub = stub
}

func (fake *FakeApplicationsService) AppExportArgsForCall(i int) (string, bool, models.AppExportRequest) {
	fake.appExportMutex.RLock()
	defer fake.appExportMutex.RUnlock()
	argsForCall := fake.appExportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeApplicationsService) AppExportReturns(result1 error) {
	fake.appExportMutex.Lock()
	defer fake.appExportMutex.Unlock()
	fake.AppExportStub = nil
	fake.appExportReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppExportReturnsOnCall(i int, result1 error) {
	fake.appExportMutex.Lock()
	defer fake.appExportMutex.Unlock()
	fake.AppExportStub = nil
	if fake.appExportReturnsOnCall == nil {
		fake.appExportReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appExportReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppLogs(arg1 string, arg2 string, arg3 bool) error {
	fake.appLogsMutex.Lock()
	ret, specificReturn := fake.appLogsReturnsOnCall[len(fake.appLogsArgsForCall)]
	fake.appLogsArgsForCall = append(fake.appLogsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.AppLogsStub
	fakeReturns := fake.appLogsReturns
	fake.recordInvocation("AppLogs", []interface{}{arg1, arg2, arg3})
	fake.appLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppLogsCallCount() int {
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	return len(fake.appLogsArgsForCall)
}

func (fake *FakeApplicationsService) AppLogsCalls(stub func(string, string, bool) error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = stub
}

func (fake *FakeApplicationsService) AppLogsArgsForCall(i int) (string, string, bool) {
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	argsForCall := fake.appLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeApplicationsService) AppLogsReturns(result1 error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = nil
	fake.appLogsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppLogsReturnsOnCall(i int, result1 error) {
	fake.appLogsMutex.Lock()
	defer fake.appLogsMutex.Unlock()
	fake.AppLogsStub = nil
	if fake.appLogsReturnsOnCall == nil {
		fake.appLogsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appLogsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppManifest(arg1 string, arg2 string) error {
	fake.appManifestMutex.Lock()
	ret, specificReturn := fake.appManifestReturnsOnCall[len(fake.appManifestArgsForCall)]
	fake.appManifestArgsForCall = append(fake.appManifestArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AppManifestStub
	fakeReturns := fake.appManifestReturns
	fake.recordInvocation("AppManifest", []interface{}{arg1, arg2})
	fake.appManifestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppManifestCallCount() int {
	fake.appManifestMutex.RLock()
	defer fake.appManifestMutex.RUnlock()
	return len(fake.appManifestArgsForCall)
}

func (fake *FakeApplicationsService) AppManifestCalls(stub func(string, string) error) {
	fake.appManifestMutex.Lock()
	defer fake.appManifestMutex.Unlock()
	fake.AppManifestStub = stub
}

func (fake *FakeApplicationsService) AppManifestArgsForCall(i int) (string, string) {
	fake.appManifestMutex.RLock()
	defer fake.appManifestMutex.RUnlock()
	argsForCall := fake.appManifestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationsService) AppManifestReturns(result1 error) {
	fake.appManifestMutex.Lock()
	defer fake.appManifestMutex.Unlock()
	fake.AppManifestStub = nil
	fake.appManifestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppManifestReturnsOnCall(i int, result1 error) {
	fake.appManifestMutex.Lock()
	defer fake.appManifestMutex.Unlock()
	fake.AppManifestStub = nil
	if fake.appManifestReturnsOnCall == nil {
		fake.appManifestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appManifestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppPortForward(arg1 context.Context, arg2 string, arg3 string, arg4 []string, arg5 []string) error {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.appPortForwardMutex.Lock()
	ret, specificReturn := fake.appPortForwardReturnsOnCall[len(fake.appPortForwardArgsForCall)]
	fake.appPortForwardArgsForCall = append(fake.appPortForwardArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
		arg5 []string
	}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	stub := fake.AppPortForwardStub
	fakeReturns := fake.appPortForwardReturns
	fake.recordInvocation("AppPortForward", []interface{}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	fake.appPortForwardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppPortForwardCallCount() int {
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	return len(fake.appPortForwardArgsForCall)
}

func (fake *FakeApplicationsService) AppPortForwardCalls(stub func(context.Context, string, string, []string, []string) error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = stub
}

func (fake *FakeApplicationsService) AppPortForwardArgsForCall(i int) (context.Context, string, string, []string, []string) {
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	argsForCall := fake.appPortForwardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeApplicationsService) AppPortForwardReturns(result1 error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = nil
	fake.appPortForwardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppPortForwardReturnsOnCall(i int, result1 error) {
	fake.appPortForwardMutex.Lock()
	defer fake.appPortForwardMutex.Unlock()
	fake.AppPortForwardStub = nil
	if fake.appPortForwardReturnsOnCall == nil {
		fake.appPortForwardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appPortForwardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppPush(arg1 context.Context, arg2 models.ApplicationManifest) error {
	fake.appPushMutex.Lock()
	ret, specificReturn := fake.appPushReturnsOnCall[len(fake.appPushArgsForCall)]
	fake.appPushArgsForCall = append(fake.appPushArgsForCall, struct {
		arg1 context.Context
		arg2 models.ApplicationManifest
	}{arg1, arg2})
	stub := fake.AppPushStub
	fakeReturns := fake.appPushReturns
	fake.recordInvocation("AppPush", []interface{}{arg1, arg2})
	fake.appPushMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppPushCallCount() int {
	fake.appPushMutex.RLock()
	defer fake.appPushMutex.RUnlock()
	return len(fake.appPushArgsForCall)
}

func (fake *FakeApplicationsService) AppPushCalls(stub func(context.Context, models.ApplicationManifest) error) {
	fake.appPushMutex.Lock()
	defer fake.appPushMutex.Unlock()
	fake.AppPushStub = stub
}

func (fake *FakeApplicationsService) AppPushArgsForCall(i int) (context.Context, models.ApplicationManifest) {
	fake.appPushMutex.RLock()
	defer fake.appPushMutex.RUnlock()
	argsForCall := fake.appPushArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationsService) AppPushReturns(result1 error) {
	fake.appPushMutex.Lock()
	defer fake.appPushMutex.Unlock()
	fake.AppPushStub = nil
	fake.appPushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppPushReturnsOnCall(i int, result1 error) {
	fake.appPushMutex.Lock()
	defer fake.appPushMutex.Unlock()
	fake.AppPushStub = nil
	if fake.appPushReturnsOnCall == nil {
		fake.appPushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appPushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppRestage(arg1 string, arg2 bool) error {
	fake.appRestageMutex.Lock()
	ret, specificReturn := fake.appRestageReturnsOnCall[len(fake.appRestageArgsForCall)]
	fake.appRestageArgsForCall = append(fake.appRestageArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.AppRestageStub
	fakeReturns := fake.appRestageReturns
	fake.recordInvocation("AppRestage", []interface{}{arg1, arg2})
	fake.appRestageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppRestageCallCount() int {
	fake.appRestageMutex.RLock()
	defer fake.appRestageMutex.RUnlock()
	return len(fake.appRestageArgsForCall)
}

func (fake *FakeApplicationsService) AppRestageCalls(stub func(string, bool) error) {
	fake.appRestageMutex.Lock()
	defer fake.appRestageMutex.Unlock()
	fake.AppRestageStub = stub
}

func (fake *FakeApplicationsService) AppRestageArgsForCall(i int) (string, bool) {
	fake.appRestageMutex.RLock()
	defer fake.appRestageMutex.RUnlock()
	argsForCall := fake.appRestageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationsService) AppRestageReturns(result1 error) {
	fake.appRestageMutex.Lock()
	defer fake.appRestageMutex.Unlock()
	fake.AppRestageStub = nil
	fake.appRestageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppRestageReturnsOnCall(i int, result1 error) {
	fake.appRestageMutex.Lock()
	defer fake.appRestageMutex.Unlock()
	fake.AppRestageStub = nil
	if fake.appRestageReturnsOnCall == nil {
		fake.appRestageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appRestageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppRestart(arg1 string) error {
	fake.appRestartMutex.Lock()
	ret, specificReturn := fake.appRestartReturnsOnCall[len(fake.appRestartArgsForCall)]
	fake.appRestartArgsForCall = append(fake.appRestartArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AppRestartStub
	fakeReturns := fake.appRestartReturns
	fake.recordInvocation("AppRestart", []interface{}{arg1})
	fake.appRestartMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppRestartCallCount() int {
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	return len(fake.appRestartArgsForCall)
}

func (fake *FakeApplicationsService) AppRestartCalls(stub func(string) error) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = stub
}

func (fake *FakeApplicationsService) AppRestartArgsForCall(i int) string {
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	argsForCall := fake.appRestartArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) AppRestartReturns(result1 error) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = nil
	fake.appRestartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppRestartReturnsOnCall(i int, result1 error) {
	fake.appRestartMutex.Lock()
	defer fake.appRestartMutex.Unlock()
	fake.AppRestartStub = nil
	if fake.appRestartReturnsOnCall == nil {
		fake.appRestartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appRestartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppShow(arg1 string) error {
	fake.appShowMutex.Lock()
	ret, specificReturn := fake.appShowReturnsOnCall[len(fake.appShowArgsForCall)]
	fake.appShowArgsForCall = append(fake.appShowArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AppShowStub
	fakeReturns := fake.appShowReturns
	fake.recordInvocation("AppShow", []interface{}{arg1})
	fake.appShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppShowCallCount() int {
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	return len(fake.appShowArgsForCall)
}

func (fake *FakeApplicationsService) AppShowCalls(stub func(string) error) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = stub
}

func (fake *FakeApplicationsService) AppShowArgsForCall(i int) string {
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	argsForCall := fake.appShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) AppShowReturns(result1 error) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = nil
	fake.appShowReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppShowReturnsOnCall(i int, result1 error) {
	fake.appShowMutex.Lock()
	defer fake.appShowMutex.Unlock()
	fake.AppShowStub = nil
	if fake.appShowReturnsOnCall == nil {
		fake.appShowReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appShowReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppStageID(arg1 string) (string, error) {
	fake.appStageIDMutex.Lock()
	ret, specificReturn := fake.appStageIDReturnsOnCall[len(fake.appStageIDArgsForCall)]
	fake.appStageIDArgsForCall = append(fake.appStageIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AppStageIDStub
	fakeReturns := fake.appStageIDReturns
	fake.recordInvocation("AppStageID", []interface{}{arg1})
	fake.appStageIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeApplicationsService) AppStageIDCallCount() int {
	fake.appStageIDMutex.RLock()
	defer fake.appStageIDMutex.RUnlock()
	return len(fake.appStageIDArgsForCall)
}

func (fake *FakeApplicationsService) AppStageIDCalls(stub func(string) (string, error)) {
	fake.appStageIDMutex.Lock()
	defer fake.appStageIDMutex.Unlock()
	fake.AppStageIDStub = stub
}

func (fake *FakeApplicationsService) AppStageIDArgsForCall(i int) string {
	fake.appStageIDMutex.RLock()
	defer fake.appStageIDMutex.RUnlock()
	argsForCall := fake.appStageIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) AppStageIDReturns(result1 string, result2 error) {
	fake.appStageIDMutex.Lock()
	defer fake.appStageIDMutex.Unlock()
	fake.AppStageIDStub = nil
	fake.appStageIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeApplicationsService) AppStageIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.appStageIDMutex.Lock()
	defer fake.appStageIDMutex.Unlock()
	fake.AppStageIDStub = nil
	if fake.appStageIDReturnsOnCall == nil {
		fake.appStageIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.appStageIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeApplicationsService) AppUpdate(arg1 string, arg2 models.ApplicationUpdateRequest) error {
	fake.appUpdateMutex.Lock()
	ret, specificReturn := fake.appUpdateReturnsOnCall[len(fake.appUpdateArgsForCall)]
	fake.appUpdateArgsForCall = append(fake.appUpdateArgsForCall, struct {
		arg1 string
		arg2 models.ApplicationUpdateRequest
	}{arg1, arg2})
	stub := fake.AppUpdateStub
	fakeReturns := fake.appUpdateReturns
	fake.recordInvocation("AppUpdate", []interface{}{arg1, arg2})
	fake.appUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppUpdateCallCount() int {
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	return len(fake.appUpdateArgsForCall)
}

func (fake *FakeApplicationsService) AppUpdateCalls(stub func(string, models.ApplicationUpdateRequest) error) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = stub
}

func (fake *FakeApplicationsService) AppUpdateArgsForCall(i int) (string, models.ApplicationUpdateRequest) {
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	argsForCall := fake.appUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationsService) AppUpdateReturns(result1 error) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = nil
	fake.appUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppUpdateReturnsOnCall(i int, result1 error) {
	fake.appUpdateMutex.Lock()
	defer fake.appUpdateMutex.Unlock()
	fake.AppUpdateStub = nil
	if fake.appUpdateReturnsOnCall == nil {
		fake.appUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) Apps(arg1 bool) error {
	fake.appsMutex.Lock()
	ret, specificReturn := fake.appsReturnsOnCall[len(fake.appsArgsForCall)]
	fake.appsArgsForCall = append(fake.appsArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.AppsStub
	fakeReturns := fake.appsReturns
	fake.recordInvocation("Apps", []interface{}{arg1})
	fake.appsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppsCallCount() int {
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	return len(fake.appsArgsForCall)
}

func (fake *FakeApplicationsService) AppsCalls(stub func(bool) error) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = stub
}

func (fake *FakeApplicationsService) AppsArgsForCall(i int) bool {
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	argsForCall := fake.appsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) AppsReturns(result1 error) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = nil
	fake.appsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppsReturnsOnCall(i int, result1 error) {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.AppsStub = nil
	if fake.appsReturnsOnCall == nil {
		fake.appsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) AppsMatching(arg1 string) []string {
	fake.appsMatchingMutex.Lock()
	ret, specificReturn := fake.appsMatchingReturnsOnCall[len(fake.appsMatchingArgsForCall)]
	fake.appsMatchingArgsForCall = append(fake.appsMatchingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AppsMatchingStub
	fakeReturns := fake.appsMatchingReturns
	fake.recordInvocation("AppsMatching", []interface{}{arg1})
	fake.appsMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) AppsMatchingCallCount() int {
	fake.appsMatchingMutex.RLock()
	defer fake.appsMatchingMutex.RUnlock()
	return len(fake.appsMatchingArgsForCall)
}

func (fake *FakeApplicationsService) AppsMatchingCalls(stub func(string) []string) {
	fake.appsMatchingMutex.Lock()
	defer fake.appsMatchingMutex.Unlock()
	fake.AppsMatchingStub = stub
}

func (fake *FakeApplicationsService) AppsMatchingArgsForCall(i int) string {
	fake.appsMatchingMutex.RLock()
	defer fake.appsMatchingMutex.RUnlock()
	argsForCall := fake.appsMatchingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) AppsMatchingReturns(result1 []string) {
	fake.appsMatchingMutex.Lock()
	defer fake.appsMatchingMutex.Unlock()
	fake.AppsMatchingStub = nil
	fake.appsMatchingReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) AppsMatchingReturnsOnCall(i int, result1 []string) {
	fake.appsMatchingMutex.Lock()
	defer fake.appsMatchingMutex.Unlock()
	fake.AppsMatchingStub = nil
	if fake.appsMatchingReturnsOnCall == nil {
		fake.appsMatchingReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.appsMatchingReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) ChartDefaultSet(arg1 context.Context, arg2 string) error {
	fake.chartDefaultSetMutex.Lock()
	ret, specificReturn := fake.chartDefaultSetReturnsOnCall[len(fake.chartDefaultSetArgsForCall)]
	fake.chartDefaultSetArgsForCall = append(fake.chartDefaultSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ChartDefaultSetStub
	fakeReturns := fake.chartDefaultSetReturns
	fake.recordInvocation("ChartDefaultSet", []interface{}{arg1, arg2})
	fake.chartDefaultSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) ChartDefaultSetCallCount() int {
	fake.chartDefaultSetMutex.RLock()
	defer fake.chartDefaultSetMutex.RUnlock()
	return len(fake.chartDefaultSetArgsForCall)
}

func (fake *FakeApplicationsService) ChartDefaultSetCalls(stub func(context.Context, string) error) {
	fake.chartDefaultSetMutex.Lock()
	defer fake.chartDefaultSetMutex.Unlock()
	fake.ChartDefaultSetStub = stub
}

func (fake *FakeApplicationsService) ChartDefaultSetArgsForCall(i int) (context.Context, string) {
	fake.chartDefaultSetMutex.RLock()
	defer fake.chartDefaultSetMutex.RUnlock()
	argsForCall := fake.chartDefaultSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationsService) ChartDefaultSetReturns(result1 error) {
	fake.chartDefaultSetMutex.Lock()
	defer fake.chartDefaultSetMutex.Unlock()
	fake.ChartDefaultSetStub = nil
	fake.chartDefaultSetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ChartDefaultSetReturnsOnCall(i int, result1 error) {
	fake.chartDefaultSetMutex.Lock()
	defer fake.chartDefaultSetMutex.Unlock()
	fake.ChartDefaultSetStub = nil
	if fake.chartDefaultSetReturnsOnCall == nil {
		fake.chartDefaultSetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chartDefaultSetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ChartDefaultShow(arg1 context.Context) error {
	fake.chartDefaultShowMutex.Lock()
	ret, specificReturn := fake.chartDefaultShowReturnsOnCall[len(fake.chartDefaultShowArgsForCall)]
	fake.chartDefaultShowArgsForCall = append(fake.chartDefaultShowArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ChartDefaultShowStub
	fakeReturns := fake.chartDefaultShowReturns
	fake.recordInvocation("ChartDefaultShow", []interface{}{arg1})
	fake.chartDefaultShowMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) ChartDefaultShowCallCount() int {
	fake.chartDefaultShowMutex.RLock()
	defer fake.chartDefaultShowMutex.RUnlock()
	return len(fake.chartDefaultShowArgsForCall)
}

func (fake *FakeApplicationsService) ChartDefaultShowCalls(stub func(context.Context) error) {
	fake.chartDefaultShowMutex.Lock()
	defer fake.chartDefaultShowMutex.Unlock()
	fake.ChartDefaultShowStub = stub
}

func (fake *FakeApplicationsService) ChartDefaultShowArgsForCall(i int) context.Context {
	fake.chartDefaultShowMutex.RLock()
	defer fake.chartDefaultShowMutex.RUnlock()
	argsForCall := fake.chartDefaultShowArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) ChartDefaultShowReturns(result1 error) {
	fake.chartDefaultShowMutex.Lock()
	defer fake.chartDefaultShowMutex.Unlock()
	fake.ChartDefaultShowStub = nil
	fake.chartDefaultShowReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ChartDefaultShowReturnsOnCall(i int, result1 error) {
	fake.chartDefaultShowMutex.Lock()
	defer fake.chartDefaultShowMutex.Unlock()
	fake.ChartDefaultShowStub = nil
	if fake.chartDefaultShowReturnsOnCall == nil {
		fake.chartDefaultShowReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chartDefaultShowReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ChartList(arg1 context.Context) error {
	fake.chartListMutex.Lock()
	ret, specificReturn := fake.chartListReturnsOnCall[len(fake.chartListArgsForCall)]
	fake.chartListArgsForCall = append(fake.chartListArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ChartListStub
	fakeReturns := fake.chartListReturns
	fake.recordInvocation("ChartList", []interface{}{arg1})
	fake.chartListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) ChartListCallCount() int {
	fake.chartListMutex.RLock()
	defer fake.chartListMutex.RUnlock()
	return len(fake.chartListArgsForCall)
}

func (fake *FakeApplicationsService) ChartListCalls(stub func(context.Context) error) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = stub
}

func (fake *FakeApplicationsService) ChartListArgsForCall(i int) context.Context {
	fake.chartListMutex.RLock()
	defer fake.chartListMutex.RUnlock()
	argsForCall := fake.chartListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) ChartListReturns(result1 error) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = nil
	fake.chartListReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ChartListReturnsOnCall(i int, result1 error) {
	fake.chartListMutex.Lock()
	defer fake.chartListMutex.Unlock()
	fake.ChartListStub = nil
	if fake.chartListReturnsOnCall == nil {
		fake.chartListReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chartListReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ChartMatching(arg1 string) []string {
	fake.chartMatchingMutex.Lock()
	ret, specificReturn := fake.chartMatchingReturnsOnCall[len(fake.chartMatchingArgsForCall)]
	fake.chartMatchingArgsForCall = append(fake.chartMatchingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ChartMatchingStub
	fakeReturns := fake.chartMatchingReturns
	fake.recordInvocation("ChartMatching", []interface{}{arg1})
	fake.chartMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) ChartMatchingCallCount() int {
	fake.chartMatchingMutex.RLock()
	defer fake.chartMatchingMutex.RUnlock()
	return len(fake.chartMatchingArgsForCall)
}

func (fake *FakeApplicationsService) ChartMatchingCalls(stub func(string) []string) {
	fake.chartMatchingMutex.Lock()
	defer fake.chartMatchingMutex.Unlock()
	fake.ChartMatchingStub = stub
}

func (fake *FakeApplicationsService) ChartMatchingArgsForCall(i int) string {
	fake.chartMatchingMutex.RLock()
	defer fake.chartMatchingMutex.RUnlock()
	argsForCall := fake.chartMatchingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) ChartMatchingReturns(result1 []string) {
	fake.chartMatchingMutex.Lock()
	defer fake.chartMatchingMutex.Unlock()
	fake.ChartMatchingStub = nil
	fake.chartMatchingReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) ChartMatchingReturnsOnCall(i int, result1 []string) {
	fake.chartMatchingMutex.Lock()
	defer fake.chartMatchingMutex.Unlock()
	fake.ChartMatchingStub = nil
	if fake.chartMatchingReturnsOnCall == nil {
		fake.chartMatchingReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.chartMatchingReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) ChartShow(arg1 context.Context, arg2 string) error {
	fake.chartShowMutex.Lock()
	ret, specificReturn := fake.chartShowReturnsOnCall[len(fake.chartShowArgsForCall)]
	fake.chartShowArgsForCall = append(fake.chartShowArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ChartShowStub
	fakeReturns := fake.chartShowReturns
	fake.recordInvocation("ChartShow", []interface{}{arg1, arg2})
	fake.chartShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) ChartShowCallCount() int {
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	return len(fake.chartShowArgsForCall)
}

func (fake *FakeApplicationsService) ChartShowCalls(stub func(context.Context, string) error) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = stub
}

func (fake *FakeApplicationsService) ChartShowArgsForCall(i int) (context.Context, string) {
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	argsForCall := fake.chartShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationsService) ChartShowReturns(result1 error) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = nil
	fake.chartShowReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ChartShowReturnsOnCall(i int, result1 error) {
	fake.chartShowMutex.Lock()
	defer fake.chartShowMutex.Unlock()
	fake.ChartShowStub = nil
	if fake.chartShowReturnsOnCall == nil {
		fake.chartShowReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chartShowReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ConfigurationMatching(arg1 string) []string {
	fake.configurationMatchingMutex.Lock()
	ret, specificReturn := fake.configurationMatchingReturnsOnCall[len(fake.configurationMatchingArgsForCall)]
	fake.configurationMatchingArgsForCall = append(fake.configurationMatchingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ConfigurationMatchingStub
	fakeReturns := fake.configurationMatchingReturns
	fake.recordInvocation("ConfigurationMatching", []interface{}{arg1})
	fake.configurationMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) ConfigurationMatchingCallCount() int {
	fake.configurationMatchingMutex.RLock()
	defer fake.configurationMatchingMutex.RUnlock()
	return len(fake.configurationMatchingArgsForCall)
}

func (fake *FakeApplicationsService) ConfigurationMatchingCalls(stub func(string) []string) {
	fake.configurationMatchingMutex.Lock()
	defer fake.configurationMatchingMutex.Unlock()
	fake.ConfigurationMatchingStub = stub
}

func (fake *FakeApplicationsService) ConfigurationMatchingArgsForCall(i int) string {
	fake.configurationMatchingMutex.RLock()
	defer fake.configurationMatchingMutex.RUnlock()
	argsForCall := fake.configurationMatchingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) ConfigurationMatchingReturns(result1 []string) {
	fake.configurationMatchingMutex.Lock()
	defer fake.configurationMatchingMutex.Unlock()
	fake.ConfigurationMatchingStub = nil
	fake.configurationMatchingReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) ConfigurationMatchingReturnsOnCall(i int, result1 []string) {
	fake.configurationMatchingMutex.Lock()
	defer fake.configurationMatchingMutex.Unlock()
	fake.ConfigurationMatchingStub = nil
	if fake.configurationMatchingReturnsOnCall == nil {
		fake.configurationMatchingReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.configurationMatchingReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) EnvList(arg1 context.Context, arg2 string) error {
	fake.envListMutex.Lock()
	ret, specificReturn := fake.envListReturnsOnCall[len(fake.envListArgsForCall)]
	fake.envListArgsForCall = append(fake.envListArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.EnvListStub
	fakeReturns := fake.envListReturns
	fake.recordInvocation("EnvList", []interface{}{arg1, arg2})
	fake.envListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) EnvListCallCount() int {
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	return len(fake.envListArgsForCall)
}

func (fake *FakeApplicationsService) EnvListCalls(stub func(context.Context, string) error) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = stub
}

func (fake *FakeApplicationsService) EnvListArgsForCall(i int) (context.Context, string) {
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	argsForCall := fake.envListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeApplicationsService) EnvListReturns(result1 error) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = nil
	fake.envListReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) EnvListReturnsOnCall(i int, result1 error) {
	fake.envListMutex.Lock()
	defer fake.envListMutex.Unlock()
	fake.EnvListStub = nil
	if fake.envListReturnsOnCall == nil {
		fake.envListReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.envListReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) EnvMatching(arg1 context.Context, arg2 string, arg3 string) []string {
	fake.envMatchingMutex.Lock()
	ret, specificReturn := fake.envMatchingReturnsOnCall[len(fake.envMatchingArgsForCall)]
	fake.envMatchingArgsForCall = append(fake.envMatchingArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvMatchingStub
	fakeReturns := fake.envMatchingReturns
	fake.recordInvocation("EnvMatching", []interface{}{arg1, arg2, arg3})
	fake.envMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) EnvMatchingCallCount() int {
	fake.envMatchingMutex.RLock()
	defer fake.envMatchingMutex.RUnlock()
	return len(fake.envMatchingArgsForCall)
}

func (fake *FakeApplicationsService) EnvMatchingCalls(stub func(context.Context, string, string) []string) {
	fake.envMatchingMutex.Lock()
	defer fake.envMatchingMutex.Unlock()
	fake.EnvMatchingStub = stub
}

func (fake *FakeApplicationsService) EnvMatchingArgsForCall(i int) (context.Context, string, string) {
	fake.envMatchingMutex.RLock()
	defer fake.envMatchingMutex.RUnlock()
	argsForCall := fake.envMatchingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeApplicationsService) EnvMatchingReturns(result1 []string) {
	fake.envMatchingMutex.Lock()
	defer fake.envMatchingMutex.Unlock()
	fake.EnvMatchingStub = nil
	fake.envMatchingReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) EnvMatchingReturnsOnCall(i int, result1 []string) {
	fake.envMatchingMutex.Lock()
	defer fake.envMatchingMutex.Unlock()
	fake.EnvMatchingStub = nil
	if fake.envMatchingReturnsOnCall == nil {
		fake.envMatchingReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.envMatchingReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) EnvSet(arg1 context.Context, arg2 string, arg3 string, arg4 string) error {
	fake.envSetMutex.Lock()
	ret, specificReturn := fake.envSetReturnsOnCall[len(fake.envSetArgsForCall)]
	fake.envSetArgsForCall = append(fake.envSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.EnvSetStub
	fakeReturns := fake.envSetReturns
	fake.recordInvocation("EnvSet", []interface{}{arg1, arg2, arg3, arg4})
	fake.envSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) EnvSetCallCount() int {
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	return len(fake.envSetArgsForCall)
}

func (fake *FakeApplicationsService) EnvSetCalls(stub func(context.Context, string, string, string) error) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = stub
}

func (fake *FakeApplicationsService) EnvSetArgsForCall(i int) (context.Context, string, string, string) {
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	argsForCall := fake.envSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeApplicationsService) EnvSetReturns(result1 error) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = nil
	fake.envSetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) EnvSetReturnsOnCall(i int, result1 error) {
	fake.envSetMutex.Lock()
	defer fake.envSetMutex.Unlock()
	fake.EnvSetStub = nil
	if fake.envSetReturnsOnCall == nil {
		fake.envSetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.envSetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) EnvShow(arg1 context.Context, arg2 string, arg3 string) error {
	fake.envShowMutex.Lock()
	ret, specificReturn := fake.envShowReturnsOnCall[len(fake.envShowArgsForCall)]
	fake.envShowArgsForCall = append(fake.envShowArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvShowStub
	fakeReturns := fake.envShowReturns
	fake.recordInvocation("EnvShow", []interface{}{arg1, arg2, arg3})
	fake.envShowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) EnvShowCallCount() int {
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	return len(fake.envShowArgsForCall)
}

func (fake *FakeApplicationsService) EnvShowCalls(stub func(context.Context, string, string) error) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = stub
}

func (fake *FakeApplicationsService) EnvShowArgsForCall(i int) (context.Context, string, string) {
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	argsForCall := fake.envShowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeApplicationsService) EnvShowReturns(result1 error) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = nil
	fake.envShowReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) EnvShowReturnsOnCall(i int, result1 error) {
	fake.envShowMutex.Lock()
	defer fake.envShowMutex.Unlock()
	fake.EnvShowStub = nil
	if fake.envShowReturnsOnCall == nil {
		fake.envShowReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.envShowReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) EnvUnset(arg1 context.Context, arg2 string, arg3 string) error {
	fake.envUnsetMutex.Lock()
	ret, specificReturn := fake.envUnsetReturnsOnCall[len(fake.envUnsetArgsForCall)]
	fake.envUnsetArgsForCall = append(fake.envUnsetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.EnvUnsetStub
	fakeReturns := fake.envUnsetReturns
	fake.recordInvocation("EnvUnset", []interface{}{arg1, arg2, arg3})
	fake.envUnsetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) EnvUnsetCallCount() int {
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	return len(fake.envUnsetArgsForCall)
}

func (fake *FakeApplicationsService) EnvUnsetCalls(stub func(context.Context, string, string) error) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = stub
}

func (fake *FakeApplicationsService) EnvUnsetArgsForCall(i int) (context.Context, string, string) {
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	argsForCall := fake.envUnsetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeApplicationsService) EnvUnsetReturns(result1 error) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = nil
	fake.envUnsetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) EnvUnsetReturnsOnCall(i int, result1 error) {
	fake.envUnsetMutex.Lock()
	defer fake.envUnsetMutex.Unlock()
	fake.EnvUnsetStub = nil
	if fake.envUnsetReturnsOnCall == nil {
		fake.envUnsetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.envUnsetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeApplicationsService) ExportregistryMatching(arg1 string) []string {
	fake.exportregistryMatchingMutex.Lock()
	ret, specificReturn := fake.exportregistryMatchingReturnsOnCall[len(fake.exportregistryMatchingArgsForCall)]
	fake.exportregistryMatchingArgsForCall = append(fake.exportregistryMatchingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExportregistryMatchingStub
	fakeReturns := fake.exportregistryMatchingReturns
	fake.recordInvocation("ExportregistryMatching", []interface{}{arg1})
	fake.exportregistryMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) ExportregistryMatchingCallCount() int {
	fake.exportregistryMatchingMutex.RLock()
	defer fake.exportregistryMatchingMutex.RUnlock()
	return len(fake.exportregistryMatchingArgsForCall)
}

func (fake *FakeApplicationsService) ExportregistryMatchingCalls(stub func(string) []string) {
	fake.exportregistryMatchingMutex.Lock()
	defer fake.exportregistryMatchingMutex.Unlock()
	fake.ExportregistryMatchingStub = stub
}

func (fake *FakeApplicationsService) ExportregistryMatchingArgsForCall(i int) string {
	fake.exportregistryMatchingMutex.RLock()
	defer fake.exportregistryMatchingMutex.RUnlock()
	argsForCall := fake.exportregistryMatchingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeApplicationsService) ExportregistryMatchingReturns(result1 []string) {
	fake.exportregistryMatchingMutex.Lock()
	defer fake.exportregistryMatchingMutex.Unlock()
	fake.ExportregistryMatchingStub = nil
	fake.exportregistryMatchingReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) ExportregistryMatchingReturnsOnCall(i int, result1 []string) {
	fake.exportregistryMatchingMutex.Lock()
	defer fake.exportregistryMatchingMutex.Unlock()
	fake.ExportregistryMatchingStub = nil
	if fake.exportregistryMatchingReturnsOnCall == nil {
		fake.exportregistryMatchingReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.exportregistryMatchingReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeApplicationsService) GetAPI() usercmd.APIClient {
	fake.getAPIMutex.Lock()
	ret, specificReturn := fake.getAPIReturnsOnCall[len(fake.getAPIArgsForCall)]
	fake.getAPIArgsForCall = append(fake.getAPIArgsForCall, struct {
	}{})
	stub := fake.GetAPIStub
	fakeReturns := fake.getAPIReturns
	fake.recordInvocation("GetAPI", []interface{}{})
	fake.getAPIMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeApplicationsService) GetAPICallCount() int {
	fake.getAPIMutex.RLock()
	defer fake.getAPIMutex.RUnlock()
	return len(fake.getAPIArgsForCall)
}

func (fake *FakeApplicationsService) GetAPICalls(stub func() usercmd.APIClient) {
	fake.getAPIMutex.Lock()
	defer fake.getAPIMutex.Unlock()
	fake.GetAPIStub = stub
}

func (fake *FakeApplicationsService) GetAPIReturns(result1 usercmd.APIClient) {
	fake.getAPIMutex.Lock()
	defer fake.getAPIMutex.Unlock()
	fake.GetAPIStub = nil
	fake.getAPIReturns = struct {
		result1 usercmd.APIClient
	}{result1}
}

func (fake *FakeApplicationsService) GetAPIReturnsOnCall(i int, result1 usercmd.APIClient) {
	fake.getAPIMutex.Lock()
	defer fake.getAPIMutex.Unlock()
	fake.GetAPIStub = nil
	if fake.getAPIReturnsOnCall == nil {
		fake.getAPIReturnsOnCall = make(map[int]struct {
			result1 usercmd.APIClient
		})
	}
	fake.getAPIReturnsOnCall[i] = struct {
		result1 usercmd.APIClient
	}{result1}
}

func (fake *FakeApplicationsService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appCreateMutex.RLock()
	defer fake.appCreateMutex.RUnlock()
	fake.appDeleteMutex.RLock()
	defer fake.appDeleteMutex.RUnlock()
	fake.appExecMutex.RLock()
	defer fake.appExecMutex.RUnlock()
	fake.appExportMutex.RLock()
	defer fake.appExportMutex.RUnlock()
	fake.appLogsMutex.RLock()
	defer fake.appLogsMutex.RUnlock()
	fake.appManifestMutex.RLock()
	defer fake.appManifestMutex.RUnlock()
	fake.appPortForwardMutex.RLock()
	defer fake.appPortForwardMutex.RUnlock()
	fake.appPushMutex.RLock()
	defer fake.appPushMutex.RUnlock()
	fake.appRestageMutex.RLock()
	defer fake.appRestageMutex.RUnlock()
	fake.appRestartMutex.RLock()
	defer fake.appRestartMutex.RUnlock()
	fake.appShowMutex.RLock()
	defer fake.appShowMutex.RUnlock()
	fake.appStageIDMutex.RLock()
	defer fake.appStageIDMutex.RUnlock()
	fake.appUpdateMutex.RLock()
	defer fake.appUpdateMutex.RUnlock()
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	fake.appsMatchingMutex.RLock()
	defer fake.appsMatchingMutex.RUnlock()
	fake.chartDefaultSetMutex.RLock()
	defer fake.chartDefaultSetMutex.RUnlock()
	fake.chartDefaultShowMutex.RLock()
	defer fake.chartDefaultShowMutex.RUnlock()
	fake.chartListMutex.RLock()
	defer fake.chartListMutex.RUnlock()
	fake.chartMatchingMutex.RLock()
	defer fake.chartMatchingMutex.RUnlock()
	fake.chartShowMutex.RLock()
	defer fake.chartShowMutex.RUnlock()
	fake.configurationMatchingMutex.RLock()
	defer fake.configurationMatchingMutex.RUnlock()
	fake.envListMutex.RLock()
	defer fake.envListMutex.RUnlock()
	fake.envMatchingMutex.RLock()
	defer fake.envMatchingMutex.RUnlock()
	fake.envSetMutex.RLock()
	defer fake.envSetMutex.RUnlock()
	fake.envShowMutex.RLock()
	defer fake.envShowMutex.RUnlock()
	fake.envUnsetMutex.RLock()
	defer fake.envUnsetMutex.RUnlock()
	fake.exportregistryMatchingMutex.RLock()
	defer fake.exportregistryMatchingMutex.RUnlock()
	fake.getAPIMutex.RLock()
	defer fake.getAPIMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeApplicationsService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cmd.ApplicationsService = new(FakeApplicationsService)
